
polling_tc72temperatue_spi.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00002fa4  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         0000011e  00800060  00002fa4  00003038  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          0000000a  0080017e  0080017e  00003156  2**0
                  ALLOC
  3 .stab         00003ad4  00000000  00000000  00003158  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00002763  00000000  00000000  00006c2c  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 000001c0  00000000  00000000  0000938f  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_pubnames 0000020d  00000000  00000000  0000954f  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   0000250e  00000000  00000000  0000975c  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00001415  00000000  00000000  0000bc6a  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   000011a9  00000000  00000000  0000d07f  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  000001e0  00000000  00000000  0000e228  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    000002ce  00000000  00000000  0000e408  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    00000986  00000000  00000000  0000e6d6  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000050  00000000  00000000  0000f05c  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 3b 07 	jmp	0xe76	; 0xe76 <__vector_6>
      1c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d4 e0       	ldi	r29, 0x04	; 4
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	11 e0       	ldi	r17, 0x01	; 1
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	e4 ea       	ldi	r30, 0xA4	; 164
      68:	ff e2       	ldi	r31, 0x2F	; 47
      6a:	02 c0       	rjmp	.+4      	; 0x70 <.do_copy_data_start>

0000006c <.do_copy_data_loop>:
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0

00000070 <.do_copy_data_start>:
      70:	ae 37       	cpi	r26, 0x7E	; 126
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <.do_copy_data_loop>

00000076 <__do_clear_bss>:
      76:	11 e0       	ldi	r17, 0x01	; 1
      78:	ae e7       	ldi	r26, 0x7E	; 126
      7a:	b1 e0       	ldi	r27, 0x01	; 1
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	a8 38       	cpi	r26, 0x88	; 136
      82:	b1 07       	cpc	r27, r17
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 27 17 	call	0x2e4e	; 0x2e4e <main>
      8a:	0c 94 d0 17 	jmp	0x2fa0	; 0x2fa0 <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <__fixunssfsi>:
      92:	ef 92       	push	r14
      94:	ff 92       	push	r15
      96:	0f 93       	push	r16
      98:	1f 93       	push	r17
      9a:	7b 01       	movw	r14, r22
      9c:	8c 01       	movw	r16, r24
      9e:	20 e0       	ldi	r18, 0x00	; 0
      a0:	30 e0       	ldi	r19, 0x00	; 0
      a2:	40 e0       	ldi	r20, 0x00	; 0
      a4:	5f e4       	ldi	r21, 0x4F	; 79
      a6:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__gesf2>
      aa:	88 23       	and	r24, r24
      ac:	8c f0       	brlt	.+34     	; 0xd0 <__fixunssfsi+0x3e>
      ae:	c8 01       	movw	r24, r16
      b0:	b7 01       	movw	r22, r14
      b2:	20 e0       	ldi	r18, 0x00	; 0
      b4:	30 e0       	ldi	r19, 0x00	; 0
      b6:	40 e0       	ldi	r20, 0x00	; 0
      b8:	5f e4       	ldi	r21, 0x4F	; 79
      ba:	0e 94 c1 01 	call	0x382	; 0x382 <__subsf3>
      be:	0e 94 67 04 	call	0x8ce	; 0x8ce <__fixsfsi>
      c2:	9b 01       	movw	r18, r22
      c4:	ac 01       	movw	r20, r24
      c6:	20 50       	subi	r18, 0x00	; 0
      c8:	30 40       	sbci	r19, 0x00	; 0
      ca:	40 40       	sbci	r20, 0x00	; 0
      cc:	50 48       	sbci	r21, 0x80	; 128
      ce:	06 c0       	rjmp	.+12     	; 0xdc <__fixunssfsi+0x4a>
      d0:	c8 01       	movw	r24, r16
      d2:	b7 01       	movw	r22, r14
      d4:	0e 94 67 04 	call	0x8ce	; 0x8ce <__fixsfsi>
      d8:	9b 01       	movw	r18, r22
      da:	ac 01       	movw	r20, r24
      dc:	b9 01       	movw	r22, r18
      de:	ca 01       	movw	r24, r20
      e0:	1f 91       	pop	r17
      e2:	0f 91       	pop	r16
      e4:	ff 90       	pop	r15
      e6:	ef 90       	pop	r14
      e8:	08 95       	ret

000000ea <_fpadd_parts>:
      ea:	a0 e0       	ldi	r26, 0x00	; 0
      ec:	b0 e0       	ldi	r27, 0x00	; 0
      ee:	eb e7       	ldi	r30, 0x7B	; 123
      f0:	f0 e0       	ldi	r31, 0x00	; 0
      f2:	0c 94 68 17 	jmp	0x2ed0	; 0x2ed0 <__prologue_saves__>
      f6:	dc 01       	movw	r26, r24
      f8:	2b 01       	movw	r4, r22
      fa:	fa 01       	movw	r30, r20
      fc:	9c 91       	ld	r25, X
      fe:	92 30       	cpi	r25, 0x02	; 2
     100:	08 f4       	brcc	.+2      	; 0x104 <_fpadd_parts+0x1a>
     102:	39 c1       	rjmp	.+626    	; 0x376 <_fpadd_parts+0x28c>
     104:	eb 01       	movw	r28, r22
     106:	88 81       	ld	r24, Y
     108:	82 30       	cpi	r24, 0x02	; 2
     10a:	08 f4       	brcc	.+2      	; 0x10e <_fpadd_parts+0x24>
     10c:	33 c1       	rjmp	.+614    	; 0x374 <_fpadd_parts+0x28a>
     10e:	94 30       	cpi	r25, 0x04	; 4
     110:	69 f4       	brne	.+26     	; 0x12c <_fpadd_parts+0x42>
     112:	84 30       	cpi	r24, 0x04	; 4
     114:	09 f0       	breq	.+2      	; 0x118 <_fpadd_parts+0x2e>
     116:	2f c1       	rjmp	.+606    	; 0x376 <_fpadd_parts+0x28c>
     118:	11 96       	adiw	r26, 0x01	; 1
     11a:	9c 91       	ld	r25, X
     11c:	11 97       	sbiw	r26, 0x01	; 1
     11e:	89 81       	ldd	r24, Y+1	; 0x01
     120:	98 17       	cp	r25, r24
     122:	09 f4       	brne	.+2      	; 0x126 <_fpadd_parts+0x3c>
     124:	28 c1       	rjmp	.+592    	; 0x376 <_fpadd_parts+0x28c>
     126:	a2 e6       	ldi	r26, 0x62	; 98
     128:	b0 e0       	ldi	r27, 0x00	; 0
     12a:	25 c1       	rjmp	.+586    	; 0x376 <_fpadd_parts+0x28c>
     12c:	84 30       	cpi	r24, 0x04	; 4
     12e:	09 f4       	brne	.+2      	; 0x132 <_fpadd_parts+0x48>
     130:	21 c1       	rjmp	.+578    	; 0x374 <_fpadd_parts+0x28a>
     132:	82 30       	cpi	r24, 0x02	; 2
     134:	a9 f4       	brne	.+42     	; 0x160 <_fpadd_parts+0x76>
     136:	92 30       	cpi	r25, 0x02	; 2
     138:	09 f0       	breq	.+2      	; 0x13c <_fpadd_parts+0x52>
     13a:	1d c1       	rjmp	.+570    	; 0x376 <_fpadd_parts+0x28c>
     13c:	9a 01       	movw	r18, r20
     13e:	ad 01       	movw	r20, r26
     140:	88 e0       	ldi	r24, 0x08	; 8
     142:	ea 01       	movw	r28, r20
     144:	09 90       	ld	r0, Y+
     146:	ae 01       	movw	r20, r28
     148:	e9 01       	movw	r28, r18
     14a:	09 92       	st	Y+, r0
     14c:	9e 01       	movw	r18, r28
     14e:	81 50       	subi	r24, 0x01	; 1
     150:	c1 f7       	brne	.-16     	; 0x142 <_fpadd_parts+0x58>
     152:	e2 01       	movw	r28, r4
     154:	89 81       	ldd	r24, Y+1	; 0x01
     156:	11 96       	adiw	r26, 0x01	; 1
     158:	9c 91       	ld	r25, X
     15a:	89 23       	and	r24, r25
     15c:	81 83       	std	Z+1, r24	; 0x01
     15e:	08 c1       	rjmp	.+528    	; 0x370 <_fpadd_parts+0x286>
     160:	92 30       	cpi	r25, 0x02	; 2
     162:	09 f4       	brne	.+2      	; 0x166 <_fpadd_parts+0x7c>
     164:	07 c1       	rjmp	.+526    	; 0x374 <_fpadd_parts+0x28a>
     166:	12 96       	adiw	r26, 0x02	; 2
     168:	2d 90       	ld	r2, X+
     16a:	3c 90       	ld	r3, X
     16c:	13 97       	sbiw	r26, 0x03	; 3
     16e:	eb 01       	movw	r28, r22
     170:	8a 81       	ldd	r24, Y+2	; 0x02
     172:	9b 81       	ldd	r25, Y+3	; 0x03
     174:	14 96       	adiw	r26, 0x04	; 4
     176:	ad 90       	ld	r10, X+
     178:	bd 90       	ld	r11, X+
     17a:	cd 90       	ld	r12, X+
     17c:	dc 90       	ld	r13, X
     17e:	17 97       	sbiw	r26, 0x07	; 7
     180:	ec 80       	ldd	r14, Y+4	; 0x04
     182:	fd 80       	ldd	r15, Y+5	; 0x05
     184:	0e 81       	ldd	r16, Y+6	; 0x06
     186:	1f 81       	ldd	r17, Y+7	; 0x07
     188:	91 01       	movw	r18, r2
     18a:	28 1b       	sub	r18, r24
     18c:	39 0b       	sbc	r19, r25
     18e:	b9 01       	movw	r22, r18
     190:	37 ff       	sbrs	r19, 7
     192:	04 c0       	rjmp	.+8      	; 0x19c <_fpadd_parts+0xb2>
     194:	66 27       	eor	r22, r22
     196:	77 27       	eor	r23, r23
     198:	62 1b       	sub	r22, r18
     19a:	73 0b       	sbc	r23, r19
     19c:	60 32       	cpi	r22, 0x20	; 32
     19e:	71 05       	cpc	r23, r1
     1a0:	0c f0       	brlt	.+2      	; 0x1a4 <_fpadd_parts+0xba>
     1a2:	61 c0       	rjmp	.+194    	; 0x266 <_fpadd_parts+0x17c>
     1a4:	12 16       	cp	r1, r18
     1a6:	13 06       	cpc	r1, r19
     1a8:	6c f5       	brge	.+90     	; 0x204 <_fpadd_parts+0x11a>
     1aa:	37 01       	movw	r6, r14
     1ac:	48 01       	movw	r8, r16
     1ae:	06 2e       	mov	r0, r22
     1b0:	04 c0       	rjmp	.+8      	; 0x1ba <_fpadd_parts+0xd0>
     1b2:	96 94       	lsr	r9
     1b4:	87 94       	ror	r8
     1b6:	77 94       	ror	r7
     1b8:	67 94       	ror	r6
     1ba:	0a 94       	dec	r0
     1bc:	d2 f7       	brpl	.-12     	; 0x1b2 <_fpadd_parts+0xc8>
     1be:	21 e0       	ldi	r18, 0x01	; 1
     1c0:	30 e0       	ldi	r19, 0x00	; 0
     1c2:	40 e0       	ldi	r20, 0x00	; 0
     1c4:	50 e0       	ldi	r21, 0x00	; 0
     1c6:	04 c0       	rjmp	.+8      	; 0x1d0 <_fpadd_parts+0xe6>
     1c8:	22 0f       	add	r18, r18
     1ca:	33 1f       	adc	r19, r19
     1cc:	44 1f       	adc	r20, r20
     1ce:	55 1f       	adc	r21, r21
     1d0:	6a 95       	dec	r22
     1d2:	d2 f7       	brpl	.-12     	; 0x1c8 <_fpadd_parts+0xde>
     1d4:	21 50       	subi	r18, 0x01	; 1
     1d6:	30 40       	sbci	r19, 0x00	; 0
     1d8:	40 40       	sbci	r20, 0x00	; 0
     1da:	50 40       	sbci	r21, 0x00	; 0
     1dc:	2e 21       	and	r18, r14
     1de:	3f 21       	and	r19, r15
     1e0:	40 23       	and	r20, r16
     1e2:	51 23       	and	r21, r17
     1e4:	21 15       	cp	r18, r1
     1e6:	31 05       	cpc	r19, r1
     1e8:	41 05       	cpc	r20, r1
     1ea:	51 05       	cpc	r21, r1
     1ec:	21 f0       	breq	.+8      	; 0x1f6 <_fpadd_parts+0x10c>
     1ee:	21 e0       	ldi	r18, 0x01	; 1
     1f0:	30 e0       	ldi	r19, 0x00	; 0
     1f2:	40 e0       	ldi	r20, 0x00	; 0
     1f4:	50 e0       	ldi	r21, 0x00	; 0
     1f6:	79 01       	movw	r14, r18
     1f8:	8a 01       	movw	r16, r20
     1fa:	e6 28       	or	r14, r6
     1fc:	f7 28       	or	r15, r7
     1fe:	08 29       	or	r16, r8
     200:	19 29       	or	r17, r9
     202:	3c c0       	rjmp	.+120    	; 0x27c <_fpadd_parts+0x192>
     204:	23 2b       	or	r18, r19
     206:	d1 f1       	breq	.+116    	; 0x27c <_fpadd_parts+0x192>
     208:	26 0e       	add	r2, r22
     20a:	37 1e       	adc	r3, r23
     20c:	35 01       	movw	r6, r10
     20e:	46 01       	movw	r8, r12
     210:	06 2e       	mov	r0, r22
     212:	04 c0       	rjmp	.+8      	; 0x21c <_fpadd_parts+0x132>
     214:	96 94       	lsr	r9
     216:	87 94       	ror	r8
     218:	77 94       	ror	r7
     21a:	67 94       	ror	r6
     21c:	0a 94       	dec	r0
     21e:	d2 f7       	brpl	.-12     	; 0x214 <_fpadd_parts+0x12a>
     220:	21 e0       	ldi	r18, 0x01	; 1
     222:	30 e0       	ldi	r19, 0x00	; 0
     224:	40 e0       	ldi	r20, 0x00	; 0
     226:	50 e0       	ldi	r21, 0x00	; 0
     228:	04 c0       	rjmp	.+8      	; 0x232 <_fpadd_parts+0x148>
     22a:	22 0f       	add	r18, r18
     22c:	33 1f       	adc	r19, r19
     22e:	44 1f       	adc	r20, r20
     230:	55 1f       	adc	r21, r21
     232:	6a 95       	dec	r22
     234:	d2 f7       	brpl	.-12     	; 0x22a <_fpadd_parts+0x140>
     236:	21 50       	subi	r18, 0x01	; 1
     238:	30 40       	sbci	r19, 0x00	; 0
     23a:	40 40       	sbci	r20, 0x00	; 0
     23c:	50 40       	sbci	r21, 0x00	; 0
     23e:	2a 21       	and	r18, r10
     240:	3b 21       	and	r19, r11
     242:	4c 21       	and	r20, r12
     244:	5d 21       	and	r21, r13
     246:	21 15       	cp	r18, r1
     248:	31 05       	cpc	r19, r1
     24a:	41 05       	cpc	r20, r1
     24c:	51 05       	cpc	r21, r1
     24e:	21 f0       	breq	.+8      	; 0x258 <_fpadd_parts+0x16e>
     250:	21 e0       	ldi	r18, 0x01	; 1
     252:	30 e0       	ldi	r19, 0x00	; 0
     254:	40 e0       	ldi	r20, 0x00	; 0
     256:	50 e0       	ldi	r21, 0x00	; 0
     258:	59 01       	movw	r10, r18
     25a:	6a 01       	movw	r12, r20
     25c:	a6 28       	or	r10, r6
     25e:	b7 28       	or	r11, r7
     260:	c8 28       	or	r12, r8
     262:	d9 28       	or	r13, r9
     264:	0b c0       	rjmp	.+22     	; 0x27c <_fpadd_parts+0x192>
     266:	82 15       	cp	r24, r2
     268:	93 05       	cpc	r25, r3
     26a:	2c f0       	brlt	.+10     	; 0x276 <_fpadd_parts+0x18c>
     26c:	1c 01       	movw	r2, r24
     26e:	aa 24       	eor	r10, r10
     270:	bb 24       	eor	r11, r11
     272:	65 01       	movw	r12, r10
     274:	03 c0       	rjmp	.+6      	; 0x27c <_fpadd_parts+0x192>
     276:	ee 24       	eor	r14, r14
     278:	ff 24       	eor	r15, r15
     27a:	87 01       	movw	r16, r14
     27c:	11 96       	adiw	r26, 0x01	; 1
     27e:	9c 91       	ld	r25, X
     280:	d2 01       	movw	r26, r4
     282:	11 96       	adiw	r26, 0x01	; 1
     284:	8c 91       	ld	r24, X
     286:	98 17       	cp	r25, r24
     288:	09 f4       	brne	.+2      	; 0x28c <_fpadd_parts+0x1a2>
     28a:	45 c0       	rjmp	.+138    	; 0x316 <_fpadd_parts+0x22c>
     28c:	99 23       	and	r25, r25
     28e:	39 f0       	breq	.+14     	; 0x29e <_fpadd_parts+0x1b4>
     290:	a8 01       	movw	r20, r16
     292:	97 01       	movw	r18, r14
     294:	2a 19       	sub	r18, r10
     296:	3b 09       	sbc	r19, r11
     298:	4c 09       	sbc	r20, r12
     29a:	5d 09       	sbc	r21, r13
     29c:	06 c0       	rjmp	.+12     	; 0x2aa <_fpadd_parts+0x1c0>
     29e:	a6 01       	movw	r20, r12
     2a0:	95 01       	movw	r18, r10
     2a2:	2e 19       	sub	r18, r14
     2a4:	3f 09       	sbc	r19, r15
     2a6:	40 0b       	sbc	r20, r16
     2a8:	51 0b       	sbc	r21, r17
     2aa:	57 fd       	sbrc	r21, 7
     2ac:	08 c0       	rjmp	.+16     	; 0x2be <_fpadd_parts+0x1d4>
     2ae:	11 82       	std	Z+1, r1	; 0x01
     2b0:	33 82       	std	Z+3, r3	; 0x03
     2b2:	22 82       	std	Z+2, r2	; 0x02
     2b4:	24 83       	std	Z+4, r18	; 0x04
     2b6:	35 83       	std	Z+5, r19	; 0x05
     2b8:	46 83       	std	Z+6, r20	; 0x06
     2ba:	57 83       	std	Z+7, r21	; 0x07
     2bc:	1d c0       	rjmp	.+58     	; 0x2f8 <_fpadd_parts+0x20e>
     2be:	81 e0       	ldi	r24, 0x01	; 1
     2c0:	81 83       	std	Z+1, r24	; 0x01
     2c2:	33 82       	std	Z+3, r3	; 0x03
     2c4:	22 82       	std	Z+2, r2	; 0x02
     2c6:	88 27       	eor	r24, r24
     2c8:	99 27       	eor	r25, r25
     2ca:	dc 01       	movw	r26, r24
     2cc:	82 1b       	sub	r24, r18
     2ce:	93 0b       	sbc	r25, r19
     2d0:	a4 0b       	sbc	r26, r20
     2d2:	b5 0b       	sbc	r27, r21
     2d4:	84 83       	std	Z+4, r24	; 0x04
     2d6:	95 83       	std	Z+5, r25	; 0x05
     2d8:	a6 83       	std	Z+6, r26	; 0x06
     2da:	b7 83       	std	Z+7, r27	; 0x07
     2dc:	0d c0       	rjmp	.+26     	; 0x2f8 <_fpadd_parts+0x20e>
     2de:	22 0f       	add	r18, r18
     2e0:	33 1f       	adc	r19, r19
     2e2:	44 1f       	adc	r20, r20
     2e4:	55 1f       	adc	r21, r21
     2e6:	24 83       	std	Z+4, r18	; 0x04
     2e8:	35 83       	std	Z+5, r19	; 0x05
     2ea:	46 83       	std	Z+6, r20	; 0x06
     2ec:	57 83       	std	Z+7, r21	; 0x07
     2ee:	82 81       	ldd	r24, Z+2	; 0x02
     2f0:	93 81       	ldd	r25, Z+3	; 0x03
     2f2:	01 97       	sbiw	r24, 0x01	; 1
     2f4:	93 83       	std	Z+3, r25	; 0x03
     2f6:	82 83       	std	Z+2, r24	; 0x02
     2f8:	24 81       	ldd	r18, Z+4	; 0x04
     2fa:	35 81       	ldd	r19, Z+5	; 0x05
     2fc:	46 81       	ldd	r20, Z+6	; 0x06
     2fe:	57 81       	ldd	r21, Z+7	; 0x07
     300:	da 01       	movw	r26, r20
     302:	c9 01       	movw	r24, r18
     304:	01 97       	sbiw	r24, 0x01	; 1
     306:	a1 09       	sbc	r26, r1
     308:	b1 09       	sbc	r27, r1
     30a:	8f 5f       	subi	r24, 0xFF	; 255
     30c:	9f 4f       	sbci	r25, 0xFF	; 255
     30e:	af 4f       	sbci	r26, 0xFF	; 255
     310:	bf 43       	sbci	r27, 0x3F	; 63
     312:	28 f3       	brcs	.-54     	; 0x2de <_fpadd_parts+0x1f4>
     314:	0b c0       	rjmp	.+22     	; 0x32c <_fpadd_parts+0x242>
     316:	91 83       	std	Z+1, r25	; 0x01
     318:	33 82       	std	Z+3, r3	; 0x03
     31a:	22 82       	std	Z+2, r2	; 0x02
     31c:	ea 0c       	add	r14, r10
     31e:	fb 1c       	adc	r15, r11
     320:	0c 1d       	adc	r16, r12
     322:	1d 1d       	adc	r17, r13
     324:	e4 82       	std	Z+4, r14	; 0x04
     326:	f5 82       	std	Z+5, r15	; 0x05
     328:	06 83       	std	Z+6, r16	; 0x06
     32a:	17 83       	std	Z+7, r17	; 0x07
     32c:	83 e0       	ldi	r24, 0x03	; 3
     32e:	80 83       	st	Z, r24
     330:	24 81       	ldd	r18, Z+4	; 0x04
     332:	35 81       	ldd	r19, Z+5	; 0x05
     334:	46 81       	ldd	r20, Z+6	; 0x06
     336:	57 81       	ldd	r21, Z+7	; 0x07
     338:	57 ff       	sbrs	r21, 7
     33a:	1a c0       	rjmp	.+52     	; 0x370 <_fpadd_parts+0x286>
     33c:	c9 01       	movw	r24, r18
     33e:	aa 27       	eor	r26, r26
     340:	97 fd       	sbrc	r25, 7
     342:	a0 95       	com	r26
     344:	ba 2f       	mov	r27, r26
     346:	81 70       	andi	r24, 0x01	; 1
     348:	90 70       	andi	r25, 0x00	; 0
     34a:	a0 70       	andi	r26, 0x00	; 0
     34c:	b0 70       	andi	r27, 0x00	; 0
     34e:	56 95       	lsr	r21
     350:	47 95       	ror	r20
     352:	37 95       	ror	r19
     354:	27 95       	ror	r18
     356:	82 2b       	or	r24, r18
     358:	93 2b       	or	r25, r19
     35a:	a4 2b       	or	r26, r20
     35c:	b5 2b       	or	r27, r21
     35e:	84 83       	std	Z+4, r24	; 0x04
     360:	95 83       	std	Z+5, r25	; 0x05
     362:	a6 83       	std	Z+6, r26	; 0x06
     364:	b7 83       	std	Z+7, r27	; 0x07
     366:	82 81       	ldd	r24, Z+2	; 0x02
     368:	93 81       	ldd	r25, Z+3	; 0x03
     36a:	01 96       	adiw	r24, 0x01	; 1
     36c:	93 83       	std	Z+3, r25	; 0x03
     36e:	82 83       	std	Z+2, r24	; 0x02
     370:	df 01       	movw	r26, r30
     372:	01 c0       	rjmp	.+2      	; 0x376 <_fpadd_parts+0x28c>
     374:	d2 01       	movw	r26, r4
     376:	cd 01       	movw	r24, r26
     378:	cd b7       	in	r28, 0x3d	; 61
     37a:	de b7       	in	r29, 0x3e	; 62
     37c:	e2 e1       	ldi	r30, 0x12	; 18
     37e:	0c 94 84 17 	jmp	0x2f08	; 0x2f08 <__epilogue_restores__>

00000382 <__subsf3>:
     382:	a0 e2       	ldi	r26, 0x20	; 32
     384:	b0 e0       	ldi	r27, 0x00	; 0
     386:	e7 ec       	ldi	r30, 0xC7	; 199
     388:	f1 e0       	ldi	r31, 0x01	; 1
     38a:	0c 94 74 17 	jmp	0x2ee8	; 0x2ee8 <__prologue_saves__+0x18>
     38e:	69 83       	std	Y+1, r22	; 0x01
     390:	7a 83       	std	Y+2, r23	; 0x02
     392:	8b 83       	std	Y+3, r24	; 0x03
     394:	9c 83       	std	Y+4, r25	; 0x04
     396:	2d 83       	std	Y+5, r18	; 0x05
     398:	3e 83       	std	Y+6, r19	; 0x06
     39a:	4f 83       	std	Y+7, r20	; 0x07
     39c:	58 87       	std	Y+8, r21	; 0x08
     39e:	e9 e0       	ldi	r30, 0x09	; 9
     3a0:	ee 2e       	mov	r14, r30
     3a2:	f1 2c       	mov	r15, r1
     3a4:	ec 0e       	add	r14, r28
     3a6:	fd 1e       	adc	r15, r29
     3a8:	ce 01       	movw	r24, r28
     3aa:	01 96       	adiw	r24, 0x01	; 1
     3ac:	b7 01       	movw	r22, r14
     3ae:	0e 94 df 05 	call	0xbbe	; 0xbbe <__unpack_f>
     3b2:	8e 01       	movw	r16, r28
     3b4:	0f 5e       	subi	r16, 0xEF	; 239
     3b6:	1f 4f       	sbci	r17, 0xFF	; 255
     3b8:	ce 01       	movw	r24, r28
     3ba:	05 96       	adiw	r24, 0x05	; 5
     3bc:	b8 01       	movw	r22, r16
     3be:	0e 94 df 05 	call	0xbbe	; 0xbbe <__unpack_f>
     3c2:	8a 89       	ldd	r24, Y+18	; 0x12
     3c4:	91 e0       	ldi	r25, 0x01	; 1
     3c6:	89 27       	eor	r24, r25
     3c8:	8a 8b       	std	Y+18, r24	; 0x12
     3ca:	c7 01       	movw	r24, r14
     3cc:	b8 01       	movw	r22, r16
     3ce:	ae 01       	movw	r20, r28
     3d0:	47 5e       	subi	r20, 0xE7	; 231
     3d2:	5f 4f       	sbci	r21, 0xFF	; 255
     3d4:	0e 94 75 00 	call	0xea	; 0xea <_fpadd_parts>
     3d8:	0e 94 0a 05 	call	0xa14	; 0xa14 <__pack_f>
     3dc:	a0 96       	adiw	r28, 0x20	; 32
     3de:	e6 e0       	ldi	r30, 0x06	; 6
     3e0:	0c 94 90 17 	jmp	0x2f20	; 0x2f20 <__epilogue_restores__+0x18>

000003e4 <__addsf3>:
     3e4:	a0 e2       	ldi	r26, 0x20	; 32
     3e6:	b0 e0       	ldi	r27, 0x00	; 0
     3e8:	e8 ef       	ldi	r30, 0xF8	; 248
     3ea:	f1 e0       	ldi	r31, 0x01	; 1
     3ec:	0c 94 74 17 	jmp	0x2ee8	; 0x2ee8 <__prologue_saves__+0x18>
     3f0:	69 83       	std	Y+1, r22	; 0x01
     3f2:	7a 83       	std	Y+2, r23	; 0x02
     3f4:	8b 83       	std	Y+3, r24	; 0x03
     3f6:	9c 83       	std	Y+4, r25	; 0x04
     3f8:	2d 83       	std	Y+5, r18	; 0x05
     3fa:	3e 83       	std	Y+6, r19	; 0x06
     3fc:	4f 83       	std	Y+7, r20	; 0x07
     3fe:	58 87       	std	Y+8, r21	; 0x08
     400:	f9 e0       	ldi	r31, 0x09	; 9
     402:	ef 2e       	mov	r14, r31
     404:	f1 2c       	mov	r15, r1
     406:	ec 0e       	add	r14, r28
     408:	fd 1e       	adc	r15, r29
     40a:	ce 01       	movw	r24, r28
     40c:	01 96       	adiw	r24, 0x01	; 1
     40e:	b7 01       	movw	r22, r14
     410:	0e 94 df 05 	call	0xbbe	; 0xbbe <__unpack_f>
     414:	8e 01       	movw	r16, r28
     416:	0f 5e       	subi	r16, 0xEF	; 239
     418:	1f 4f       	sbci	r17, 0xFF	; 255
     41a:	ce 01       	movw	r24, r28
     41c:	05 96       	adiw	r24, 0x05	; 5
     41e:	b8 01       	movw	r22, r16
     420:	0e 94 df 05 	call	0xbbe	; 0xbbe <__unpack_f>
     424:	c7 01       	movw	r24, r14
     426:	b8 01       	movw	r22, r16
     428:	ae 01       	movw	r20, r28
     42a:	47 5e       	subi	r20, 0xE7	; 231
     42c:	5f 4f       	sbci	r21, 0xFF	; 255
     42e:	0e 94 75 00 	call	0xea	; 0xea <_fpadd_parts>
     432:	0e 94 0a 05 	call	0xa14	; 0xa14 <__pack_f>
     436:	a0 96       	adiw	r28, 0x20	; 32
     438:	e6 e0       	ldi	r30, 0x06	; 6
     43a:	0c 94 90 17 	jmp	0x2f20	; 0x2f20 <__epilogue_restores__+0x18>

0000043e <__mulsf3>:
     43e:	a0 e2       	ldi	r26, 0x20	; 32
     440:	b0 e0       	ldi	r27, 0x00	; 0
     442:	e5 e2       	ldi	r30, 0x25	; 37
     444:	f2 e0       	ldi	r31, 0x02	; 2
     446:	0c 94 68 17 	jmp	0x2ed0	; 0x2ed0 <__prologue_saves__>
     44a:	69 83       	std	Y+1, r22	; 0x01
     44c:	7a 83       	std	Y+2, r23	; 0x02
     44e:	8b 83       	std	Y+3, r24	; 0x03
     450:	9c 83       	std	Y+4, r25	; 0x04
     452:	2d 83       	std	Y+5, r18	; 0x05
     454:	3e 83       	std	Y+6, r19	; 0x06
     456:	4f 83       	std	Y+7, r20	; 0x07
     458:	58 87       	std	Y+8, r21	; 0x08
     45a:	ce 01       	movw	r24, r28
     45c:	01 96       	adiw	r24, 0x01	; 1
     45e:	be 01       	movw	r22, r28
     460:	67 5f       	subi	r22, 0xF7	; 247
     462:	7f 4f       	sbci	r23, 0xFF	; 255
     464:	0e 94 df 05 	call	0xbbe	; 0xbbe <__unpack_f>
     468:	ce 01       	movw	r24, r28
     46a:	05 96       	adiw	r24, 0x05	; 5
     46c:	be 01       	movw	r22, r28
     46e:	6f 5e       	subi	r22, 0xEF	; 239
     470:	7f 4f       	sbci	r23, 0xFF	; 255
     472:	0e 94 df 05 	call	0xbbe	; 0xbbe <__unpack_f>
     476:	99 85       	ldd	r25, Y+9	; 0x09
     478:	92 30       	cpi	r25, 0x02	; 2
     47a:	88 f0       	brcs	.+34     	; 0x49e <__stack+0x3f>
     47c:	89 89       	ldd	r24, Y+17	; 0x11
     47e:	82 30       	cpi	r24, 0x02	; 2
     480:	c8 f0       	brcs	.+50     	; 0x4b4 <__stack+0x55>
     482:	94 30       	cpi	r25, 0x04	; 4
     484:	19 f4       	brne	.+6      	; 0x48c <__stack+0x2d>
     486:	82 30       	cpi	r24, 0x02	; 2
     488:	51 f4       	brne	.+20     	; 0x49e <__stack+0x3f>
     48a:	04 c0       	rjmp	.+8      	; 0x494 <__stack+0x35>
     48c:	84 30       	cpi	r24, 0x04	; 4
     48e:	29 f4       	brne	.+10     	; 0x49a <__stack+0x3b>
     490:	92 30       	cpi	r25, 0x02	; 2
     492:	81 f4       	brne	.+32     	; 0x4b4 <__stack+0x55>
     494:	82 e6       	ldi	r24, 0x62	; 98
     496:	90 e0       	ldi	r25, 0x00	; 0
     498:	c6 c0       	rjmp	.+396    	; 0x626 <__stack+0x1c7>
     49a:	92 30       	cpi	r25, 0x02	; 2
     49c:	49 f4       	brne	.+18     	; 0x4b0 <__stack+0x51>
     49e:	20 e0       	ldi	r18, 0x00	; 0
     4a0:	9a 85       	ldd	r25, Y+10	; 0x0a
     4a2:	8a 89       	ldd	r24, Y+18	; 0x12
     4a4:	98 13       	cpse	r25, r24
     4a6:	21 e0       	ldi	r18, 0x01	; 1
     4a8:	2a 87       	std	Y+10, r18	; 0x0a
     4aa:	ce 01       	movw	r24, r28
     4ac:	09 96       	adiw	r24, 0x09	; 9
     4ae:	bb c0       	rjmp	.+374    	; 0x626 <__stack+0x1c7>
     4b0:	82 30       	cpi	r24, 0x02	; 2
     4b2:	49 f4       	brne	.+18     	; 0x4c6 <__stack+0x67>
     4b4:	20 e0       	ldi	r18, 0x00	; 0
     4b6:	9a 85       	ldd	r25, Y+10	; 0x0a
     4b8:	8a 89       	ldd	r24, Y+18	; 0x12
     4ba:	98 13       	cpse	r25, r24
     4bc:	21 e0       	ldi	r18, 0x01	; 1
     4be:	2a 8b       	std	Y+18, r18	; 0x12
     4c0:	ce 01       	movw	r24, r28
     4c2:	41 96       	adiw	r24, 0x11	; 17
     4c4:	b0 c0       	rjmp	.+352    	; 0x626 <__stack+0x1c7>
     4c6:	2d 84       	ldd	r2, Y+13	; 0x0d
     4c8:	3e 84       	ldd	r3, Y+14	; 0x0e
     4ca:	4f 84       	ldd	r4, Y+15	; 0x0f
     4cc:	58 88       	ldd	r5, Y+16	; 0x10
     4ce:	6d 88       	ldd	r6, Y+21	; 0x15
     4d0:	7e 88       	ldd	r7, Y+22	; 0x16
     4d2:	8f 88       	ldd	r8, Y+23	; 0x17
     4d4:	98 8c       	ldd	r9, Y+24	; 0x18
     4d6:	ee 24       	eor	r14, r14
     4d8:	ff 24       	eor	r15, r15
     4da:	87 01       	movw	r16, r14
     4dc:	aa 24       	eor	r10, r10
     4de:	bb 24       	eor	r11, r11
     4e0:	65 01       	movw	r12, r10
     4e2:	40 e0       	ldi	r20, 0x00	; 0
     4e4:	50 e0       	ldi	r21, 0x00	; 0
     4e6:	60 e0       	ldi	r22, 0x00	; 0
     4e8:	70 e0       	ldi	r23, 0x00	; 0
     4ea:	e0 e0       	ldi	r30, 0x00	; 0
     4ec:	f0 e0       	ldi	r31, 0x00	; 0
     4ee:	c1 01       	movw	r24, r2
     4f0:	81 70       	andi	r24, 0x01	; 1
     4f2:	90 70       	andi	r25, 0x00	; 0
     4f4:	89 2b       	or	r24, r25
     4f6:	e9 f0       	breq	.+58     	; 0x532 <__stack+0xd3>
     4f8:	e6 0c       	add	r14, r6
     4fa:	f7 1c       	adc	r15, r7
     4fc:	08 1d       	adc	r16, r8
     4fe:	19 1d       	adc	r17, r9
     500:	9a 01       	movw	r18, r20
     502:	ab 01       	movw	r20, r22
     504:	2a 0d       	add	r18, r10
     506:	3b 1d       	adc	r19, r11
     508:	4c 1d       	adc	r20, r12
     50a:	5d 1d       	adc	r21, r13
     50c:	80 e0       	ldi	r24, 0x00	; 0
     50e:	90 e0       	ldi	r25, 0x00	; 0
     510:	a0 e0       	ldi	r26, 0x00	; 0
     512:	b0 e0       	ldi	r27, 0x00	; 0
     514:	e6 14       	cp	r14, r6
     516:	f7 04       	cpc	r15, r7
     518:	08 05       	cpc	r16, r8
     51a:	19 05       	cpc	r17, r9
     51c:	20 f4       	brcc	.+8      	; 0x526 <__stack+0xc7>
     51e:	81 e0       	ldi	r24, 0x01	; 1
     520:	90 e0       	ldi	r25, 0x00	; 0
     522:	a0 e0       	ldi	r26, 0x00	; 0
     524:	b0 e0       	ldi	r27, 0x00	; 0
     526:	ba 01       	movw	r22, r20
     528:	a9 01       	movw	r20, r18
     52a:	48 0f       	add	r20, r24
     52c:	59 1f       	adc	r21, r25
     52e:	6a 1f       	adc	r22, r26
     530:	7b 1f       	adc	r23, r27
     532:	aa 0c       	add	r10, r10
     534:	bb 1c       	adc	r11, r11
     536:	cc 1c       	adc	r12, r12
     538:	dd 1c       	adc	r13, r13
     53a:	97 fe       	sbrs	r9, 7
     53c:	08 c0       	rjmp	.+16     	; 0x54e <__stack+0xef>
     53e:	81 e0       	ldi	r24, 0x01	; 1
     540:	90 e0       	ldi	r25, 0x00	; 0
     542:	a0 e0       	ldi	r26, 0x00	; 0
     544:	b0 e0       	ldi	r27, 0x00	; 0
     546:	a8 2a       	or	r10, r24
     548:	b9 2a       	or	r11, r25
     54a:	ca 2a       	or	r12, r26
     54c:	db 2a       	or	r13, r27
     54e:	31 96       	adiw	r30, 0x01	; 1
     550:	e0 32       	cpi	r30, 0x20	; 32
     552:	f1 05       	cpc	r31, r1
     554:	49 f0       	breq	.+18     	; 0x568 <__stack+0x109>
     556:	66 0c       	add	r6, r6
     558:	77 1c       	adc	r7, r7
     55a:	88 1c       	adc	r8, r8
     55c:	99 1c       	adc	r9, r9
     55e:	56 94       	lsr	r5
     560:	47 94       	ror	r4
     562:	37 94       	ror	r3
     564:	27 94       	ror	r2
     566:	c3 cf       	rjmp	.-122    	; 0x4ee <__stack+0x8f>
     568:	fa 85       	ldd	r31, Y+10	; 0x0a
     56a:	ea 89       	ldd	r30, Y+18	; 0x12
     56c:	2b 89       	ldd	r18, Y+19	; 0x13
     56e:	3c 89       	ldd	r19, Y+20	; 0x14
     570:	8b 85       	ldd	r24, Y+11	; 0x0b
     572:	9c 85       	ldd	r25, Y+12	; 0x0c
     574:	28 0f       	add	r18, r24
     576:	39 1f       	adc	r19, r25
     578:	2e 5f       	subi	r18, 0xFE	; 254
     57a:	3f 4f       	sbci	r19, 0xFF	; 255
     57c:	17 c0       	rjmp	.+46     	; 0x5ac <__stack+0x14d>
     57e:	ca 01       	movw	r24, r20
     580:	81 70       	andi	r24, 0x01	; 1
     582:	90 70       	andi	r25, 0x00	; 0
     584:	89 2b       	or	r24, r25
     586:	61 f0       	breq	.+24     	; 0x5a0 <__stack+0x141>
     588:	16 95       	lsr	r17
     58a:	07 95       	ror	r16
     58c:	f7 94       	ror	r15
     58e:	e7 94       	ror	r14
     590:	80 e0       	ldi	r24, 0x00	; 0
     592:	90 e0       	ldi	r25, 0x00	; 0
     594:	a0 e0       	ldi	r26, 0x00	; 0
     596:	b0 e8       	ldi	r27, 0x80	; 128
     598:	e8 2a       	or	r14, r24
     59a:	f9 2a       	or	r15, r25
     59c:	0a 2b       	or	r16, r26
     59e:	1b 2b       	or	r17, r27
     5a0:	76 95       	lsr	r23
     5a2:	67 95       	ror	r22
     5a4:	57 95       	ror	r21
     5a6:	47 95       	ror	r20
     5a8:	2f 5f       	subi	r18, 0xFF	; 255
     5aa:	3f 4f       	sbci	r19, 0xFF	; 255
     5ac:	77 fd       	sbrc	r23, 7
     5ae:	e7 cf       	rjmp	.-50     	; 0x57e <__stack+0x11f>
     5b0:	0c c0       	rjmp	.+24     	; 0x5ca <__stack+0x16b>
     5b2:	44 0f       	add	r20, r20
     5b4:	55 1f       	adc	r21, r21
     5b6:	66 1f       	adc	r22, r22
     5b8:	77 1f       	adc	r23, r23
     5ba:	17 fd       	sbrc	r17, 7
     5bc:	41 60       	ori	r20, 0x01	; 1
     5be:	ee 0c       	add	r14, r14
     5c0:	ff 1c       	adc	r15, r15
     5c2:	00 1f       	adc	r16, r16
     5c4:	11 1f       	adc	r17, r17
     5c6:	21 50       	subi	r18, 0x01	; 1
     5c8:	30 40       	sbci	r19, 0x00	; 0
     5ca:	40 30       	cpi	r20, 0x00	; 0
     5cc:	90 e0       	ldi	r25, 0x00	; 0
     5ce:	59 07       	cpc	r21, r25
     5d0:	90 e0       	ldi	r25, 0x00	; 0
     5d2:	69 07       	cpc	r22, r25
     5d4:	90 e4       	ldi	r25, 0x40	; 64
     5d6:	79 07       	cpc	r23, r25
     5d8:	60 f3       	brcs	.-40     	; 0x5b2 <__stack+0x153>
     5da:	2b 8f       	std	Y+27, r18	; 0x1b
     5dc:	3c 8f       	std	Y+28, r19	; 0x1c
     5de:	db 01       	movw	r26, r22
     5e0:	ca 01       	movw	r24, r20
     5e2:	8f 77       	andi	r24, 0x7F	; 127
     5e4:	90 70       	andi	r25, 0x00	; 0
     5e6:	a0 70       	andi	r26, 0x00	; 0
     5e8:	b0 70       	andi	r27, 0x00	; 0
     5ea:	80 34       	cpi	r24, 0x40	; 64
     5ec:	91 05       	cpc	r25, r1
     5ee:	a1 05       	cpc	r26, r1
     5f0:	b1 05       	cpc	r27, r1
     5f2:	61 f4       	brne	.+24     	; 0x60c <__stack+0x1ad>
     5f4:	47 fd       	sbrc	r20, 7
     5f6:	0a c0       	rjmp	.+20     	; 0x60c <__stack+0x1ad>
     5f8:	e1 14       	cp	r14, r1
     5fa:	f1 04       	cpc	r15, r1
     5fc:	01 05       	cpc	r16, r1
     5fe:	11 05       	cpc	r17, r1
     600:	29 f0       	breq	.+10     	; 0x60c <__stack+0x1ad>
     602:	40 5c       	subi	r20, 0xC0	; 192
     604:	5f 4f       	sbci	r21, 0xFF	; 255
     606:	6f 4f       	sbci	r22, 0xFF	; 255
     608:	7f 4f       	sbci	r23, 0xFF	; 255
     60a:	40 78       	andi	r20, 0x80	; 128
     60c:	1a 8e       	std	Y+26, r1	; 0x1a
     60e:	fe 17       	cp	r31, r30
     610:	11 f0       	breq	.+4      	; 0x616 <__stack+0x1b7>
     612:	81 e0       	ldi	r24, 0x01	; 1
     614:	8a 8f       	std	Y+26, r24	; 0x1a
     616:	4d 8f       	std	Y+29, r20	; 0x1d
     618:	5e 8f       	std	Y+30, r21	; 0x1e
     61a:	6f 8f       	std	Y+31, r22	; 0x1f
     61c:	78 a3       	std	Y+32, r23	; 0x20
     61e:	83 e0       	ldi	r24, 0x03	; 3
     620:	89 8f       	std	Y+25, r24	; 0x19
     622:	ce 01       	movw	r24, r28
     624:	49 96       	adiw	r24, 0x19	; 25
     626:	0e 94 0a 05 	call	0xa14	; 0xa14 <__pack_f>
     62a:	a0 96       	adiw	r28, 0x20	; 32
     62c:	e2 e1       	ldi	r30, 0x12	; 18
     62e:	0c 94 84 17 	jmp	0x2f08	; 0x2f08 <__epilogue_restores__>

00000632 <__nesf2>:
     632:	a8 e1       	ldi	r26, 0x18	; 24
     634:	b0 e0       	ldi	r27, 0x00	; 0
     636:	ef e1       	ldi	r30, 0x1F	; 31
     638:	f3 e0       	ldi	r31, 0x03	; 3
     63a:	0c 94 74 17 	jmp	0x2ee8	; 0x2ee8 <__prologue_saves__+0x18>
     63e:	69 83       	std	Y+1, r22	; 0x01
     640:	7a 83       	std	Y+2, r23	; 0x02
     642:	8b 83       	std	Y+3, r24	; 0x03
     644:	9c 83       	std	Y+4, r25	; 0x04
     646:	2d 83       	std	Y+5, r18	; 0x05
     648:	3e 83       	std	Y+6, r19	; 0x06
     64a:	4f 83       	std	Y+7, r20	; 0x07
     64c:	58 87       	std	Y+8, r21	; 0x08
     64e:	89 e0       	ldi	r24, 0x09	; 9
     650:	e8 2e       	mov	r14, r24
     652:	f1 2c       	mov	r15, r1
     654:	ec 0e       	add	r14, r28
     656:	fd 1e       	adc	r15, r29
     658:	ce 01       	movw	r24, r28
     65a:	01 96       	adiw	r24, 0x01	; 1
     65c:	b7 01       	movw	r22, r14
     65e:	0e 94 df 05 	call	0xbbe	; 0xbbe <__unpack_f>
     662:	8e 01       	movw	r16, r28
     664:	0f 5e       	subi	r16, 0xEF	; 239
     666:	1f 4f       	sbci	r17, 0xFF	; 255
     668:	ce 01       	movw	r24, r28
     66a:	05 96       	adiw	r24, 0x05	; 5
     66c:	b8 01       	movw	r22, r16
     66e:	0e 94 df 05 	call	0xbbe	; 0xbbe <__unpack_f>
     672:	89 85       	ldd	r24, Y+9	; 0x09
     674:	82 30       	cpi	r24, 0x02	; 2
     676:	40 f0       	brcs	.+16     	; 0x688 <__nesf2+0x56>
     678:	89 89       	ldd	r24, Y+17	; 0x11
     67a:	82 30       	cpi	r24, 0x02	; 2
     67c:	28 f0       	brcs	.+10     	; 0x688 <__nesf2+0x56>
     67e:	c7 01       	movw	r24, r14
     680:	b8 01       	movw	r22, r16
     682:	0e 94 57 06 	call	0xcae	; 0xcae <__fpcmp_parts_f>
     686:	01 c0       	rjmp	.+2      	; 0x68a <__nesf2+0x58>
     688:	81 e0       	ldi	r24, 0x01	; 1
     68a:	68 96       	adiw	r28, 0x18	; 24
     68c:	e6 e0       	ldi	r30, 0x06	; 6
     68e:	0c 94 90 17 	jmp	0x2f20	; 0x2f20 <__epilogue_restores__+0x18>

00000692 <__gtsf2>:
     692:	a8 e1       	ldi	r26, 0x18	; 24
     694:	b0 e0       	ldi	r27, 0x00	; 0
     696:	ef e4       	ldi	r30, 0x4F	; 79
     698:	f3 e0       	ldi	r31, 0x03	; 3
     69a:	0c 94 74 17 	jmp	0x2ee8	; 0x2ee8 <__prologue_saves__+0x18>
     69e:	69 83       	std	Y+1, r22	; 0x01
     6a0:	7a 83       	std	Y+2, r23	; 0x02
     6a2:	8b 83       	std	Y+3, r24	; 0x03
     6a4:	9c 83       	std	Y+4, r25	; 0x04
     6a6:	2d 83       	std	Y+5, r18	; 0x05
     6a8:	3e 83       	std	Y+6, r19	; 0x06
     6aa:	4f 83       	std	Y+7, r20	; 0x07
     6ac:	58 87       	std	Y+8, r21	; 0x08
     6ae:	89 e0       	ldi	r24, 0x09	; 9
     6b0:	e8 2e       	mov	r14, r24
     6b2:	f1 2c       	mov	r15, r1
     6b4:	ec 0e       	add	r14, r28
     6b6:	fd 1e       	adc	r15, r29
     6b8:	ce 01       	movw	r24, r28
     6ba:	01 96       	adiw	r24, 0x01	; 1
     6bc:	b7 01       	movw	r22, r14
     6be:	0e 94 df 05 	call	0xbbe	; 0xbbe <__unpack_f>
     6c2:	8e 01       	movw	r16, r28
     6c4:	0f 5e       	subi	r16, 0xEF	; 239
     6c6:	1f 4f       	sbci	r17, 0xFF	; 255
     6c8:	ce 01       	movw	r24, r28
     6ca:	05 96       	adiw	r24, 0x05	; 5
     6cc:	b8 01       	movw	r22, r16
     6ce:	0e 94 df 05 	call	0xbbe	; 0xbbe <__unpack_f>
     6d2:	89 85       	ldd	r24, Y+9	; 0x09
     6d4:	82 30       	cpi	r24, 0x02	; 2
     6d6:	40 f0       	brcs	.+16     	; 0x6e8 <__gtsf2+0x56>
     6d8:	89 89       	ldd	r24, Y+17	; 0x11
     6da:	82 30       	cpi	r24, 0x02	; 2
     6dc:	28 f0       	brcs	.+10     	; 0x6e8 <__gtsf2+0x56>
     6de:	c7 01       	movw	r24, r14
     6e0:	b8 01       	movw	r22, r16
     6e2:	0e 94 57 06 	call	0xcae	; 0xcae <__fpcmp_parts_f>
     6e6:	01 c0       	rjmp	.+2      	; 0x6ea <__gtsf2+0x58>
     6e8:	8f ef       	ldi	r24, 0xFF	; 255
     6ea:	68 96       	adiw	r28, 0x18	; 24
     6ec:	e6 e0       	ldi	r30, 0x06	; 6
     6ee:	0c 94 90 17 	jmp	0x2f20	; 0x2f20 <__epilogue_restores__+0x18>

000006f2 <__gesf2>:
     6f2:	a8 e1       	ldi	r26, 0x18	; 24
     6f4:	b0 e0       	ldi	r27, 0x00	; 0
     6f6:	ef e7       	ldi	r30, 0x7F	; 127
     6f8:	f3 e0       	ldi	r31, 0x03	; 3
     6fa:	0c 94 74 17 	jmp	0x2ee8	; 0x2ee8 <__prologue_saves__+0x18>
     6fe:	69 83       	std	Y+1, r22	; 0x01
     700:	7a 83       	std	Y+2, r23	; 0x02
     702:	8b 83       	std	Y+3, r24	; 0x03
     704:	9c 83       	std	Y+4, r25	; 0x04
     706:	2d 83       	std	Y+5, r18	; 0x05
     708:	3e 83       	std	Y+6, r19	; 0x06
     70a:	4f 83       	std	Y+7, r20	; 0x07
     70c:	58 87       	std	Y+8, r21	; 0x08
     70e:	89 e0       	ldi	r24, 0x09	; 9
     710:	e8 2e       	mov	r14, r24
     712:	f1 2c       	mov	r15, r1
     714:	ec 0e       	add	r14, r28
     716:	fd 1e       	adc	r15, r29
     718:	ce 01       	movw	r24, r28
     71a:	01 96       	adiw	r24, 0x01	; 1
     71c:	b7 01       	movw	r22, r14
     71e:	0e 94 df 05 	call	0xbbe	; 0xbbe <__unpack_f>
     722:	8e 01       	movw	r16, r28
     724:	0f 5e       	subi	r16, 0xEF	; 239
     726:	1f 4f       	sbci	r17, 0xFF	; 255
     728:	ce 01       	movw	r24, r28
     72a:	05 96       	adiw	r24, 0x05	; 5
     72c:	b8 01       	movw	r22, r16
     72e:	0e 94 df 05 	call	0xbbe	; 0xbbe <__unpack_f>
     732:	89 85       	ldd	r24, Y+9	; 0x09
     734:	82 30       	cpi	r24, 0x02	; 2
     736:	40 f0       	brcs	.+16     	; 0x748 <__gesf2+0x56>
     738:	89 89       	ldd	r24, Y+17	; 0x11
     73a:	82 30       	cpi	r24, 0x02	; 2
     73c:	28 f0       	brcs	.+10     	; 0x748 <__gesf2+0x56>
     73e:	c7 01       	movw	r24, r14
     740:	b8 01       	movw	r22, r16
     742:	0e 94 57 06 	call	0xcae	; 0xcae <__fpcmp_parts_f>
     746:	01 c0       	rjmp	.+2      	; 0x74a <__gesf2+0x58>
     748:	8f ef       	ldi	r24, 0xFF	; 255
     74a:	68 96       	adiw	r28, 0x18	; 24
     74c:	e6 e0       	ldi	r30, 0x06	; 6
     74e:	0c 94 90 17 	jmp	0x2f20	; 0x2f20 <__epilogue_restores__+0x18>

00000752 <__ltsf2>:
     752:	a8 e1       	ldi	r26, 0x18	; 24
     754:	b0 e0       	ldi	r27, 0x00	; 0
     756:	ef ea       	ldi	r30, 0xAF	; 175
     758:	f3 e0       	ldi	r31, 0x03	; 3
     75a:	0c 94 74 17 	jmp	0x2ee8	; 0x2ee8 <__prologue_saves__+0x18>
     75e:	69 83       	std	Y+1, r22	; 0x01
     760:	7a 83       	std	Y+2, r23	; 0x02
     762:	8b 83       	std	Y+3, r24	; 0x03
     764:	9c 83       	std	Y+4, r25	; 0x04
     766:	2d 83       	std	Y+5, r18	; 0x05
     768:	3e 83       	std	Y+6, r19	; 0x06
     76a:	4f 83       	std	Y+7, r20	; 0x07
     76c:	58 87       	std	Y+8, r21	; 0x08
     76e:	89 e0       	ldi	r24, 0x09	; 9
     770:	e8 2e       	mov	r14, r24
     772:	f1 2c       	mov	r15, r1
     774:	ec 0e       	add	r14, r28
     776:	fd 1e       	adc	r15, r29
     778:	ce 01       	movw	r24, r28
     77a:	01 96       	adiw	r24, 0x01	; 1
     77c:	b7 01       	movw	r22, r14
     77e:	0e 94 df 05 	call	0xbbe	; 0xbbe <__unpack_f>
     782:	8e 01       	movw	r16, r28
     784:	0f 5e       	subi	r16, 0xEF	; 239
     786:	1f 4f       	sbci	r17, 0xFF	; 255
     788:	ce 01       	movw	r24, r28
     78a:	05 96       	adiw	r24, 0x05	; 5
     78c:	b8 01       	movw	r22, r16
     78e:	0e 94 df 05 	call	0xbbe	; 0xbbe <__unpack_f>
     792:	89 85       	ldd	r24, Y+9	; 0x09
     794:	82 30       	cpi	r24, 0x02	; 2
     796:	40 f0       	brcs	.+16     	; 0x7a8 <__ltsf2+0x56>
     798:	89 89       	ldd	r24, Y+17	; 0x11
     79a:	82 30       	cpi	r24, 0x02	; 2
     79c:	28 f0       	brcs	.+10     	; 0x7a8 <__ltsf2+0x56>
     79e:	c7 01       	movw	r24, r14
     7a0:	b8 01       	movw	r22, r16
     7a2:	0e 94 57 06 	call	0xcae	; 0xcae <__fpcmp_parts_f>
     7a6:	01 c0       	rjmp	.+2      	; 0x7aa <__ltsf2+0x58>
     7a8:	81 e0       	ldi	r24, 0x01	; 1
     7aa:	68 96       	adiw	r28, 0x18	; 24
     7ac:	e6 e0       	ldi	r30, 0x06	; 6
     7ae:	0c 94 90 17 	jmp	0x2f20	; 0x2f20 <__epilogue_restores__+0x18>

000007b2 <__lesf2>:
     7b2:	a8 e1       	ldi	r26, 0x18	; 24
     7b4:	b0 e0       	ldi	r27, 0x00	; 0
     7b6:	ef ed       	ldi	r30, 0xDF	; 223
     7b8:	f3 e0       	ldi	r31, 0x03	; 3
     7ba:	0c 94 74 17 	jmp	0x2ee8	; 0x2ee8 <__prologue_saves__+0x18>
     7be:	69 83       	std	Y+1, r22	; 0x01
     7c0:	7a 83       	std	Y+2, r23	; 0x02
     7c2:	8b 83       	std	Y+3, r24	; 0x03
     7c4:	9c 83       	std	Y+4, r25	; 0x04
     7c6:	2d 83       	std	Y+5, r18	; 0x05
     7c8:	3e 83       	std	Y+6, r19	; 0x06
     7ca:	4f 83       	std	Y+7, r20	; 0x07
     7cc:	58 87       	std	Y+8, r21	; 0x08
     7ce:	89 e0       	ldi	r24, 0x09	; 9
     7d0:	e8 2e       	mov	r14, r24
     7d2:	f1 2c       	mov	r15, r1
     7d4:	ec 0e       	add	r14, r28
     7d6:	fd 1e       	adc	r15, r29
     7d8:	ce 01       	movw	r24, r28
     7da:	01 96       	adiw	r24, 0x01	; 1
     7dc:	b7 01       	movw	r22, r14
     7de:	0e 94 df 05 	call	0xbbe	; 0xbbe <__unpack_f>
     7e2:	8e 01       	movw	r16, r28
     7e4:	0f 5e       	subi	r16, 0xEF	; 239
     7e6:	1f 4f       	sbci	r17, 0xFF	; 255
     7e8:	ce 01       	movw	r24, r28
     7ea:	05 96       	adiw	r24, 0x05	; 5
     7ec:	b8 01       	movw	r22, r16
     7ee:	0e 94 df 05 	call	0xbbe	; 0xbbe <__unpack_f>
     7f2:	89 85       	ldd	r24, Y+9	; 0x09
     7f4:	82 30       	cpi	r24, 0x02	; 2
     7f6:	40 f0       	brcs	.+16     	; 0x808 <__lesf2+0x56>
     7f8:	89 89       	ldd	r24, Y+17	; 0x11
     7fa:	82 30       	cpi	r24, 0x02	; 2
     7fc:	28 f0       	brcs	.+10     	; 0x808 <__lesf2+0x56>
     7fe:	c7 01       	movw	r24, r14
     800:	b8 01       	movw	r22, r16
     802:	0e 94 57 06 	call	0xcae	; 0xcae <__fpcmp_parts_f>
     806:	01 c0       	rjmp	.+2      	; 0x80a <__lesf2+0x58>
     808:	81 e0       	ldi	r24, 0x01	; 1
     80a:	68 96       	adiw	r28, 0x18	; 24
     80c:	e6 e0       	ldi	r30, 0x06	; 6
     80e:	0c 94 90 17 	jmp	0x2f20	; 0x2f20 <__epilogue_restores__+0x18>

00000812 <__floatsisf>:
     812:	a8 e0       	ldi	r26, 0x08	; 8
     814:	b0 e0       	ldi	r27, 0x00	; 0
     816:	ef e0       	ldi	r30, 0x0F	; 15
     818:	f4 e0       	ldi	r31, 0x04	; 4
     81a:	0c 94 71 17 	jmp	0x2ee2	; 0x2ee2 <__prologue_saves__+0x12>
     81e:	9b 01       	movw	r18, r22
     820:	ac 01       	movw	r20, r24
     822:	83 e0       	ldi	r24, 0x03	; 3
     824:	89 83       	std	Y+1, r24	; 0x01
     826:	da 01       	movw	r26, r20
     828:	c9 01       	movw	r24, r18
     82a:	88 27       	eor	r24, r24
     82c:	b7 fd       	sbrc	r27, 7
     82e:	83 95       	inc	r24
     830:	99 27       	eor	r25, r25
     832:	aa 27       	eor	r26, r26
     834:	bb 27       	eor	r27, r27
     836:	b8 2e       	mov	r11, r24
     838:	21 15       	cp	r18, r1
     83a:	31 05       	cpc	r19, r1
     83c:	41 05       	cpc	r20, r1
     83e:	51 05       	cpc	r21, r1
     840:	19 f4       	brne	.+6      	; 0x848 <__floatsisf+0x36>
     842:	82 e0       	ldi	r24, 0x02	; 2
     844:	89 83       	std	Y+1, r24	; 0x01
     846:	3a c0       	rjmp	.+116    	; 0x8bc <__floatsisf+0xaa>
     848:	88 23       	and	r24, r24
     84a:	a9 f0       	breq	.+42     	; 0x876 <__floatsisf+0x64>
     84c:	20 30       	cpi	r18, 0x00	; 0
     84e:	80 e0       	ldi	r24, 0x00	; 0
     850:	38 07       	cpc	r19, r24
     852:	80 e0       	ldi	r24, 0x00	; 0
     854:	48 07       	cpc	r20, r24
     856:	80 e8       	ldi	r24, 0x80	; 128
     858:	58 07       	cpc	r21, r24
     85a:	29 f4       	brne	.+10     	; 0x866 <__floatsisf+0x54>
     85c:	60 e0       	ldi	r22, 0x00	; 0
     85e:	70 e0       	ldi	r23, 0x00	; 0
     860:	80 e0       	ldi	r24, 0x00	; 0
     862:	9f ec       	ldi	r25, 0xCF	; 207
     864:	30 c0       	rjmp	.+96     	; 0x8c6 <__floatsisf+0xb4>
     866:	ee 24       	eor	r14, r14
     868:	ff 24       	eor	r15, r15
     86a:	87 01       	movw	r16, r14
     86c:	e2 1a       	sub	r14, r18
     86e:	f3 0a       	sbc	r15, r19
     870:	04 0b       	sbc	r16, r20
     872:	15 0b       	sbc	r17, r21
     874:	02 c0       	rjmp	.+4      	; 0x87a <__floatsisf+0x68>
     876:	79 01       	movw	r14, r18
     878:	8a 01       	movw	r16, r20
     87a:	8e e1       	ldi	r24, 0x1E	; 30
     87c:	c8 2e       	mov	r12, r24
     87e:	d1 2c       	mov	r13, r1
     880:	dc 82       	std	Y+4, r13	; 0x04
     882:	cb 82       	std	Y+3, r12	; 0x03
     884:	ed 82       	std	Y+5, r14	; 0x05
     886:	fe 82       	std	Y+6, r15	; 0x06
     888:	0f 83       	std	Y+7, r16	; 0x07
     88a:	18 87       	std	Y+8, r17	; 0x08
     88c:	c8 01       	movw	r24, r16
     88e:	b7 01       	movw	r22, r14
     890:	0e 94 bb 04 	call	0x976	; 0x976 <__clzsi2>
     894:	01 97       	sbiw	r24, 0x01	; 1
     896:	18 16       	cp	r1, r24
     898:	19 06       	cpc	r1, r25
     89a:	84 f4       	brge	.+32     	; 0x8bc <__floatsisf+0xaa>
     89c:	08 2e       	mov	r0, r24
     89e:	04 c0       	rjmp	.+8      	; 0x8a8 <__floatsisf+0x96>
     8a0:	ee 0c       	add	r14, r14
     8a2:	ff 1c       	adc	r15, r15
     8a4:	00 1f       	adc	r16, r16
     8a6:	11 1f       	adc	r17, r17
     8a8:	0a 94       	dec	r0
     8aa:	d2 f7       	brpl	.-12     	; 0x8a0 <__floatsisf+0x8e>
     8ac:	ed 82       	std	Y+5, r14	; 0x05
     8ae:	fe 82       	std	Y+6, r15	; 0x06
     8b0:	0f 83       	std	Y+7, r16	; 0x07
     8b2:	18 87       	std	Y+8, r17	; 0x08
     8b4:	c8 1a       	sub	r12, r24
     8b6:	d9 0a       	sbc	r13, r25
     8b8:	dc 82       	std	Y+4, r13	; 0x04
     8ba:	cb 82       	std	Y+3, r12	; 0x03
     8bc:	ba 82       	std	Y+2, r11	; 0x02
     8be:	ce 01       	movw	r24, r28
     8c0:	01 96       	adiw	r24, 0x01	; 1
     8c2:	0e 94 0a 05 	call	0xa14	; 0xa14 <__pack_f>
     8c6:	28 96       	adiw	r28, 0x08	; 8
     8c8:	e9 e0       	ldi	r30, 0x09	; 9
     8ca:	0c 94 8d 17 	jmp	0x2f1a	; 0x2f1a <__epilogue_restores__+0x12>

000008ce <__fixsfsi>:
     8ce:	ac e0       	ldi	r26, 0x0C	; 12
     8d0:	b0 e0       	ldi	r27, 0x00	; 0
     8d2:	ed e6       	ldi	r30, 0x6D	; 109
     8d4:	f4 e0       	ldi	r31, 0x04	; 4
     8d6:	0c 94 78 17 	jmp	0x2ef0	; 0x2ef0 <__prologue_saves__+0x20>
     8da:	69 83       	std	Y+1, r22	; 0x01
     8dc:	7a 83       	std	Y+2, r23	; 0x02
     8de:	8b 83       	std	Y+3, r24	; 0x03
     8e0:	9c 83       	std	Y+4, r25	; 0x04
     8e2:	ce 01       	movw	r24, r28
     8e4:	01 96       	adiw	r24, 0x01	; 1
     8e6:	be 01       	movw	r22, r28
     8e8:	6b 5f       	subi	r22, 0xFB	; 251
     8ea:	7f 4f       	sbci	r23, 0xFF	; 255
     8ec:	0e 94 df 05 	call	0xbbe	; 0xbbe <__unpack_f>
     8f0:	8d 81       	ldd	r24, Y+5	; 0x05
     8f2:	82 30       	cpi	r24, 0x02	; 2
     8f4:	61 f1       	breq	.+88     	; 0x94e <__fixsfsi+0x80>
     8f6:	82 30       	cpi	r24, 0x02	; 2
     8f8:	50 f1       	brcs	.+84     	; 0x94e <__fixsfsi+0x80>
     8fa:	84 30       	cpi	r24, 0x04	; 4
     8fc:	21 f4       	brne	.+8      	; 0x906 <__fixsfsi+0x38>
     8fe:	8e 81       	ldd	r24, Y+6	; 0x06
     900:	88 23       	and	r24, r24
     902:	51 f1       	breq	.+84     	; 0x958 <__fixsfsi+0x8a>
     904:	2e c0       	rjmp	.+92     	; 0x962 <__fixsfsi+0x94>
     906:	2f 81       	ldd	r18, Y+7	; 0x07
     908:	38 85       	ldd	r19, Y+8	; 0x08
     90a:	37 fd       	sbrc	r19, 7
     90c:	20 c0       	rjmp	.+64     	; 0x94e <__fixsfsi+0x80>
     90e:	6e 81       	ldd	r22, Y+6	; 0x06
     910:	2f 31       	cpi	r18, 0x1F	; 31
     912:	31 05       	cpc	r19, r1
     914:	1c f0       	brlt	.+6      	; 0x91c <__fixsfsi+0x4e>
     916:	66 23       	and	r22, r22
     918:	f9 f0       	breq	.+62     	; 0x958 <__fixsfsi+0x8a>
     91a:	23 c0       	rjmp	.+70     	; 0x962 <__fixsfsi+0x94>
     91c:	8e e1       	ldi	r24, 0x1E	; 30
     91e:	90 e0       	ldi	r25, 0x00	; 0
     920:	82 1b       	sub	r24, r18
     922:	93 0b       	sbc	r25, r19
     924:	29 85       	ldd	r18, Y+9	; 0x09
     926:	3a 85       	ldd	r19, Y+10	; 0x0a
     928:	4b 85       	ldd	r20, Y+11	; 0x0b
     92a:	5c 85       	ldd	r21, Y+12	; 0x0c
     92c:	04 c0       	rjmp	.+8      	; 0x936 <__fixsfsi+0x68>
     92e:	56 95       	lsr	r21
     930:	47 95       	ror	r20
     932:	37 95       	ror	r19
     934:	27 95       	ror	r18
     936:	8a 95       	dec	r24
     938:	d2 f7       	brpl	.-12     	; 0x92e <__fixsfsi+0x60>
     93a:	66 23       	and	r22, r22
     93c:	b1 f0       	breq	.+44     	; 0x96a <__fixsfsi+0x9c>
     93e:	50 95       	com	r21
     940:	40 95       	com	r20
     942:	30 95       	com	r19
     944:	21 95       	neg	r18
     946:	3f 4f       	sbci	r19, 0xFF	; 255
     948:	4f 4f       	sbci	r20, 0xFF	; 255
     94a:	5f 4f       	sbci	r21, 0xFF	; 255
     94c:	0e c0       	rjmp	.+28     	; 0x96a <__fixsfsi+0x9c>
     94e:	20 e0       	ldi	r18, 0x00	; 0
     950:	30 e0       	ldi	r19, 0x00	; 0
     952:	40 e0       	ldi	r20, 0x00	; 0
     954:	50 e0       	ldi	r21, 0x00	; 0
     956:	09 c0       	rjmp	.+18     	; 0x96a <__fixsfsi+0x9c>
     958:	2f ef       	ldi	r18, 0xFF	; 255
     95a:	3f ef       	ldi	r19, 0xFF	; 255
     95c:	4f ef       	ldi	r20, 0xFF	; 255
     95e:	5f e7       	ldi	r21, 0x7F	; 127
     960:	04 c0       	rjmp	.+8      	; 0x96a <__fixsfsi+0x9c>
     962:	20 e0       	ldi	r18, 0x00	; 0
     964:	30 e0       	ldi	r19, 0x00	; 0
     966:	40 e0       	ldi	r20, 0x00	; 0
     968:	50 e8       	ldi	r21, 0x80	; 128
     96a:	b9 01       	movw	r22, r18
     96c:	ca 01       	movw	r24, r20
     96e:	2c 96       	adiw	r28, 0x0c	; 12
     970:	e2 e0       	ldi	r30, 0x02	; 2
     972:	0c 94 94 17 	jmp	0x2f28	; 0x2f28 <__epilogue_restores__+0x20>

00000976 <__clzsi2>:
     976:	ef 92       	push	r14
     978:	ff 92       	push	r15
     97a:	0f 93       	push	r16
     97c:	1f 93       	push	r17
     97e:	7b 01       	movw	r14, r22
     980:	8c 01       	movw	r16, r24
     982:	80 e0       	ldi	r24, 0x00	; 0
     984:	e8 16       	cp	r14, r24
     986:	80 e0       	ldi	r24, 0x00	; 0
     988:	f8 06       	cpc	r15, r24
     98a:	81 e0       	ldi	r24, 0x01	; 1
     98c:	08 07       	cpc	r16, r24
     98e:	80 e0       	ldi	r24, 0x00	; 0
     990:	18 07       	cpc	r17, r24
     992:	88 f4       	brcc	.+34     	; 0x9b6 <__clzsi2+0x40>
     994:	8f ef       	ldi	r24, 0xFF	; 255
     996:	e8 16       	cp	r14, r24
     998:	f1 04       	cpc	r15, r1
     99a:	01 05       	cpc	r16, r1
     99c:	11 05       	cpc	r17, r1
     99e:	31 f0       	breq	.+12     	; 0x9ac <__clzsi2+0x36>
     9a0:	28 f0       	brcs	.+10     	; 0x9ac <__clzsi2+0x36>
     9a2:	88 e0       	ldi	r24, 0x08	; 8
     9a4:	90 e0       	ldi	r25, 0x00	; 0
     9a6:	a0 e0       	ldi	r26, 0x00	; 0
     9a8:	b0 e0       	ldi	r27, 0x00	; 0
     9aa:	17 c0       	rjmp	.+46     	; 0x9da <__clzsi2+0x64>
     9ac:	80 e0       	ldi	r24, 0x00	; 0
     9ae:	90 e0       	ldi	r25, 0x00	; 0
     9b0:	a0 e0       	ldi	r26, 0x00	; 0
     9b2:	b0 e0       	ldi	r27, 0x00	; 0
     9b4:	12 c0       	rjmp	.+36     	; 0x9da <__clzsi2+0x64>
     9b6:	80 e0       	ldi	r24, 0x00	; 0
     9b8:	e8 16       	cp	r14, r24
     9ba:	80 e0       	ldi	r24, 0x00	; 0
     9bc:	f8 06       	cpc	r15, r24
     9be:	80 e0       	ldi	r24, 0x00	; 0
     9c0:	08 07       	cpc	r16, r24
     9c2:	81 e0       	ldi	r24, 0x01	; 1
     9c4:	18 07       	cpc	r17, r24
     9c6:	28 f0       	brcs	.+10     	; 0x9d2 <__clzsi2+0x5c>
     9c8:	88 e1       	ldi	r24, 0x18	; 24
     9ca:	90 e0       	ldi	r25, 0x00	; 0
     9cc:	a0 e0       	ldi	r26, 0x00	; 0
     9ce:	b0 e0       	ldi	r27, 0x00	; 0
     9d0:	04 c0       	rjmp	.+8      	; 0x9da <__clzsi2+0x64>
     9d2:	80 e1       	ldi	r24, 0x10	; 16
     9d4:	90 e0       	ldi	r25, 0x00	; 0
     9d6:	a0 e0       	ldi	r26, 0x00	; 0
     9d8:	b0 e0       	ldi	r27, 0x00	; 0
     9da:	20 e2       	ldi	r18, 0x20	; 32
     9dc:	30 e0       	ldi	r19, 0x00	; 0
     9de:	40 e0       	ldi	r20, 0x00	; 0
     9e0:	50 e0       	ldi	r21, 0x00	; 0
     9e2:	28 1b       	sub	r18, r24
     9e4:	39 0b       	sbc	r19, r25
     9e6:	4a 0b       	sbc	r20, r26
     9e8:	5b 0b       	sbc	r21, r27
     9ea:	04 c0       	rjmp	.+8      	; 0x9f4 <__clzsi2+0x7e>
     9ec:	16 95       	lsr	r17
     9ee:	07 95       	ror	r16
     9f0:	f7 94       	ror	r15
     9f2:	e7 94       	ror	r14
     9f4:	8a 95       	dec	r24
     9f6:	d2 f7       	brpl	.-12     	; 0x9ec <__clzsi2+0x76>
     9f8:	f7 01       	movw	r30, r14
     9fa:	e6 59       	subi	r30, 0x96	; 150
     9fc:	ff 4f       	sbci	r31, 0xFF	; 255
     9fe:	80 81       	ld	r24, Z
     a00:	28 1b       	sub	r18, r24
     a02:	31 09       	sbc	r19, r1
     a04:	41 09       	sbc	r20, r1
     a06:	51 09       	sbc	r21, r1
     a08:	c9 01       	movw	r24, r18
     a0a:	1f 91       	pop	r17
     a0c:	0f 91       	pop	r16
     a0e:	ff 90       	pop	r15
     a10:	ef 90       	pop	r14
     a12:	08 95       	ret

00000a14 <__pack_f>:
     a14:	df 92       	push	r13
     a16:	ef 92       	push	r14
     a18:	ff 92       	push	r15
     a1a:	0f 93       	push	r16
     a1c:	1f 93       	push	r17
     a1e:	fc 01       	movw	r30, r24
     a20:	e4 80       	ldd	r14, Z+4	; 0x04
     a22:	f5 80       	ldd	r15, Z+5	; 0x05
     a24:	06 81       	ldd	r16, Z+6	; 0x06
     a26:	17 81       	ldd	r17, Z+7	; 0x07
     a28:	d1 80       	ldd	r13, Z+1	; 0x01
     a2a:	80 81       	ld	r24, Z
     a2c:	82 30       	cpi	r24, 0x02	; 2
     a2e:	48 f4       	brcc	.+18     	; 0xa42 <__pack_f+0x2e>
     a30:	80 e0       	ldi	r24, 0x00	; 0
     a32:	90 e0       	ldi	r25, 0x00	; 0
     a34:	a0 e1       	ldi	r26, 0x10	; 16
     a36:	b0 e0       	ldi	r27, 0x00	; 0
     a38:	e8 2a       	or	r14, r24
     a3a:	f9 2a       	or	r15, r25
     a3c:	0a 2b       	or	r16, r26
     a3e:	1b 2b       	or	r17, r27
     a40:	a5 c0       	rjmp	.+330    	; 0xb8c <__pack_f+0x178>
     a42:	84 30       	cpi	r24, 0x04	; 4
     a44:	09 f4       	brne	.+2      	; 0xa48 <__pack_f+0x34>
     a46:	9f c0       	rjmp	.+318    	; 0xb86 <__pack_f+0x172>
     a48:	82 30       	cpi	r24, 0x02	; 2
     a4a:	21 f4       	brne	.+8      	; 0xa54 <__pack_f+0x40>
     a4c:	ee 24       	eor	r14, r14
     a4e:	ff 24       	eor	r15, r15
     a50:	87 01       	movw	r16, r14
     a52:	05 c0       	rjmp	.+10     	; 0xa5e <__pack_f+0x4a>
     a54:	e1 14       	cp	r14, r1
     a56:	f1 04       	cpc	r15, r1
     a58:	01 05       	cpc	r16, r1
     a5a:	11 05       	cpc	r17, r1
     a5c:	19 f4       	brne	.+6      	; 0xa64 <__pack_f+0x50>
     a5e:	e0 e0       	ldi	r30, 0x00	; 0
     a60:	f0 e0       	ldi	r31, 0x00	; 0
     a62:	96 c0       	rjmp	.+300    	; 0xb90 <__pack_f+0x17c>
     a64:	62 81       	ldd	r22, Z+2	; 0x02
     a66:	73 81       	ldd	r23, Z+3	; 0x03
     a68:	9f ef       	ldi	r25, 0xFF	; 255
     a6a:	62 38       	cpi	r22, 0x82	; 130
     a6c:	79 07       	cpc	r23, r25
     a6e:	0c f0       	brlt	.+2      	; 0xa72 <__pack_f+0x5e>
     a70:	5b c0       	rjmp	.+182    	; 0xb28 <__pack_f+0x114>
     a72:	22 e8       	ldi	r18, 0x82	; 130
     a74:	3f ef       	ldi	r19, 0xFF	; 255
     a76:	26 1b       	sub	r18, r22
     a78:	37 0b       	sbc	r19, r23
     a7a:	2a 31       	cpi	r18, 0x1A	; 26
     a7c:	31 05       	cpc	r19, r1
     a7e:	2c f0       	brlt	.+10     	; 0xa8a <__pack_f+0x76>
     a80:	20 e0       	ldi	r18, 0x00	; 0
     a82:	30 e0       	ldi	r19, 0x00	; 0
     a84:	40 e0       	ldi	r20, 0x00	; 0
     a86:	50 e0       	ldi	r21, 0x00	; 0
     a88:	2a c0       	rjmp	.+84     	; 0xade <__pack_f+0xca>
     a8a:	b8 01       	movw	r22, r16
     a8c:	a7 01       	movw	r20, r14
     a8e:	02 2e       	mov	r0, r18
     a90:	04 c0       	rjmp	.+8      	; 0xa9a <__pack_f+0x86>
     a92:	76 95       	lsr	r23
     a94:	67 95       	ror	r22
     a96:	57 95       	ror	r21
     a98:	47 95       	ror	r20
     a9a:	0a 94       	dec	r0
     a9c:	d2 f7       	brpl	.-12     	; 0xa92 <__pack_f+0x7e>
     a9e:	81 e0       	ldi	r24, 0x01	; 1
     aa0:	90 e0       	ldi	r25, 0x00	; 0
     aa2:	a0 e0       	ldi	r26, 0x00	; 0
     aa4:	b0 e0       	ldi	r27, 0x00	; 0
     aa6:	04 c0       	rjmp	.+8      	; 0xab0 <__pack_f+0x9c>
     aa8:	88 0f       	add	r24, r24
     aaa:	99 1f       	adc	r25, r25
     aac:	aa 1f       	adc	r26, r26
     aae:	bb 1f       	adc	r27, r27
     ab0:	2a 95       	dec	r18
     ab2:	d2 f7       	brpl	.-12     	; 0xaa8 <__pack_f+0x94>
     ab4:	01 97       	sbiw	r24, 0x01	; 1
     ab6:	a1 09       	sbc	r26, r1
     ab8:	b1 09       	sbc	r27, r1
     aba:	8e 21       	and	r24, r14
     abc:	9f 21       	and	r25, r15
     abe:	a0 23       	and	r26, r16
     ac0:	b1 23       	and	r27, r17
     ac2:	00 97       	sbiw	r24, 0x00	; 0
     ac4:	a1 05       	cpc	r26, r1
     ac6:	b1 05       	cpc	r27, r1
     ac8:	21 f0       	breq	.+8      	; 0xad2 <__pack_f+0xbe>
     aca:	81 e0       	ldi	r24, 0x01	; 1
     acc:	90 e0       	ldi	r25, 0x00	; 0
     ace:	a0 e0       	ldi	r26, 0x00	; 0
     ad0:	b0 e0       	ldi	r27, 0x00	; 0
     ad2:	9a 01       	movw	r18, r20
     ad4:	ab 01       	movw	r20, r22
     ad6:	28 2b       	or	r18, r24
     ad8:	39 2b       	or	r19, r25
     ada:	4a 2b       	or	r20, r26
     adc:	5b 2b       	or	r21, r27
     ade:	da 01       	movw	r26, r20
     ae0:	c9 01       	movw	r24, r18
     ae2:	8f 77       	andi	r24, 0x7F	; 127
     ae4:	90 70       	andi	r25, 0x00	; 0
     ae6:	a0 70       	andi	r26, 0x00	; 0
     ae8:	b0 70       	andi	r27, 0x00	; 0
     aea:	80 34       	cpi	r24, 0x40	; 64
     aec:	91 05       	cpc	r25, r1
     aee:	a1 05       	cpc	r26, r1
     af0:	b1 05       	cpc	r27, r1
     af2:	39 f4       	brne	.+14     	; 0xb02 <__pack_f+0xee>
     af4:	27 ff       	sbrs	r18, 7
     af6:	09 c0       	rjmp	.+18     	; 0xb0a <__pack_f+0xf6>
     af8:	20 5c       	subi	r18, 0xC0	; 192
     afa:	3f 4f       	sbci	r19, 0xFF	; 255
     afc:	4f 4f       	sbci	r20, 0xFF	; 255
     afe:	5f 4f       	sbci	r21, 0xFF	; 255
     b00:	04 c0       	rjmp	.+8      	; 0xb0a <__pack_f+0xf6>
     b02:	21 5c       	subi	r18, 0xC1	; 193
     b04:	3f 4f       	sbci	r19, 0xFF	; 255
     b06:	4f 4f       	sbci	r20, 0xFF	; 255
     b08:	5f 4f       	sbci	r21, 0xFF	; 255
     b0a:	e0 e0       	ldi	r30, 0x00	; 0
     b0c:	f0 e0       	ldi	r31, 0x00	; 0
     b0e:	20 30       	cpi	r18, 0x00	; 0
     b10:	a0 e0       	ldi	r26, 0x00	; 0
     b12:	3a 07       	cpc	r19, r26
     b14:	a0 e0       	ldi	r26, 0x00	; 0
     b16:	4a 07       	cpc	r20, r26
     b18:	a0 e4       	ldi	r26, 0x40	; 64
     b1a:	5a 07       	cpc	r21, r26
     b1c:	10 f0       	brcs	.+4      	; 0xb22 <__pack_f+0x10e>
     b1e:	e1 e0       	ldi	r30, 0x01	; 1
     b20:	f0 e0       	ldi	r31, 0x00	; 0
     b22:	79 01       	movw	r14, r18
     b24:	8a 01       	movw	r16, r20
     b26:	27 c0       	rjmp	.+78     	; 0xb76 <__pack_f+0x162>
     b28:	60 38       	cpi	r22, 0x80	; 128
     b2a:	71 05       	cpc	r23, r1
     b2c:	64 f5       	brge	.+88     	; 0xb86 <__pack_f+0x172>
     b2e:	fb 01       	movw	r30, r22
     b30:	e1 58       	subi	r30, 0x81	; 129
     b32:	ff 4f       	sbci	r31, 0xFF	; 255
     b34:	d8 01       	movw	r26, r16
     b36:	c7 01       	movw	r24, r14
     b38:	8f 77       	andi	r24, 0x7F	; 127
     b3a:	90 70       	andi	r25, 0x00	; 0
     b3c:	a0 70       	andi	r26, 0x00	; 0
     b3e:	b0 70       	andi	r27, 0x00	; 0
     b40:	80 34       	cpi	r24, 0x40	; 64
     b42:	91 05       	cpc	r25, r1
     b44:	a1 05       	cpc	r26, r1
     b46:	b1 05       	cpc	r27, r1
     b48:	39 f4       	brne	.+14     	; 0xb58 <__pack_f+0x144>
     b4a:	e7 fe       	sbrs	r14, 7
     b4c:	0d c0       	rjmp	.+26     	; 0xb68 <__pack_f+0x154>
     b4e:	80 e4       	ldi	r24, 0x40	; 64
     b50:	90 e0       	ldi	r25, 0x00	; 0
     b52:	a0 e0       	ldi	r26, 0x00	; 0
     b54:	b0 e0       	ldi	r27, 0x00	; 0
     b56:	04 c0       	rjmp	.+8      	; 0xb60 <__pack_f+0x14c>
     b58:	8f e3       	ldi	r24, 0x3F	; 63
     b5a:	90 e0       	ldi	r25, 0x00	; 0
     b5c:	a0 e0       	ldi	r26, 0x00	; 0
     b5e:	b0 e0       	ldi	r27, 0x00	; 0
     b60:	e8 0e       	add	r14, r24
     b62:	f9 1e       	adc	r15, r25
     b64:	0a 1f       	adc	r16, r26
     b66:	1b 1f       	adc	r17, r27
     b68:	17 ff       	sbrs	r17, 7
     b6a:	05 c0       	rjmp	.+10     	; 0xb76 <__pack_f+0x162>
     b6c:	16 95       	lsr	r17
     b6e:	07 95       	ror	r16
     b70:	f7 94       	ror	r15
     b72:	e7 94       	ror	r14
     b74:	31 96       	adiw	r30, 0x01	; 1
     b76:	87 e0       	ldi	r24, 0x07	; 7
     b78:	16 95       	lsr	r17
     b7a:	07 95       	ror	r16
     b7c:	f7 94       	ror	r15
     b7e:	e7 94       	ror	r14
     b80:	8a 95       	dec	r24
     b82:	d1 f7       	brne	.-12     	; 0xb78 <__pack_f+0x164>
     b84:	05 c0       	rjmp	.+10     	; 0xb90 <__pack_f+0x17c>
     b86:	ee 24       	eor	r14, r14
     b88:	ff 24       	eor	r15, r15
     b8a:	87 01       	movw	r16, r14
     b8c:	ef ef       	ldi	r30, 0xFF	; 255
     b8e:	f0 e0       	ldi	r31, 0x00	; 0
     b90:	6e 2f       	mov	r22, r30
     b92:	67 95       	ror	r22
     b94:	66 27       	eor	r22, r22
     b96:	67 95       	ror	r22
     b98:	90 2f       	mov	r25, r16
     b9a:	9f 77       	andi	r25, 0x7F	; 127
     b9c:	d7 94       	ror	r13
     b9e:	dd 24       	eor	r13, r13
     ba0:	d7 94       	ror	r13
     ba2:	8e 2f       	mov	r24, r30
     ba4:	86 95       	lsr	r24
     ba6:	49 2f       	mov	r20, r25
     ba8:	46 2b       	or	r20, r22
     baa:	58 2f       	mov	r21, r24
     bac:	5d 29       	or	r21, r13
     bae:	b7 01       	movw	r22, r14
     bb0:	ca 01       	movw	r24, r20
     bb2:	1f 91       	pop	r17
     bb4:	0f 91       	pop	r16
     bb6:	ff 90       	pop	r15
     bb8:	ef 90       	pop	r14
     bba:	df 90       	pop	r13
     bbc:	08 95       	ret

00000bbe <__unpack_f>:
     bbe:	fc 01       	movw	r30, r24
     bc0:	db 01       	movw	r26, r22
     bc2:	40 81       	ld	r20, Z
     bc4:	51 81       	ldd	r21, Z+1	; 0x01
     bc6:	22 81       	ldd	r18, Z+2	; 0x02
     bc8:	62 2f       	mov	r22, r18
     bca:	6f 77       	andi	r22, 0x7F	; 127
     bcc:	70 e0       	ldi	r23, 0x00	; 0
     bce:	22 1f       	adc	r18, r18
     bd0:	22 27       	eor	r18, r18
     bd2:	22 1f       	adc	r18, r18
     bd4:	93 81       	ldd	r25, Z+3	; 0x03
     bd6:	89 2f       	mov	r24, r25
     bd8:	88 0f       	add	r24, r24
     bda:	82 2b       	or	r24, r18
     bdc:	28 2f       	mov	r18, r24
     bde:	30 e0       	ldi	r19, 0x00	; 0
     be0:	99 1f       	adc	r25, r25
     be2:	99 27       	eor	r25, r25
     be4:	99 1f       	adc	r25, r25
     be6:	11 96       	adiw	r26, 0x01	; 1
     be8:	9c 93       	st	X, r25
     bea:	11 97       	sbiw	r26, 0x01	; 1
     bec:	21 15       	cp	r18, r1
     bee:	31 05       	cpc	r19, r1
     bf0:	a9 f5       	brne	.+106    	; 0xc5c <__unpack_f+0x9e>
     bf2:	41 15       	cp	r20, r1
     bf4:	51 05       	cpc	r21, r1
     bf6:	61 05       	cpc	r22, r1
     bf8:	71 05       	cpc	r23, r1
     bfa:	11 f4       	brne	.+4      	; 0xc00 <__unpack_f+0x42>
     bfc:	82 e0       	ldi	r24, 0x02	; 2
     bfe:	37 c0       	rjmp	.+110    	; 0xc6e <__unpack_f+0xb0>
     c00:	82 e8       	ldi	r24, 0x82	; 130
     c02:	9f ef       	ldi	r25, 0xFF	; 255
     c04:	13 96       	adiw	r26, 0x03	; 3
     c06:	9c 93       	st	X, r25
     c08:	8e 93       	st	-X, r24
     c0a:	12 97       	sbiw	r26, 0x02	; 2
     c0c:	9a 01       	movw	r18, r20
     c0e:	ab 01       	movw	r20, r22
     c10:	67 e0       	ldi	r22, 0x07	; 7
     c12:	22 0f       	add	r18, r18
     c14:	33 1f       	adc	r19, r19
     c16:	44 1f       	adc	r20, r20
     c18:	55 1f       	adc	r21, r21
     c1a:	6a 95       	dec	r22
     c1c:	d1 f7       	brne	.-12     	; 0xc12 <__unpack_f+0x54>
     c1e:	83 e0       	ldi	r24, 0x03	; 3
     c20:	8c 93       	st	X, r24
     c22:	0d c0       	rjmp	.+26     	; 0xc3e <__unpack_f+0x80>
     c24:	22 0f       	add	r18, r18
     c26:	33 1f       	adc	r19, r19
     c28:	44 1f       	adc	r20, r20
     c2a:	55 1f       	adc	r21, r21
     c2c:	12 96       	adiw	r26, 0x02	; 2
     c2e:	8d 91       	ld	r24, X+
     c30:	9c 91       	ld	r25, X
     c32:	13 97       	sbiw	r26, 0x03	; 3
     c34:	01 97       	sbiw	r24, 0x01	; 1
     c36:	13 96       	adiw	r26, 0x03	; 3
     c38:	9c 93       	st	X, r25
     c3a:	8e 93       	st	-X, r24
     c3c:	12 97       	sbiw	r26, 0x02	; 2
     c3e:	20 30       	cpi	r18, 0x00	; 0
     c40:	80 e0       	ldi	r24, 0x00	; 0
     c42:	38 07       	cpc	r19, r24
     c44:	80 e0       	ldi	r24, 0x00	; 0
     c46:	48 07       	cpc	r20, r24
     c48:	80 e4       	ldi	r24, 0x40	; 64
     c4a:	58 07       	cpc	r21, r24
     c4c:	58 f3       	brcs	.-42     	; 0xc24 <__unpack_f+0x66>
     c4e:	14 96       	adiw	r26, 0x04	; 4
     c50:	2d 93       	st	X+, r18
     c52:	3d 93       	st	X+, r19
     c54:	4d 93       	st	X+, r20
     c56:	5c 93       	st	X, r21
     c58:	17 97       	sbiw	r26, 0x07	; 7
     c5a:	08 95       	ret
     c5c:	2f 3f       	cpi	r18, 0xFF	; 255
     c5e:	31 05       	cpc	r19, r1
     c60:	79 f4       	brne	.+30     	; 0xc80 <__unpack_f+0xc2>
     c62:	41 15       	cp	r20, r1
     c64:	51 05       	cpc	r21, r1
     c66:	61 05       	cpc	r22, r1
     c68:	71 05       	cpc	r23, r1
     c6a:	19 f4       	brne	.+6      	; 0xc72 <__unpack_f+0xb4>
     c6c:	84 e0       	ldi	r24, 0x04	; 4
     c6e:	8c 93       	st	X, r24
     c70:	08 95       	ret
     c72:	64 ff       	sbrs	r22, 4
     c74:	03 c0       	rjmp	.+6      	; 0xc7c <__unpack_f+0xbe>
     c76:	81 e0       	ldi	r24, 0x01	; 1
     c78:	8c 93       	st	X, r24
     c7a:	12 c0       	rjmp	.+36     	; 0xca0 <__unpack_f+0xe2>
     c7c:	1c 92       	st	X, r1
     c7e:	10 c0       	rjmp	.+32     	; 0xca0 <__unpack_f+0xe2>
     c80:	2f 57       	subi	r18, 0x7F	; 127
     c82:	30 40       	sbci	r19, 0x00	; 0
     c84:	13 96       	adiw	r26, 0x03	; 3
     c86:	3c 93       	st	X, r19
     c88:	2e 93       	st	-X, r18
     c8a:	12 97       	sbiw	r26, 0x02	; 2
     c8c:	83 e0       	ldi	r24, 0x03	; 3
     c8e:	8c 93       	st	X, r24
     c90:	87 e0       	ldi	r24, 0x07	; 7
     c92:	44 0f       	add	r20, r20
     c94:	55 1f       	adc	r21, r21
     c96:	66 1f       	adc	r22, r22
     c98:	77 1f       	adc	r23, r23
     c9a:	8a 95       	dec	r24
     c9c:	d1 f7       	brne	.-12     	; 0xc92 <__unpack_f+0xd4>
     c9e:	70 64       	ori	r23, 0x40	; 64
     ca0:	14 96       	adiw	r26, 0x04	; 4
     ca2:	4d 93       	st	X+, r20
     ca4:	5d 93       	st	X+, r21
     ca6:	6d 93       	st	X+, r22
     ca8:	7c 93       	st	X, r23
     caa:	17 97       	sbiw	r26, 0x07	; 7
     cac:	08 95       	ret

00000cae <__fpcmp_parts_f>:
     cae:	1f 93       	push	r17
     cb0:	dc 01       	movw	r26, r24
     cb2:	fb 01       	movw	r30, r22
     cb4:	9c 91       	ld	r25, X
     cb6:	92 30       	cpi	r25, 0x02	; 2
     cb8:	08 f4       	brcc	.+2      	; 0xcbc <__fpcmp_parts_f+0xe>
     cba:	47 c0       	rjmp	.+142    	; 0xd4a <__fpcmp_parts_f+0x9c>
     cbc:	80 81       	ld	r24, Z
     cbe:	82 30       	cpi	r24, 0x02	; 2
     cc0:	08 f4       	brcc	.+2      	; 0xcc4 <__fpcmp_parts_f+0x16>
     cc2:	43 c0       	rjmp	.+134    	; 0xd4a <__fpcmp_parts_f+0x9c>
     cc4:	94 30       	cpi	r25, 0x04	; 4
     cc6:	51 f4       	brne	.+20     	; 0xcdc <__fpcmp_parts_f+0x2e>
     cc8:	11 96       	adiw	r26, 0x01	; 1
     cca:	1c 91       	ld	r17, X
     ccc:	84 30       	cpi	r24, 0x04	; 4
     cce:	99 f5       	brne	.+102    	; 0xd36 <__fpcmp_parts_f+0x88>
     cd0:	81 81       	ldd	r24, Z+1	; 0x01
     cd2:	68 2f       	mov	r22, r24
     cd4:	70 e0       	ldi	r23, 0x00	; 0
     cd6:	61 1b       	sub	r22, r17
     cd8:	71 09       	sbc	r23, r1
     cda:	3f c0       	rjmp	.+126    	; 0xd5a <__fpcmp_parts_f+0xac>
     cdc:	84 30       	cpi	r24, 0x04	; 4
     cde:	21 f0       	breq	.+8      	; 0xce8 <__fpcmp_parts_f+0x3a>
     ce0:	92 30       	cpi	r25, 0x02	; 2
     ce2:	31 f4       	brne	.+12     	; 0xcf0 <__fpcmp_parts_f+0x42>
     ce4:	82 30       	cpi	r24, 0x02	; 2
     ce6:	b9 f1       	breq	.+110    	; 0xd56 <__fpcmp_parts_f+0xa8>
     ce8:	81 81       	ldd	r24, Z+1	; 0x01
     cea:	88 23       	and	r24, r24
     cec:	89 f1       	breq	.+98     	; 0xd50 <__fpcmp_parts_f+0xa2>
     cee:	2d c0       	rjmp	.+90     	; 0xd4a <__fpcmp_parts_f+0x9c>
     cf0:	11 96       	adiw	r26, 0x01	; 1
     cf2:	1c 91       	ld	r17, X
     cf4:	11 97       	sbiw	r26, 0x01	; 1
     cf6:	82 30       	cpi	r24, 0x02	; 2
     cf8:	f1 f0       	breq	.+60     	; 0xd36 <__fpcmp_parts_f+0x88>
     cfa:	81 81       	ldd	r24, Z+1	; 0x01
     cfc:	18 17       	cp	r17, r24
     cfe:	d9 f4       	brne	.+54     	; 0xd36 <__fpcmp_parts_f+0x88>
     d00:	12 96       	adiw	r26, 0x02	; 2
     d02:	2d 91       	ld	r18, X+
     d04:	3c 91       	ld	r19, X
     d06:	13 97       	sbiw	r26, 0x03	; 3
     d08:	82 81       	ldd	r24, Z+2	; 0x02
     d0a:	93 81       	ldd	r25, Z+3	; 0x03
     d0c:	82 17       	cp	r24, r18
     d0e:	93 07       	cpc	r25, r19
     d10:	94 f0       	brlt	.+36     	; 0xd36 <__fpcmp_parts_f+0x88>
     d12:	28 17       	cp	r18, r24
     d14:	39 07       	cpc	r19, r25
     d16:	bc f0       	brlt	.+46     	; 0xd46 <__fpcmp_parts_f+0x98>
     d18:	14 96       	adiw	r26, 0x04	; 4
     d1a:	8d 91       	ld	r24, X+
     d1c:	9d 91       	ld	r25, X+
     d1e:	0d 90       	ld	r0, X+
     d20:	bc 91       	ld	r27, X
     d22:	a0 2d       	mov	r26, r0
     d24:	24 81       	ldd	r18, Z+4	; 0x04
     d26:	35 81       	ldd	r19, Z+5	; 0x05
     d28:	46 81       	ldd	r20, Z+6	; 0x06
     d2a:	57 81       	ldd	r21, Z+7	; 0x07
     d2c:	28 17       	cp	r18, r24
     d2e:	39 07       	cpc	r19, r25
     d30:	4a 07       	cpc	r20, r26
     d32:	5b 07       	cpc	r21, r27
     d34:	18 f4       	brcc	.+6      	; 0xd3c <__fpcmp_parts_f+0x8e>
     d36:	11 23       	and	r17, r17
     d38:	41 f0       	breq	.+16     	; 0xd4a <__fpcmp_parts_f+0x9c>
     d3a:	0a c0       	rjmp	.+20     	; 0xd50 <__fpcmp_parts_f+0xa2>
     d3c:	82 17       	cp	r24, r18
     d3e:	93 07       	cpc	r25, r19
     d40:	a4 07       	cpc	r26, r20
     d42:	b5 07       	cpc	r27, r21
     d44:	40 f4       	brcc	.+16     	; 0xd56 <__fpcmp_parts_f+0xa8>
     d46:	11 23       	and	r17, r17
     d48:	19 f0       	breq	.+6      	; 0xd50 <__fpcmp_parts_f+0xa2>
     d4a:	61 e0       	ldi	r22, 0x01	; 1
     d4c:	70 e0       	ldi	r23, 0x00	; 0
     d4e:	05 c0       	rjmp	.+10     	; 0xd5a <__fpcmp_parts_f+0xac>
     d50:	6f ef       	ldi	r22, 0xFF	; 255
     d52:	7f ef       	ldi	r23, 0xFF	; 255
     d54:	02 c0       	rjmp	.+4      	; 0xd5a <__fpcmp_parts_f+0xac>
     d56:	60 e0       	ldi	r22, 0x00	; 0
     d58:	70 e0       	ldi	r23, 0x00	; 0
     d5a:	cb 01       	movw	r24, r22
     d5c:	1f 91       	pop	r17
     d5e:	08 95       	ret

00000d60 <POLL>:
unsigned long Poll_countTime =0; /*variable responsible for store time wanted to poll */
unsigned short int poll_count = 0;/*variable responsible for store number of counts needed for one poll*/


void POLL(void)
{
     d60:	df 93       	push	r29
     d62:	cf 93       	push	r28
     d64:	00 d0       	rcall	.+0      	; 0xd66 <POLL+0x6>
     d66:	00 d0       	rcall	.+0      	; 0xd68 <POLL+0x8>
     d68:	cd b7       	in	r28, 0x3d	; 61
     d6a:	de b7       	in	r29, 0x3e	; 62
	if ( Poll_Enable && (!poll_count))
     d6c:	80 91 6a 01 	lds	r24, 0x016A
     d70:	88 23       	and	r24, r24
     d72:	f1 f0       	breq	.+60     	; 0xdb0 <POLL+0x50>
     d74:	80 91 82 01 	lds	r24, 0x0182
     d78:	90 91 83 01 	lds	r25, 0x0183
     d7c:	00 97       	sbiw	r24, 0x00	; 0
     d7e:	c1 f4       	brne	.+48     	; 0xdb0 <POLL+0x50>
	{
		/*Here will put gets data for devices wanted and handling for this data*/
		float TC72_data =TC72_temperatureGetData();
     d80:	0e 94 05 10 	call	0x200a	; 0x200a <TC72_temperatureGetData>
     d84:	dc 01       	movw	r26, r24
     d86:	cb 01       	movw	r24, r22
     d88:	89 83       	std	Y+1, r24	; 0x01
     d8a:	9a 83       	std	Y+2, r25	; 0x02
     d8c:	ab 83       	std	Y+3, r26	; 0x03
     d8e:	bc 83       	std	Y+4, r27	; 0x04
		TC72_displayTemperature(TC72_data);
     d90:	89 81       	ldd	r24, Y+1	; 0x01
     d92:	9a 81       	ldd	r25, Y+2	; 0x02
     d94:	ab 81       	ldd	r26, Y+3	; 0x03
     d96:	bc 81       	ldd	r27, Y+4	; 0x04
     d98:	bc 01       	movw	r22, r24
     d9a:	cd 01       	movw	r24, r26
     d9c:	0e 94 5e 0f 	call	0x1ebc	; 0x1ebc <TC72_displayTemperature>
		Tc72_temperatureDataHandle(TC72_data);
     da0:	89 81       	ldd	r24, Y+1	; 0x01
     da2:	9a 81       	ldd	r25, Y+2	; 0x02
     da4:	ab 81       	ldd	r26, Y+3	; 0x03
     da6:	bc 81       	ldd	r27, Y+4	; 0x04
     da8:	bc 01       	movw	r22, r24
     daa:	cd 01       	movw	r24, r26
     dac:	0e 94 24 10 	call	0x2048	; 0x2048 <Tc72_temperatureDataHandle>
	}
	poll_count++;
     db0:	80 91 82 01 	lds	r24, 0x0182
     db4:	90 91 83 01 	lds	r25, 0x0183
     db8:	01 96       	adiw	r24, 0x01	; 1
     dba:	90 93 83 01 	sts	0x0183, r25
     dbe:	80 93 82 01 	sts	0x0182, r24
	poll_count = poll_count % Poll_countTime;
     dc2:	80 91 82 01 	lds	r24, 0x0182
     dc6:	90 91 83 01 	lds	r25, 0x0183
     dca:	cc 01       	movw	r24, r24
     dcc:	a0 e0       	ldi	r26, 0x00	; 0
     dce:	b0 e0       	ldi	r27, 0x00	; 0
     dd0:	20 91 7e 01 	lds	r18, 0x017E
     dd4:	30 91 7f 01 	lds	r19, 0x017F
     dd8:	40 91 80 01 	lds	r20, 0x0180
     ddc:	50 91 81 01 	lds	r21, 0x0181
     de0:	bc 01       	movw	r22, r24
     de2:	cd 01       	movw	r24, r26
     de4:	0e 94 46 17 	call	0x2e8c	; 0x2e8c <__udivmodsi4>
     de8:	dc 01       	movw	r26, r24
     dea:	cb 01       	movw	r24, r22
     dec:	90 93 83 01 	sts	0x0183, r25
     df0:	80 93 82 01 	sts	0x0182, r24
}
     df4:	0f 90       	pop	r0
     df6:	0f 90       	pop	r0
     df8:	0f 90       	pop	r0
     dfa:	0f 90       	pop	r0
     dfc:	cf 91       	pop	r28
     dfe:	df 91       	pop	r29
     e00:	08 95       	ret

00000e02 <POLL_start>:
/*
* Description:
* function responsible for enable poll by set value of variable that check for it if Poll is enabled /disabled
*/
void POLL_start(void)
{
     e02:	df 93       	push	r29
     e04:	cf 93       	push	r28
     e06:	cd b7       	in	r28, 0x3d	; 61
     e08:	de b7       	in	r29, 0x3e	; 62
	Poll_Enable = 1;
     e0a:	81 e0       	ldi	r24, 0x01	; 1
     e0c:	80 93 6a 01 	sts	0x016A, r24
}
     e10:	cf 91       	pop	r28
     e12:	df 91       	pop	r29
     e14:	08 95       	ret

00000e16 <POLL_stop>:
/*
* Description:
* function responsible for enable poll by clear value of variable that check for it if Poll is enabled /disabled
*/
void POLL_stop(void)
{
     e16:	df 93       	push	r29
     e18:	cf 93       	push	r28
     e1a:	cd b7       	in	r28, 0x3d	; 61
     e1c:	de b7       	in	r29, 0x3e	; 62
	Poll_Enable = 0;
     e1e:	10 92 6a 01 	sts	0x016A, r1
}
     e22:	cf 91       	pop	r28
     e24:	df 91       	pop	r29
     e26:	08 95       	ret

00000e28 <POLL_setTime>:

void POLL_setTime(unsigned long Poll_time)
{
     e28:	df 93       	push	r29
     e2a:	cf 93       	push	r28
     e2c:	00 d0       	rcall	.+0      	; 0xe2e <POLL_setTime+0x6>
     e2e:	00 d0       	rcall	.+0      	; 0xe30 <POLL_setTime+0x8>
     e30:	cd b7       	in	r28, 0x3d	; 61
     e32:	de b7       	in	r29, 0x3e	; 62
     e34:	69 83       	std	Y+1, r22	; 0x01
     e36:	7a 83       	std	Y+2, r23	; 0x02
     e38:	8b 83       	std	Y+3, r24	; 0x03
     e3a:	9c 83       	std	Y+4, r25	; 0x04

	Poll_countTime = Poll_time /100;
     e3c:	89 81       	ldd	r24, Y+1	; 0x01
     e3e:	9a 81       	ldd	r25, Y+2	; 0x02
     e40:	ab 81       	ldd	r26, Y+3	; 0x03
     e42:	bc 81       	ldd	r27, Y+4	; 0x04
     e44:	24 e6       	ldi	r18, 0x64	; 100
     e46:	30 e0       	ldi	r19, 0x00	; 0
     e48:	40 e0       	ldi	r20, 0x00	; 0
     e4a:	50 e0       	ldi	r21, 0x00	; 0
     e4c:	bc 01       	movw	r22, r24
     e4e:	cd 01       	movw	r24, r26
     e50:	0e 94 46 17 	call	0x2e8c	; 0x2e8c <__udivmodsi4>
     e54:	da 01       	movw	r26, r20
     e56:	c9 01       	movw	r24, r18
     e58:	80 93 7e 01 	sts	0x017E, r24
     e5c:	90 93 7f 01 	sts	0x017F, r25
     e60:	a0 93 80 01 	sts	0x0180, r26
     e64:	b0 93 81 01 	sts	0x0181, r27
}
     e68:	0f 90       	pop	r0
     e6a:	0f 90       	pop	r0
     e6c:	0f 90       	pop	r0
     e6e:	0f 90       	pop	r0
     e70:	cf 91       	pop	r28
     e72:	df 91       	pop	r29
     e74:	08 95       	ret

00000e76 <__vector_6>:
#include <avr/interrupt.h>
/*TIMER0_COMP_vect*/


ISR(TIMER1_COMPA_vect)
{
     e76:	1f 92       	push	r1
     e78:	0f 92       	push	r0
     e7a:	0f b6       	in	r0, 0x3f	; 63
     e7c:	0f 92       	push	r0
     e7e:	11 24       	eor	r1, r1
     e80:	2f 93       	push	r18
     e82:	3f 93       	push	r19
     e84:	4f 93       	push	r20
     e86:	5f 93       	push	r21
     e88:	6f 93       	push	r22
     e8a:	7f 93       	push	r23
     e8c:	8f 93       	push	r24
     e8e:	9f 93       	push	r25
     e90:	af 93       	push	r26
     e92:	bf 93       	push	r27
     e94:	ef 93       	push	r30
     e96:	ff 93       	push	r31
     e98:	df 93       	push	r29
     e9a:	cf 93       	push	r28
     e9c:	cd b7       	in	r28, 0x3d	; 61
     e9e:	de b7       	in	r29, 0x3e	; 62

	PollTimer_callBack();
     ea0:	0e 94 89 07 	call	0xf12	; 0xf12 <PollTimer_callBack>

}
     ea4:	cf 91       	pop	r28
     ea6:	df 91       	pop	r29
     ea8:	ff 91       	pop	r31
     eaa:	ef 91       	pop	r30
     eac:	bf 91       	pop	r27
     eae:	af 91       	pop	r26
     eb0:	9f 91       	pop	r25
     eb2:	8f 91       	pop	r24
     eb4:	7f 91       	pop	r23
     eb6:	6f 91       	pop	r22
     eb8:	5f 91       	pop	r21
     eba:	4f 91       	pop	r20
     ebc:	3f 91       	pop	r19
     ebe:	2f 91       	pop	r18
     ec0:	0f 90       	pop	r0
     ec2:	0f be       	out	0x3f, r0	; 63
     ec4:	0f 90       	pop	r0
     ec6:	1f 90       	pop	r1
     ec8:	18 95       	reti

00000eca <PollTimer_start>:

void PollTimer_start(void)
{
     eca:	df 93       	push	r29
     ecc:	cf 93       	push	r28
     ece:	cd b7       	in	r28, 0x3d	; 61
     ed0:	de b7       	in	r29, 0x3e	; 62
	TIMER1_startCTC();
     ed2:	0e 94 92 07 	call	0xf24	; 0xf24 <TIMER1_startCTC>
}
     ed6:	cf 91       	pop	r28
     ed8:	df 91       	pop	r29
     eda:	08 95       	ret

00000edc <PollTimer_stop>:

void PollTimer_stop(void)
{
     edc:	df 93       	push	r29
     ede:	cf 93       	push	r28
     ee0:	cd b7       	in	r28, 0x3d	; 61
     ee2:	de b7       	in	r29, 0x3e	; 62
	TIMER1_stopCTC();
     ee4:	0e 94 ab 07 	call	0xf56	; 0xf56 <TIMER1_stopCTC>
}
     ee8:	cf 91       	pop	r28
     eea:	df 91       	pop	r29
     eec:	08 95       	ret

00000eee <PollTimer_enableInterrupt>:

void PollTimer_enableInterrupt(void)
{
     eee:	df 93       	push	r29
     ef0:	cf 93       	push	r28
     ef2:	cd b7       	in	r28, 0x3d	; 61
     ef4:	de b7       	in	r29, 0x3e	; 62
	TIMER1_enableInterrupt();
     ef6:	0e 94 c7 07 	call	0xf8e	; 0xf8e <TIMER1_enableInterrupt>
}
     efa:	cf 91       	pop	r28
     efc:	df 91       	pop	r29
     efe:	08 95       	ret

00000f00 <PollTimer_disableInterrupt>:

void PollTimer_disableInterrupt(void)
{
     f00:	df 93       	push	r29
     f02:	cf 93       	push	r28
     f04:	cd b7       	in	r28, 0x3d	; 61
     f06:	de b7       	in	r29, 0x3e	; 62
	TIMER1_disableInterrupt();
     f08:	0e 94 dc 07 	call	0xfb8	; 0xfb8 <TIMER1_disableInterrupt>
}
     f0c:	cf 91       	pop	r28
     f0e:	df 91       	pop	r29
     f10:	08 95       	ret

00000f12 <PollTimer_callBack>:

void PollTimer_callBack(void)
{
     f12:	df 93       	push	r29
     f14:	cf 93       	push	r28
     f16:	cd b7       	in	r28, 0x3d	; 61
     f18:	de b7       	in	r29, 0x3e	; 62
	POLL();
     f1a:	0e 94 b0 06 	call	0xd60	; 0xd60 <POLL>
}
     f1e:	cf 91       	pop	r28
     f20:	df 91       	pop	r29
     f22:	08 95       	ret

00000f24 <TIMER1_startCTC>:
 */
#include "../../utilities/std_types.h"
#include "TIMER1.h"

void TIMER1_startCTC(void)
{
     f24:	df 93       	push	r29
     f26:	cf 93       	push	r28
     f28:	cd b7       	in	r28, 0x3d	; 61
     f2a:	de b7       	in	r29, 0x3e	; 62
	TCNT1 = 0;
     f2c:	ec e4       	ldi	r30, 0x4C	; 76
     f2e:	f0 e0       	ldi	r31, 0x00	; 0
     f30:	11 82       	std	Z+1, r1	; 0x01
     f32:	10 82       	st	Z, r1

	OCR1A = 391;
     f34:	ea e4       	ldi	r30, 0x4A	; 74
     f36:	f0 e0       	ldi	r31, 0x00	; 0
     f38:	87 e8       	ldi	r24, 0x87	; 135
     f3a:	91 e0       	ldi	r25, 0x01	; 1
     f3c:	91 83       	std	Z+1, r25	; 0x01
     f3e:	80 83       	st	Z, r24



	TCCR1A = (1<<FOC1A);
     f40:	ef e4       	ldi	r30, 0x4F	; 79
     f42:	f0 e0       	ldi	r31, 0x00	; 0
     f44:	88 e0       	ldi	r24, 0x08	; 8
     f46:	80 83       	st	Z, r24
	/*FCPU/256
	 * number of clocks per 100ms is 390.6*/
	TCCR1B = (1<<WGM12) | (4<<CS10);
     f48:	ee e4       	ldi	r30, 0x4E	; 78
     f4a:	f0 e0       	ldi	r31, 0x00	; 0
     f4c:	8c e0       	ldi	r24, 0x0C	; 12
     f4e:	80 83       	st	Z, r24

}
     f50:	cf 91       	pop	r28
     f52:	df 91       	pop	r29
     f54:	08 95       	ret

00000f56 <TIMER1_stopCTC>:

void TIMER1_stopCTC(void)
{
     f56:	df 93       	push	r29
     f58:	cf 93       	push	r28
     f5a:	cd b7       	in	r28, 0x3d	; 61
     f5c:	de b7       	in	r29, 0x3e	; 62
	TCCR1B &= ~(1<<CS10);
     f5e:	ae e4       	ldi	r26, 0x4E	; 78
     f60:	b0 e0       	ldi	r27, 0x00	; 0
     f62:	ee e4       	ldi	r30, 0x4E	; 78
     f64:	f0 e0       	ldi	r31, 0x00	; 0
     f66:	80 81       	ld	r24, Z
     f68:	8e 7f       	andi	r24, 0xFE	; 254
     f6a:	8c 93       	st	X, r24
	TCCR1B &= ~(1<<CS11);
     f6c:	ae e4       	ldi	r26, 0x4E	; 78
     f6e:	b0 e0       	ldi	r27, 0x00	; 0
     f70:	ee e4       	ldi	r30, 0x4E	; 78
     f72:	f0 e0       	ldi	r31, 0x00	; 0
     f74:	80 81       	ld	r24, Z
     f76:	8d 7f       	andi	r24, 0xFD	; 253
     f78:	8c 93       	st	X, r24
	TCCR1B &= ~(1<<CS12);
     f7a:	ae e4       	ldi	r26, 0x4E	; 78
     f7c:	b0 e0       	ldi	r27, 0x00	; 0
     f7e:	ee e4       	ldi	r30, 0x4E	; 78
     f80:	f0 e0       	ldi	r31, 0x00	; 0
     f82:	80 81       	ld	r24, Z
     f84:	8b 7f       	andi	r24, 0xFB	; 251
     f86:	8c 93       	st	X, r24
}
     f88:	cf 91       	pop	r28
     f8a:	df 91       	pop	r29
     f8c:	08 95       	ret

00000f8e <TIMER1_enableInterrupt>:

void TIMER1_enableInterrupt(void)
{
     f8e:	df 93       	push	r29
     f90:	cf 93       	push	r28
     f92:	cd b7       	in	r28, 0x3d	; 61
     f94:	de b7       	in	r29, 0x3e	; 62
	/*Enable timer interrupt*/
	TIMSK |= (1<<OCIE1A);
     f96:	a9 e5       	ldi	r26, 0x59	; 89
     f98:	b0 e0       	ldi	r27, 0x00	; 0
     f9a:	e9 e5       	ldi	r30, 0x59	; 89
     f9c:	f0 e0       	ldi	r31, 0x00	; 0
     f9e:	80 81       	ld	r24, Z
     fa0:	80 61       	ori	r24, 0x10	; 16
     fa2:	8c 93       	st	X, r24
	SREG  |= (1<<7);       // Enable interrupts by setting I-bit
     fa4:	af e5       	ldi	r26, 0x5F	; 95
     fa6:	b0 e0       	ldi	r27, 0x00	; 0
     fa8:	ef e5       	ldi	r30, 0x5F	; 95
     faa:	f0 e0       	ldi	r31, 0x00	; 0
     fac:	80 81       	ld	r24, Z
     fae:	80 68       	ori	r24, 0x80	; 128
     fb0:	8c 93       	st	X, r24
}
     fb2:	cf 91       	pop	r28
     fb4:	df 91       	pop	r29
     fb6:	08 95       	ret

00000fb8 <TIMER1_disableInterrupt>:

void TIMER1_disableInterrupt(void)
{
     fb8:	df 93       	push	r29
     fba:	cf 93       	push	r28
     fbc:	cd b7       	in	r28, 0x3d	; 61
     fbe:	de b7       	in	r29, 0x3e	; 62
	TIMSK &= ~(1<<OCIE1A);
     fc0:	a9 e5       	ldi	r26, 0x59	; 89
     fc2:	b0 e0       	ldi	r27, 0x00	; 0
     fc4:	e9 e5       	ldi	r30, 0x59	; 89
     fc6:	f0 e0       	ldi	r31, 0x00	; 0
     fc8:	80 81       	ld	r24, Z
     fca:	8f 7e       	andi	r24, 0xEF	; 239
     fcc:	8c 93       	st	X, r24
}
     fce:	cf 91       	pop	r28
     fd0:	df 91       	pop	r29
     fd2:	08 95       	ret

00000fd4 <SPI_init>:
/*
 * Description :
 * Initialize the SPI device .
 */
void SPI_init( SPI_configType* SPI_ConfigParameter)
{
     fd4:	df 93       	push	r29
     fd6:	cf 93       	push	r28
     fd8:	00 d0       	rcall	.+0      	; 0xfda <SPI_init+0x6>
     fda:	cd b7       	in	r28, 0x3d	; 61
     fdc:	de b7       	in	r29, 0x3e	; 62
     fde:	9a 83       	std	Y+2, r25	; 0x02
     fe0:	89 83       	std	Y+1, r24	; 0x01
	/*check if config as master or slave*/
	if(SPI_ConfigParameter->MasterSlaveTypes == SLAVE )
     fe2:	e9 81       	ldd	r30, Y+1	; 0x01
     fe4:	fa 81       	ldd	r31, Y+2	; 0x02
     fe6:	80 81       	ld	r24, Z
     fe8:	88 23       	and	r24, r24
     fea:	a9 f4       	brne	.+42     	; 0x1016 <SPI_init+0x42>
			 * SS(PB4)   --> Input
			 * MOSI(PB5) --> Input
			 * MISO(PB6) --> Output
			 * SCK(PB7) --> Input
			 ********************************************/
			DIO_setupPinDirection(PORTB_ID,PIN4_ID,INPUT_PIN);
     fec:	81 e0       	ldi	r24, 0x01	; 1
     fee:	64 e0       	ldi	r22, 0x04	; 4
     ff0:	40 e0       	ldi	r20, 0x00	; 0
     ff2:	0e 94 0f 09 	call	0x121e	; 0x121e <DIO_setupPinDirection>
			DIO_setupPinDirection(PORTB_ID,PIN5_ID,INPUT_PIN);
     ff6:	81 e0       	ldi	r24, 0x01	; 1
     ff8:	65 e0       	ldi	r22, 0x05	; 5
     ffa:	40 e0       	ldi	r20, 0x00	; 0
     ffc:	0e 94 0f 09 	call	0x121e	; 0x121e <DIO_setupPinDirection>
			DIO_setupPinDirection(PORTB_ID,PIN6_ID,OUTPUT_PIN);
    1000:	81 e0       	ldi	r24, 0x01	; 1
    1002:	66 e0       	ldi	r22, 0x06	; 6
    1004:	42 e0       	ldi	r20, 0x02	; 2
    1006:	0e 94 0f 09 	call	0x121e	; 0x121e <DIO_setupPinDirection>
			DIO_setupPinDirection(PORTB_ID,PIN7_ID,INPUT_PIN);
    100a:	81 e0       	ldi	r24, 0x01	; 1
    100c:	67 e0       	ldi	r22, 0x07	; 7
    100e:	40 e0       	ldi	r20, 0x00	; 0
    1010:	0e 94 0f 09 	call	0x121e	; 0x121e <DIO_setupPinDirection>
    1014:	19 c0       	rjmp	.+50     	; 0x1048 <SPI_init+0x74>
	}
	else if (SPI_ConfigParameter->MasterSlaveTypes == MASTER)
    1016:	e9 81       	ldd	r30, Y+1	; 0x01
    1018:	fa 81       	ldd	r31, Y+2	; 0x02
    101a:	80 81       	ld	r24, Z
    101c:	81 30       	cpi	r24, 0x01	; 1
    101e:	a1 f4       	brne	.+40     	; 0x1048 <SPI_init+0x74>
			 * MOSI(PB5) --> Output
			 * MISO(PB6) --> Input
			 * SCK(PB7) --> Output
			 ********************************************/

			DIO_setupPinDirection(PORTB_ID,PIN4_ID,OUTPUT_PIN);
    1020:	81 e0       	ldi	r24, 0x01	; 1
    1022:	64 e0       	ldi	r22, 0x04	; 4
    1024:	42 e0       	ldi	r20, 0x02	; 2
    1026:	0e 94 0f 09 	call	0x121e	; 0x121e <DIO_setupPinDirection>
			DIO_setupPinDirection(PORTB_ID,PIN5_ID,OUTPUT_PIN);
    102a:	81 e0       	ldi	r24, 0x01	; 1
    102c:	65 e0       	ldi	r22, 0x05	; 5
    102e:	42 e0       	ldi	r20, 0x02	; 2
    1030:	0e 94 0f 09 	call	0x121e	; 0x121e <DIO_setupPinDirection>
			DIO_setupPinDirection(PORTB_ID,PIN6_ID,INPUT_PIN);
    1034:	81 e0       	ldi	r24, 0x01	; 1
    1036:	66 e0       	ldi	r22, 0x06	; 6
    1038:	40 e0       	ldi	r20, 0x00	; 0
    103a:	0e 94 0f 09 	call	0x121e	; 0x121e <DIO_setupPinDirection>
			DIO_setupPinDirection(PORTB_ID,PIN7_ID,OUTPUT_PIN);
    103e:	81 e0       	ldi	r24, 0x01	; 1
    1040:	67 e0       	ldi	r22, 0x07	; 7
    1042:	42 e0       	ldi	r20, 0x02	; 2
    1044:	0e 94 0f 09 	call	0x121e	; 0x121e <DIO_setupPinDirection>
	}

	/*set value of clock polarity & clock phase & Enable SPI Driver */
	SPCR = ( SPI_ConfigParameter->CLOCKPOLARITY << 3) | (SPI_ConfigParameter->CLOCKPHASE << 2 ) | (SPI_ConfigParameter->MasterSlaveTypes << 4)| (1<<SPE);
    1048:	ad e2       	ldi	r26, 0x2D	; 45
    104a:	b0 e0       	ldi	r27, 0x00	; 0
    104c:	e9 81       	ldd	r30, Y+1	; 0x01
    104e:	fa 81       	ldd	r31, Y+2	; 0x02
    1050:	81 81       	ldd	r24, Z+1	; 0x01
    1052:	88 2f       	mov	r24, r24
    1054:	90 e0       	ldi	r25, 0x00	; 0
    1056:	88 0f       	add	r24, r24
    1058:	99 1f       	adc	r25, r25
    105a:	88 0f       	add	r24, r24
    105c:	99 1f       	adc	r25, r25
    105e:	88 0f       	add	r24, r24
    1060:	99 1f       	adc	r25, r25
    1062:	28 2f       	mov	r18, r24
    1064:	e9 81       	ldd	r30, Y+1	; 0x01
    1066:	fa 81       	ldd	r31, Y+2	; 0x02
    1068:	82 81       	ldd	r24, Z+2	; 0x02
    106a:	88 2f       	mov	r24, r24
    106c:	90 e0       	ldi	r25, 0x00	; 0
    106e:	88 0f       	add	r24, r24
    1070:	99 1f       	adc	r25, r25
    1072:	88 0f       	add	r24, r24
    1074:	99 1f       	adc	r25, r25
    1076:	28 2b       	or	r18, r24
    1078:	e9 81       	ldd	r30, Y+1	; 0x01
    107a:	fa 81       	ldd	r31, Y+2	; 0x02
    107c:	80 81       	ld	r24, Z
    107e:	88 2f       	mov	r24, r24
    1080:	90 e0       	ldi	r25, 0x00	; 0
    1082:	82 95       	swap	r24
    1084:	92 95       	swap	r25
    1086:	90 7f       	andi	r25, 0xF0	; 240
    1088:	98 27       	eor	r25, r24
    108a:	80 7f       	andi	r24, 0xF0	; 240
    108c:	98 27       	eor	r25, r24
    108e:	82 2b       	or	r24, r18
    1090:	80 64       	ori	r24, 0x40	; 64
    1092:	8c 93       	st	X, r24
//	SPCR |= (1 << SPR1) | (1 << SPR0);  /* optional */



	
}
    1094:	0f 90       	pop	r0
    1096:	0f 90       	pop	r0
    1098:	cf 91       	pop	r28
    109a:	df 91       	pop	r29
    109c:	08 95       	ret

0000109e <SPI_sendByte>:
 * Description :
 * Send the required data through SPI to the other SPI device.
 * In the same time data will be received from the other device.
 */
void SPI_sendByte(uint8_t data)
{
    109e:	df 93       	push	r29
    10a0:	cf 93       	push	r28
    10a2:	0f 92       	push	r0
    10a4:	cd b7       	in	r28, 0x3d	; 61
    10a6:	de b7       	in	r29, 0x3e	; 62
    10a8:	89 83       	std	Y+1, r24	; 0x01
	/* Initiate the communication and send data by SPI */
		SPDR = data;
    10aa:	ef e2       	ldi	r30, 0x2F	; 47
    10ac:	f0 e0       	ldi	r31, 0x00	; 0
    10ae:	89 81       	ldd	r24, Y+1	; 0x01
    10b0:	80 83       	st	Z, r24

		/* Wait until SPI interrupt flag SPIF = 1 (data has been sent/received correctly) */
		while(BIT_IS_CLEAR(SPSR,SPIF)){}
    10b2:	ee e2       	ldi	r30, 0x2E	; 46
    10b4:	f0 e0       	ldi	r31, 0x00	; 0
    10b6:	80 81       	ld	r24, Z
    10b8:	88 23       	and	r24, r24
    10ba:	dc f7       	brge	.-10     	; 0x10b2 <SPI_sendByte+0x14>
}
    10bc:	0f 90       	pop	r0
    10be:	cf 91       	pop	r28
    10c0:	df 91       	pop	r29
    10c2:	08 95       	ret

000010c4 <SPI_sendReceiveByte>:


uint8_t SPI_sendReceiveByte(uint8_t data)
{
    10c4:	df 93       	push	r29
    10c6:	cf 93       	push	r28
    10c8:	0f 92       	push	r0
    10ca:	cd b7       	in	r28, 0x3d	; 61
    10cc:	de b7       	in	r29, 0x3e	; 62
    10ce:	89 83       	std	Y+1, r24	; 0x01
	/* Initiate the communication and send data by SPI */
	SPDR = data;
    10d0:	ef e2       	ldi	r30, 0x2F	; 47
    10d2:	f0 e0       	ldi	r31, 0x00	; 0
    10d4:	89 81       	ldd	r24, Y+1	; 0x01
    10d6:	80 83       	st	Z, r24

	/* Wait until SPI interrupt flag SPIF = 1 (data has been sent/received correctly) */
	while(BIT_IS_CLEAR(SPSR,SPIF)){}
    10d8:	ee e2       	ldi	r30, 0x2E	; 46
    10da:	f0 e0       	ldi	r31, 0x00	; 0
    10dc:	80 81       	ld	r24, Z
    10de:	88 23       	and	r24, r24
    10e0:	dc f7       	brge	.-10     	; 0x10d8 <SPI_sendReceiveByte+0x14>

	/*
	 * Note: SPIF flag is cleared by first reading SPSR (with SPIF set) which is done in the previous step.
	 * and then accessing SPDR like the below line.
	 */
	return SPDR;
    10e2:	ef e2       	ldi	r30, 0x2F	; 47
    10e4:	f0 e0       	ldi	r31, 0x00	; 0
    10e6:	80 81       	ld	r24, Z
}
    10e8:	0f 90       	pop	r0
    10ea:	cf 91       	pop	r28
    10ec:	df 91       	pop	r29
    10ee:	08 95       	ret

000010f0 <SPI_sendString>:
/*
 * Description :
 * Send the required string through SPI to the other SPI device.
 */
void SPI_sendString(const uint8_t *str)
{
    10f0:	df 93       	push	r29
    10f2:	cf 93       	push	r28
    10f4:	00 d0       	rcall	.+0      	; 0x10f6 <SPI_sendString+0x6>
    10f6:	00 d0       	rcall	.+0      	; 0x10f8 <SPI_sendString+0x8>
    10f8:	cd b7       	in	r28, 0x3d	; 61
    10fa:	de b7       	in	r29, 0x3e	; 62
    10fc:	9c 83       	std	Y+4, r25	; 0x04
    10fe:	8b 83       	std	Y+3, r24	; 0x03
	uint8_t i = 0;
    1100:	1a 82       	std	Y+2, r1	; 0x02
	uint8_t received_data = 0;
    1102:	19 82       	std	Y+1, r1	; 0x01
    1104:	0f c0       	rjmp	.+30     	; 0x1124 <SPI_sendString+0x34>
	{
		/*
		 * received_data contains the received data from the other device.
		 * It is a dummy data variable as we just need to send the string to other device.
		 */
		received_data = SPI_sendReceiveByte(str[i]);
    1106:	8a 81       	ldd	r24, Y+2	; 0x02
    1108:	28 2f       	mov	r18, r24
    110a:	30 e0       	ldi	r19, 0x00	; 0
    110c:	8b 81       	ldd	r24, Y+3	; 0x03
    110e:	9c 81       	ldd	r25, Y+4	; 0x04
    1110:	fc 01       	movw	r30, r24
    1112:	e2 0f       	add	r30, r18
    1114:	f3 1f       	adc	r31, r19
    1116:	80 81       	ld	r24, Z
    1118:	0e 94 62 08 	call	0x10c4	; 0x10c4 <SPI_sendReceiveByte>
    111c:	89 83       	std	Y+1, r24	; 0x01
		i++;
    111e:	8a 81       	ldd	r24, Y+2	; 0x02
    1120:	8f 5f       	subi	r24, 0xFF	; 255
    1122:	8a 83       	std	Y+2, r24	; 0x02
{
	uint8_t i = 0;
	uint8_t received_data = 0;

	/* Send the whole string */
	while(str[i] != '\0')
    1124:	8a 81       	ldd	r24, Y+2	; 0x02
    1126:	28 2f       	mov	r18, r24
    1128:	30 e0       	ldi	r19, 0x00	; 0
    112a:	8b 81       	ldd	r24, Y+3	; 0x03
    112c:	9c 81       	ldd	r25, Y+4	; 0x04
    112e:	fc 01       	movw	r30, r24
    1130:	e2 0f       	add	r30, r18
    1132:	f3 1f       	adc	r31, r19
    1134:	80 81       	ld	r24, Z
    1136:	88 23       	and	r24, r24
    1138:	31 f7       	brne	.-52     	; 0x1106 <SPI_sendString+0x16>
		 * It is a dummy data variable as we just need to send the string to other device.
		 */
		received_data = SPI_sendReceiveByte(str[i]);
		i++;
	}
}
    113a:	0f 90       	pop	r0
    113c:	0f 90       	pop	r0
    113e:	0f 90       	pop	r0
    1140:	0f 90       	pop	r0
    1142:	cf 91       	pop	r28
    1144:	df 91       	pop	r29
    1146:	08 95       	ret

00001148 <SPI_receiveString>:
/*
 * Description :
 * Receive the required string until the '#' symbol through SPI from the other SPI device.
 */
void SPI_receiveString(uint8_t *str)
{
    1148:	0f 93       	push	r16
    114a:	1f 93       	push	r17
    114c:	df 93       	push	r29
    114e:	cf 93       	push	r28
    1150:	00 d0       	rcall	.+0      	; 0x1152 <SPI_receiveString+0xa>
    1152:	0f 92       	push	r0
    1154:	cd b7       	in	r28, 0x3d	; 61
    1156:	de b7       	in	r29, 0x3e	; 62
    1158:	9b 83       	std	Y+3, r25	; 0x03
    115a:	8a 83       	std	Y+2, r24	; 0x02
	uint8_t i = 0;
    115c:	19 82       	std	Y+1, r1	; 0x01

	/* Receive the first byte */
	str[i] = SPI_sendReceiveByte(SPI_DEFAULT_DATA_VALUE);
    115e:	89 81       	ldd	r24, Y+1	; 0x01
    1160:	28 2f       	mov	r18, r24
    1162:	30 e0       	ldi	r19, 0x00	; 0
    1164:	8a 81       	ldd	r24, Y+2	; 0x02
    1166:	9b 81       	ldd	r25, Y+3	; 0x03
    1168:	8c 01       	movw	r16, r24
    116a:	02 0f       	add	r16, r18
    116c:	13 1f       	adc	r17, r19
    116e:	8f ef       	ldi	r24, 0xFF	; 255
    1170:	0e 94 62 08 	call	0x10c4	; 0x10c4 <SPI_sendReceiveByte>
    1174:	f8 01       	movw	r30, r16
    1176:	80 83       	st	Z, r24
    1178:	10 c0       	rjmp	.+32     	; 0x119a <SPI_receiveString+0x52>

	/* Receive the whole string until the '#' */
	while(str[i] != '#')
	{
		i++;
    117a:	89 81       	ldd	r24, Y+1	; 0x01
    117c:	8f 5f       	subi	r24, 0xFF	; 255
    117e:	89 83       	std	Y+1, r24	; 0x01
		str[i] = SPI_sendReceiveByte(SPI_DEFAULT_DATA_VALUE);
    1180:	89 81       	ldd	r24, Y+1	; 0x01
    1182:	28 2f       	mov	r18, r24
    1184:	30 e0       	ldi	r19, 0x00	; 0
    1186:	8a 81       	ldd	r24, Y+2	; 0x02
    1188:	9b 81       	ldd	r25, Y+3	; 0x03
    118a:	8c 01       	movw	r16, r24
    118c:	02 0f       	add	r16, r18
    118e:	13 1f       	adc	r17, r19
    1190:	8f ef       	ldi	r24, 0xFF	; 255
    1192:	0e 94 62 08 	call	0x10c4	; 0x10c4 <SPI_sendReceiveByte>
    1196:	f8 01       	movw	r30, r16
    1198:	80 83       	st	Z, r24

	/* Receive the first byte */
	str[i] = SPI_sendReceiveByte(SPI_DEFAULT_DATA_VALUE);

	/* Receive the whole string until the '#' */
	while(str[i] != '#')
    119a:	89 81       	ldd	r24, Y+1	; 0x01
    119c:	28 2f       	mov	r18, r24
    119e:	30 e0       	ldi	r19, 0x00	; 0
    11a0:	8a 81       	ldd	r24, Y+2	; 0x02
    11a2:	9b 81       	ldd	r25, Y+3	; 0x03
    11a4:	fc 01       	movw	r30, r24
    11a6:	e2 0f       	add	r30, r18
    11a8:	f3 1f       	adc	r31, r19
    11aa:	80 81       	ld	r24, Z
    11ac:	83 32       	cpi	r24, 0x23	; 35
    11ae:	29 f7       	brne	.-54     	; 0x117a <SPI_receiveString+0x32>
		i++;
		str[i] = SPI_sendReceiveByte(SPI_DEFAULT_DATA_VALUE);
	}

	/* After receiving the whole string plus the '#', replace the '#' with '\0' */
	str[i] = '\0';
    11b0:	89 81       	ldd	r24, Y+1	; 0x01
    11b2:	28 2f       	mov	r18, r24
    11b4:	30 e0       	ldi	r19, 0x00	; 0
    11b6:	8a 81       	ldd	r24, Y+2	; 0x02
    11b8:	9b 81       	ldd	r25, Y+3	; 0x03
    11ba:	fc 01       	movw	r30, r24
    11bc:	e2 0f       	add	r30, r18
    11be:	f3 1f       	adc	r31, r19
    11c0:	10 82       	st	Z, r1
}
    11c2:	0f 90       	pop	r0
    11c4:	0f 90       	pop	r0
    11c6:	0f 90       	pop	r0
    11c8:	cf 91       	pop	r28
    11ca:	df 91       	pop	r29
    11cc:	1f 91       	pop	r17
    11ce:	0f 91       	pop	r16
    11d0:	08 95       	ret

000011d2 <PWM_Timer0_Start>:
 #include "../PWM/timer0.h"

#include <avr/io.h>
 
 void PWM_Timer0_Start(uint8_t duty_cycle)
 {
    11d2:	df 93       	push	r29
    11d4:	cf 93       	push	r28
    11d6:	0f 92       	push	r0
    11d8:	cd b7       	in	r28, 0x3d	; 61
    11da:	de b7       	in	r29, 0x3e	; 62
    11dc:	89 83       	std	Y+1, r24	; 0x01
	
	TCNT0 = 0; // Set Timer Initial Value to 0
    11de:	e2 e5       	ldi	r30, 0x52	; 82
    11e0:	f0 e0       	ldi	r31, 0x00	; 0
    11e2:	10 82       	st	Z, r1
	
	OCR0  = (uint8_t)(((uint16_t)(duty_cycle*256))/100); // Set Compare Value
    11e4:	ec e5       	ldi	r30, 0x5C	; 92
    11e6:	f0 e0       	ldi	r31, 0x00	; 0
    11e8:	89 81       	ldd	r24, Y+1	; 0x01
    11ea:	88 2f       	mov	r24, r24
    11ec:	90 e0       	ldi	r25, 0x00	; 0
    11ee:	98 2f       	mov	r25, r24
    11f0:	88 27       	eor	r24, r24
    11f2:	24 e6       	ldi	r18, 0x64	; 100
    11f4:	30 e0       	ldi	r19, 0x00	; 0
    11f6:	b9 01       	movw	r22, r18
    11f8:	0e 94 32 17 	call	0x2e64	; 0x2e64 <__udivmodhi4>
    11fc:	cb 01       	movw	r24, r22
    11fe:	80 83       	st	Z, r24
	
	DDRB  = DDRB | (1<<PB3); // Configure PB3/OC0 as output pin --> pin where the PWM signal is generated from MC
    1200:	a7 e3       	ldi	r26, 0x37	; 55
    1202:	b0 e0       	ldi	r27, 0x00	; 0
    1204:	e7 e3       	ldi	r30, 0x37	; 55
    1206:	f0 e0       	ldi	r31, 0x00	; 0
    1208:	80 81       	ld	r24, Z
    120a:	88 60       	ori	r24, 0x08	; 8
    120c:	8c 93       	st	X, r24
	 * 1. Fast PWM mode FOC0=0
	 * 2. Fast PWM Mode WGM01=1 & WGM00=1
	 * 3. Clear OC0 when match occurs (non inverted mode) COM00=0 & COM01=1
	 * 4. clock = F_CPU/8 CS00=0 CS01=1 CS02=0
	 */ 
	TCCR0 = (1<<WGM00) | (1<<WGM01) | (1<<COM01) | (1<<CS01);
    120e:	e3 e5       	ldi	r30, 0x53	; 83
    1210:	f0 e0       	ldi	r31, 0x00	; 0
    1212:	8a e6       	ldi	r24, 0x6A	; 106
    1214:	80 83       	st	Z, r24
	 
 }
    1216:	0f 90       	pop	r0
    1218:	cf 91       	pop	r28
    121a:	df 91       	pop	r29
    121c:	08 95       	ret

0000121e <DIO_setupPinDirection>:
#include "DIO.h"
/*********************************************************
*               Implement
*********************************************************/
void DIO_setupPinDirection(uint8_t PORT_X ,uint8_t PIN_NUM,GPIO_PinDirectionTypes DIRECTION )
{
    121e:	df 93       	push	r29
    1220:	cf 93       	push	r28
    1222:	00 d0       	rcall	.+0      	; 0x1224 <DIO_setupPinDirection+0x6>
    1224:	00 d0       	rcall	.+0      	; 0x1226 <DIO_setupPinDirection+0x8>
    1226:	0f 92       	push	r0
    1228:	cd b7       	in	r28, 0x3d	; 61
    122a:	de b7       	in	r29, 0x3e	; 62
    122c:	89 83       	std	Y+1, r24	; 0x01
    122e:	6a 83       	std	Y+2, r22	; 0x02
    1230:	4b 83       	std	Y+3, r20	; 0x03
	if( (PIN_NUM >= NUM_OF_PIN_PER_PORT) || (PORT_X >= NUM_OF_PORT) )
    1232:	8a 81       	ldd	r24, Y+2	; 0x02
    1234:	88 30       	cpi	r24, 0x08	; 8
    1236:	08 f0       	brcs	.+2      	; 0x123a <DIO_setupPinDirection+0x1c>
    1238:	8c c1       	rjmp	.+792    	; 0x1552 <DIO_setupPinDirection+0x334>
    123a:	89 81       	ldd	r24, Y+1	; 0x01
    123c:	84 30       	cpi	r24, 0x04	; 4
    123e:	08 f0       	brcs	.+2      	; 0x1242 <DIO_setupPinDirection+0x24>
    1240:	88 c1       	rjmp	.+784    	; 0x1552 <DIO_setupPinDirection+0x334>
		
		//Error handling ,Nothing to do
	}
	else
	{
		switch(PORT_X)
    1242:	89 81       	ldd	r24, Y+1	; 0x01
    1244:	28 2f       	mov	r18, r24
    1246:	30 e0       	ldi	r19, 0x00	; 0
    1248:	3d 83       	std	Y+5, r19	; 0x05
    124a:	2c 83       	std	Y+4, r18	; 0x04
    124c:	8c 81       	ldd	r24, Y+4	; 0x04
    124e:	9d 81       	ldd	r25, Y+5	; 0x05
    1250:	81 30       	cpi	r24, 0x01	; 1
    1252:	91 05       	cpc	r25, r1
    1254:	09 f4       	brne	.+2      	; 0x1258 <DIO_setupPinDirection+0x3a>
    1256:	71 c0       	rjmp	.+226    	; 0x133a <DIO_setupPinDirection+0x11c>
    1258:	2c 81       	ldd	r18, Y+4	; 0x04
    125a:	3d 81       	ldd	r19, Y+5	; 0x05
    125c:	22 30       	cpi	r18, 0x02	; 2
    125e:	31 05       	cpc	r19, r1
    1260:	2c f4       	brge	.+10     	; 0x126c <DIO_setupPinDirection+0x4e>
    1262:	8c 81       	ldd	r24, Y+4	; 0x04
    1264:	9d 81       	ldd	r25, Y+5	; 0x05
    1266:	00 97       	sbiw	r24, 0x00	; 0
    1268:	71 f0       	breq	.+28     	; 0x1286 <DIO_setupPinDirection+0x68>
    126a:	73 c1       	rjmp	.+742    	; 0x1552 <DIO_setupPinDirection+0x334>
    126c:	2c 81       	ldd	r18, Y+4	; 0x04
    126e:	3d 81       	ldd	r19, Y+5	; 0x05
    1270:	22 30       	cpi	r18, 0x02	; 2
    1272:	31 05       	cpc	r19, r1
    1274:	09 f4       	brne	.+2      	; 0x1278 <DIO_setupPinDirection+0x5a>
    1276:	bb c0       	rjmp	.+374    	; 0x13ee <DIO_setupPinDirection+0x1d0>
    1278:	8c 81       	ldd	r24, Y+4	; 0x04
    127a:	9d 81       	ldd	r25, Y+5	; 0x05
    127c:	83 30       	cpi	r24, 0x03	; 3
    127e:	91 05       	cpc	r25, r1
    1280:	09 f4       	brne	.+2      	; 0x1284 <DIO_setupPinDirection+0x66>
    1282:	0f c1       	rjmp	.+542    	; 0x14a2 <DIO_setupPinDirection+0x284>
    1284:	66 c1       	rjmp	.+716    	; 0x1552 <DIO_setupPinDirection+0x334>
		{
			case PORTA_ID:
				if(DIRECTION == INPUT_PIN)
    1286:	8b 81       	ldd	r24, Y+3	; 0x03
    1288:	88 23       	and	r24, r24
    128a:	a9 f4       	brne	.+42     	; 0x12b6 <DIO_setupPinDirection+0x98>
				{
					CLEAR_BIT(DDRA,PIN_NUM);//put "zero" in this bit in DDR to make it input pin
    128c:	aa e3       	ldi	r26, 0x3A	; 58
    128e:	b0 e0       	ldi	r27, 0x00	; 0
    1290:	ea e3       	ldi	r30, 0x3A	; 58
    1292:	f0 e0       	ldi	r31, 0x00	; 0
    1294:	80 81       	ld	r24, Z
    1296:	48 2f       	mov	r20, r24
    1298:	8a 81       	ldd	r24, Y+2	; 0x02
    129a:	28 2f       	mov	r18, r24
    129c:	30 e0       	ldi	r19, 0x00	; 0
    129e:	81 e0       	ldi	r24, 0x01	; 1
    12a0:	90 e0       	ldi	r25, 0x00	; 0
    12a2:	02 2e       	mov	r0, r18
    12a4:	02 c0       	rjmp	.+4      	; 0x12aa <DIO_setupPinDirection+0x8c>
    12a6:	88 0f       	add	r24, r24
    12a8:	99 1f       	adc	r25, r25
    12aa:	0a 94       	dec	r0
    12ac:	e2 f7       	brpl	.-8      	; 0x12a6 <DIO_setupPinDirection+0x88>
    12ae:	80 95       	com	r24
    12b0:	84 23       	and	r24, r20
    12b2:	8c 93       	st	X, r24
    12b4:	4e c1       	rjmp	.+668    	; 0x1552 <DIO_setupPinDirection+0x334>
				}
				else if(DIRECTION == INPUT_PIN_PULLUP)
    12b6:	8b 81       	ldd	r24, Y+3	; 0x03
    12b8:	81 30       	cpi	r24, 0x01	; 1
    12ba:	39 f5       	brne	.+78     	; 0x130a <DIO_setupPinDirection+0xec>
				{
					CLEAR_BIT(DDRA,PIN_NUM);//put "zero" in this bit in DDR to make it input pin
    12bc:	aa e3       	ldi	r26, 0x3A	; 58
    12be:	b0 e0       	ldi	r27, 0x00	; 0
    12c0:	ea e3       	ldi	r30, 0x3A	; 58
    12c2:	f0 e0       	ldi	r31, 0x00	; 0
    12c4:	80 81       	ld	r24, Z
    12c6:	48 2f       	mov	r20, r24
    12c8:	8a 81       	ldd	r24, Y+2	; 0x02
    12ca:	28 2f       	mov	r18, r24
    12cc:	30 e0       	ldi	r19, 0x00	; 0
    12ce:	81 e0       	ldi	r24, 0x01	; 1
    12d0:	90 e0       	ldi	r25, 0x00	; 0
    12d2:	02 c0       	rjmp	.+4      	; 0x12d8 <DIO_setupPinDirection+0xba>
    12d4:	88 0f       	add	r24, r24
    12d6:	99 1f       	adc	r25, r25
    12d8:	2a 95       	dec	r18
    12da:	e2 f7       	brpl	.-8      	; 0x12d4 <DIO_setupPinDirection+0xb6>
    12dc:	80 95       	com	r24
    12de:	84 23       	and	r24, r20
    12e0:	8c 93       	st	X, r24
					SET_BIT(PORTA,PIN_NUM);// put "one" in this bit in port to activate pull up internal
    12e2:	ab e3       	ldi	r26, 0x3B	; 59
    12e4:	b0 e0       	ldi	r27, 0x00	; 0
    12e6:	eb e3       	ldi	r30, 0x3B	; 59
    12e8:	f0 e0       	ldi	r31, 0x00	; 0
    12ea:	80 81       	ld	r24, Z
    12ec:	48 2f       	mov	r20, r24
    12ee:	8a 81       	ldd	r24, Y+2	; 0x02
    12f0:	28 2f       	mov	r18, r24
    12f2:	30 e0       	ldi	r19, 0x00	; 0
    12f4:	81 e0       	ldi	r24, 0x01	; 1
    12f6:	90 e0       	ldi	r25, 0x00	; 0
    12f8:	02 2e       	mov	r0, r18
    12fa:	02 c0       	rjmp	.+4      	; 0x1300 <DIO_setupPinDirection+0xe2>
    12fc:	88 0f       	add	r24, r24
    12fe:	99 1f       	adc	r25, r25
    1300:	0a 94       	dec	r0
    1302:	e2 f7       	brpl	.-8      	; 0x12fc <DIO_setupPinDirection+0xde>
    1304:	84 2b       	or	r24, r20
    1306:	8c 93       	st	X, r24
    1308:	24 c1       	rjmp	.+584    	; 0x1552 <DIO_setupPinDirection+0x334>
				}
				else if(DIRECTION == OUTPUT_PIN)
    130a:	8b 81       	ldd	r24, Y+3	; 0x03
    130c:	82 30       	cpi	r24, 0x02	; 2
    130e:	09 f0       	breq	.+2      	; 0x1312 <DIO_setupPinDirection+0xf4>
    1310:	20 c1       	rjmp	.+576    	; 0x1552 <DIO_setupPinDirection+0x334>
				{
					SET_BIT(DDRA,PIN_NUM);//put "one" in this bit in DDR to make it output pin
    1312:	aa e3       	ldi	r26, 0x3A	; 58
    1314:	b0 e0       	ldi	r27, 0x00	; 0
    1316:	ea e3       	ldi	r30, 0x3A	; 58
    1318:	f0 e0       	ldi	r31, 0x00	; 0
    131a:	80 81       	ld	r24, Z
    131c:	48 2f       	mov	r20, r24
    131e:	8a 81       	ldd	r24, Y+2	; 0x02
    1320:	28 2f       	mov	r18, r24
    1322:	30 e0       	ldi	r19, 0x00	; 0
    1324:	81 e0       	ldi	r24, 0x01	; 1
    1326:	90 e0       	ldi	r25, 0x00	; 0
    1328:	02 2e       	mov	r0, r18
    132a:	02 c0       	rjmp	.+4      	; 0x1330 <DIO_setupPinDirection+0x112>
    132c:	88 0f       	add	r24, r24
    132e:	99 1f       	adc	r25, r25
    1330:	0a 94       	dec	r0
    1332:	e2 f7       	brpl	.-8      	; 0x132c <DIO_setupPinDirection+0x10e>
    1334:	84 2b       	or	r24, r20
    1336:	8c 93       	st	X, r24
    1338:	0c c1       	rjmp	.+536    	; 0x1552 <DIO_setupPinDirection+0x334>
				{
					/*  worng direction*/
				}
				break;
			case PORTB_ID:
				if(DIRECTION == INPUT_PIN)
    133a:	8b 81       	ldd	r24, Y+3	; 0x03
    133c:	88 23       	and	r24, r24
    133e:	a9 f4       	brne	.+42     	; 0x136a <DIO_setupPinDirection+0x14c>
				{
					CLEAR_BIT(DDRB,PIN_NUM);//put "zero" in this bit in DDR to make it input pin
    1340:	a7 e3       	ldi	r26, 0x37	; 55
    1342:	b0 e0       	ldi	r27, 0x00	; 0
    1344:	e7 e3       	ldi	r30, 0x37	; 55
    1346:	f0 e0       	ldi	r31, 0x00	; 0
    1348:	80 81       	ld	r24, Z
    134a:	48 2f       	mov	r20, r24
    134c:	8a 81       	ldd	r24, Y+2	; 0x02
    134e:	28 2f       	mov	r18, r24
    1350:	30 e0       	ldi	r19, 0x00	; 0
    1352:	81 e0       	ldi	r24, 0x01	; 1
    1354:	90 e0       	ldi	r25, 0x00	; 0
    1356:	02 2e       	mov	r0, r18
    1358:	02 c0       	rjmp	.+4      	; 0x135e <DIO_setupPinDirection+0x140>
    135a:	88 0f       	add	r24, r24
    135c:	99 1f       	adc	r25, r25
    135e:	0a 94       	dec	r0
    1360:	e2 f7       	brpl	.-8      	; 0x135a <DIO_setupPinDirection+0x13c>
    1362:	80 95       	com	r24
    1364:	84 23       	and	r24, r20
    1366:	8c 93       	st	X, r24
    1368:	f4 c0       	rjmp	.+488    	; 0x1552 <DIO_setupPinDirection+0x334>
				}
				else if(DIRECTION == INPUT_PIN_PULLUP)
    136a:	8b 81       	ldd	r24, Y+3	; 0x03
    136c:	81 30       	cpi	r24, 0x01	; 1
    136e:	39 f5       	brne	.+78     	; 0x13be <DIO_setupPinDirection+0x1a0>
				{
					CLEAR_BIT(DDRB,PIN_NUM);//put "zero" in this bit in DDR to make it input pin
    1370:	a7 e3       	ldi	r26, 0x37	; 55
    1372:	b0 e0       	ldi	r27, 0x00	; 0
    1374:	e7 e3       	ldi	r30, 0x37	; 55
    1376:	f0 e0       	ldi	r31, 0x00	; 0
    1378:	80 81       	ld	r24, Z
    137a:	48 2f       	mov	r20, r24
    137c:	8a 81       	ldd	r24, Y+2	; 0x02
    137e:	28 2f       	mov	r18, r24
    1380:	30 e0       	ldi	r19, 0x00	; 0
    1382:	81 e0       	ldi	r24, 0x01	; 1
    1384:	90 e0       	ldi	r25, 0x00	; 0
    1386:	02 c0       	rjmp	.+4      	; 0x138c <DIO_setupPinDirection+0x16e>
    1388:	88 0f       	add	r24, r24
    138a:	99 1f       	adc	r25, r25
    138c:	2a 95       	dec	r18
    138e:	e2 f7       	brpl	.-8      	; 0x1388 <DIO_setupPinDirection+0x16a>
    1390:	80 95       	com	r24
    1392:	84 23       	and	r24, r20
    1394:	8c 93       	st	X, r24
					SET_BIT(PORTB,PIN_NUM);// put "one" in this bit in port to activate pull up internal
    1396:	a8 e3       	ldi	r26, 0x38	; 56
    1398:	b0 e0       	ldi	r27, 0x00	; 0
    139a:	e8 e3       	ldi	r30, 0x38	; 56
    139c:	f0 e0       	ldi	r31, 0x00	; 0
    139e:	80 81       	ld	r24, Z
    13a0:	48 2f       	mov	r20, r24
    13a2:	8a 81       	ldd	r24, Y+2	; 0x02
    13a4:	28 2f       	mov	r18, r24
    13a6:	30 e0       	ldi	r19, 0x00	; 0
    13a8:	81 e0       	ldi	r24, 0x01	; 1
    13aa:	90 e0       	ldi	r25, 0x00	; 0
    13ac:	02 2e       	mov	r0, r18
    13ae:	02 c0       	rjmp	.+4      	; 0x13b4 <DIO_setupPinDirection+0x196>
    13b0:	88 0f       	add	r24, r24
    13b2:	99 1f       	adc	r25, r25
    13b4:	0a 94       	dec	r0
    13b6:	e2 f7       	brpl	.-8      	; 0x13b0 <DIO_setupPinDirection+0x192>
    13b8:	84 2b       	or	r24, r20
    13ba:	8c 93       	st	X, r24
    13bc:	ca c0       	rjmp	.+404    	; 0x1552 <DIO_setupPinDirection+0x334>
				}
				else if(DIRECTION == OUTPUT_PIN)
    13be:	8b 81       	ldd	r24, Y+3	; 0x03
    13c0:	82 30       	cpi	r24, 0x02	; 2
    13c2:	09 f0       	breq	.+2      	; 0x13c6 <DIO_setupPinDirection+0x1a8>
    13c4:	c6 c0       	rjmp	.+396    	; 0x1552 <DIO_setupPinDirection+0x334>
				{
					SET_BIT(DDRB,PIN_NUM);//put "one" in this bit in DDR to make it output pin
    13c6:	a7 e3       	ldi	r26, 0x37	; 55
    13c8:	b0 e0       	ldi	r27, 0x00	; 0
    13ca:	e7 e3       	ldi	r30, 0x37	; 55
    13cc:	f0 e0       	ldi	r31, 0x00	; 0
    13ce:	80 81       	ld	r24, Z
    13d0:	48 2f       	mov	r20, r24
    13d2:	8a 81       	ldd	r24, Y+2	; 0x02
    13d4:	28 2f       	mov	r18, r24
    13d6:	30 e0       	ldi	r19, 0x00	; 0
    13d8:	81 e0       	ldi	r24, 0x01	; 1
    13da:	90 e0       	ldi	r25, 0x00	; 0
    13dc:	02 2e       	mov	r0, r18
    13de:	02 c0       	rjmp	.+4      	; 0x13e4 <DIO_setupPinDirection+0x1c6>
    13e0:	88 0f       	add	r24, r24
    13e2:	99 1f       	adc	r25, r25
    13e4:	0a 94       	dec	r0
    13e6:	e2 f7       	brpl	.-8      	; 0x13e0 <DIO_setupPinDirection+0x1c2>
    13e8:	84 2b       	or	r24, r20
    13ea:	8c 93       	st	X, r24
    13ec:	b2 c0       	rjmp	.+356    	; 0x1552 <DIO_setupPinDirection+0x334>
				{
					/*  wrong direction*/
				}
				break;
			case PORTC_ID:
				if(DIRECTION == INPUT_PIN)
    13ee:	8b 81       	ldd	r24, Y+3	; 0x03
    13f0:	88 23       	and	r24, r24
    13f2:	a9 f4       	brne	.+42     	; 0x141e <DIO_setupPinDirection+0x200>
				{
					CLEAR_BIT(DDRC,PIN_NUM);//put "zero" in this bit in DDR to make it input pin
    13f4:	a4 e3       	ldi	r26, 0x34	; 52
    13f6:	b0 e0       	ldi	r27, 0x00	; 0
    13f8:	e4 e3       	ldi	r30, 0x34	; 52
    13fa:	f0 e0       	ldi	r31, 0x00	; 0
    13fc:	80 81       	ld	r24, Z
    13fe:	48 2f       	mov	r20, r24
    1400:	8a 81       	ldd	r24, Y+2	; 0x02
    1402:	28 2f       	mov	r18, r24
    1404:	30 e0       	ldi	r19, 0x00	; 0
    1406:	81 e0       	ldi	r24, 0x01	; 1
    1408:	90 e0       	ldi	r25, 0x00	; 0
    140a:	02 2e       	mov	r0, r18
    140c:	02 c0       	rjmp	.+4      	; 0x1412 <DIO_setupPinDirection+0x1f4>
    140e:	88 0f       	add	r24, r24
    1410:	99 1f       	adc	r25, r25
    1412:	0a 94       	dec	r0
    1414:	e2 f7       	brpl	.-8      	; 0x140e <DIO_setupPinDirection+0x1f0>
    1416:	80 95       	com	r24
    1418:	84 23       	and	r24, r20
    141a:	8c 93       	st	X, r24
    141c:	9a c0       	rjmp	.+308    	; 0x1552 <DIO_setupPinDirection+0x334>
				}
				else if(DIRECTION == INPUT_PIN_PULLUP)
    141e:	8b 81       	ldd	r24, Y+3	; 0x03
    1420:	81 30       	cpi	r24, 0x01	; 1
    1422:	39 f5       	brne	.+78     	; 0x1472 <DIO_setupPinDirection+0x254>
				{
					CLEAR_BIT(DDRC,PIN_NUM);//put "zero" in this bit in DDR to make it input pin
    1424:	a4 e3       	ldi	r26, 0x34	; 52
    1426:	b0 e0       	ldi	r27, 0x00	; 0
    1428:	e4 e3       	ldi	r30, 0x34	; 52
    142a:	f0 e0       	ldi	r31, 0x00	; 0
    142c:	80 81       	ld	r24, Z
    142e:	48 2f       	mov	r20, r24
    1430:	8a 81       	ldd	r24, Y+2	; 0x02
    1432:	28 2f       	mov	r18, r24
    1434:	30 e0       	ldi	r19, 0x00	; 0
    1436:	81 e0       	ldi	r24, 0x01	; 1
    1438:	90 e0       	ldi	r25, 0x00	; 0
    143a:	02 c0       	rjmp	.+4      	; 0x1440 <DIO_setupPinDirection+0x222>
    143c:	88 0f       	add	r24, r24
    143e:	99 1f       	adc	r25, r25
    1440:	2a 95       	dec	r18
    1442:	e2 f7       	brpl	.-8      	; 0x143c <DIO_setupPinDirection+0x21e>
    1444:	80 95       	com	r24
    1446:	84 23       	and	r24, r20
    1448:	8c 93       	st	X, r24
					SET_BIT(PORTC,PIN_NUM);// put "one" in this bit in port to activate pull up internal
    144a:	a5 e3       	ldi	r26, 0x35	; 53
    144c:	b0 e0       	ldi	r27, 0x00	; 0
    144e:	e5 e3       	ldi	r30, 0x35	; 53
    1450:	f0 e0       	ldi	r31, 0x00	; 0
    1452:	80 81       	ld	r24, Z
    1454:	48 2f       	mov	r20, r24
    1456:	8a 81       	ldd	r24, Y+2	; 0x02
    1458:	28 2f       	mov	r18, r24
    145a:	30 e0       	ldi	r19, 0x00	; 0
    145c:	81 e0       	ldi	r24, 0x01	; 1
    145e:	90 e0       	ldi	r25, 0x00	; 0
    1460:	02 2e       	mov	r0, r18
    1462:	02 c0       	rjmp	.+4      	; 0x1468 <DIO_setupPinDirection+0x24a>
    1464:	88 0f       	add	r24, r24
    1466:	99 1f       	adc	r25, r25
    1468:	0a 94       	dec	r0
    146a:	e2 f7       	brpl	.-8      	; 0x1464 <DIO_setupPinDirection+0x246>
    146c:	84 2b       	or	r24, r20
    146e:	8c 93       	st	X, r24
    1470:	70 c0       	rjmp	.+224    	; 0x1552 <DIO_setupPinDirection+0x334>
				}
				else if(DIRECTION == OUTPUT_PIN)
    1472:	8b 81       	ldd	r24, Y+3	; 0x03
    1474:	82 30       	cpi	r24, 0x02	; 2
    1476:	09 f0       	breq	.+2      	; 0x147a <DIO_setupPinDirection+0x25c>
    1478:	6c c0       	rjmp	.+216    	; 0x1552 <DIO_setupPinDirection+0x334>
				{
					SET_BIT(DDRC,PIN_NUM);//put "one" in this bit in DDR to make it output pin
    147a:	a4 e3       	ldi	r26, 0x34	; 52
    147c:	b0 e0       	ldi	r27, 0x00	; 0
    147e:	e4 e3       	ldi	r30, 0x34	; 52
    1480:	f0 e0       	ldi	r31, 0x00	; 0
    1482:	80 81       	ld	r24, Z
    1484:	48 2f       	mov	r20, r24
    1486:	8a 81       	ldd	r24, Y+2	; 0x02
    1488:	28 2f       	mov	r18, r24
    148a:	30 e0       	ldi	r19, 0x00	; 0
    148c:	81 e0       	ldi	r24, 0x01	; 1
    148e:	90 e0       	ldi	r25, 0x00	; 0
    1490:	02 2e       	mov	r0, r18
    1492:	02 c0       	rjmp	.+4      	; 0x1498 <DIO_setupPinDirection+0x27a>
    1494:	88 0f       	add	r24, r24
    1496:	99 1f       	adc	r25, r25
    1498:	0a 94       	dec	r0
    149a:	e2 f7       	brpl	.-8      	; 0x1494 <DIO_setupPinDirection+0x276>
    149c:	84 2b       	or	r24, r20
    149e:	8c 93       	st	X, r24
    14a0:	58 c0       	rjmp	.+176    	; 0x1552 <DIO_setupPinDirection+0x334>
				{
					/*  wrong direction*/
				}
				break;
			case PORTD_ID:
				if(DIRECTION == INPUT_PIN)
    14a2:	8b 81       	ldd	r24, Y+3	; 0x03
    14a4:	88 23       	and	r24, r24
    14a6:	a9 f4       	brne	.+42     	; 0x14d2 <DIO_setupPinDirection+0x2b4>
				{
					CLEAR_BIT(DDRD,PIN_NUM);//put "zero" in this bit in DDR to make it input pin
    14a8:	a1 e3       	ldi	r26, 0x31	; 49
    14aa:	b0 e0       	ldi	r27, 0x00	; 0
    14ac:	e1 e3       	ldi	r30, 0x31	; 49
    14ae:	f0 e0       	ldi	r31, 0x00	; 0
    14b0:	80 81       	ld	r24, Z
    14b2:	48 2f       	mov	r20, r24
    14b4:	8a 81       	ldd	r24, Y+2	; 0x02
    14b6:	28 2f       	mov	r18, r24
    14b8:	30 e0       	ldi	r19, 0x00	; 0
    14ba:	81 e0       	ldi	r24, 0x01	; 1
    14bc:	90 e0       	ldi	r25, 0x00	; 0
    14be:	02 2e       	mov	r0, r18
    14c0:	02 c0       	rjmp	.+4      	; 0x14c6 <DIO_setupPinDirection+0x2a8>
    14c2:	88 0f       	add	r24, r24
    14c4:	99 1f       	adc	r25, r25
    14c6:	0a 94       	dec	r0
    14c8:	e2 f7       	brpl	.-8      	; 0x14c2 <DIO_setupPinDirection+0x2a4>
    14ca:	80 95       	com	r24
    14cc:	84 23       	and	r24, r20
    14ce:	8c 93       	st	X, r24
    14d0:	40 c0       	rjmp	.+128    	; 0x1552 <DIO_setupPinDirection+0x334>
				}
				else if(DIRECTION == INPUT_PIN_PULLUP)
    14d2:	8b 81       	ldd	r24, Y+3	; 0x03
    14d4:	81 30       	cpi	r24, 0x01	; 1
    14d6:	39 f5       	brne	.+78     	; 0x1526 <DIO_setupPinDirection+0x308>
				{
					CLEAR_BIT(DDRD,PIN_NUM);//put "zero" in this bit in DDR to make it input pin
    14d8:	a1 e3       	ldi	r26, 0x31	; 49
    14da:	b0 e0       	ldi	r27, 0x00	; 0
    14dc:	e1 e3       	ldi	r30, 0x31	; 49
    14de:	f0 e0       	ldi	r31, 0x00	; 0
    14e0:	80 81       	ld	r24, Z
    14e2:	48 2f       	mov	r20, r24
    14e4:	8a 81       	ldd	r24, Y+2	; 0x02
    14e6:	28 2f       	mov	r18, r24
    14e8:	30 e0       	ldi	r19, 0x00	; 0
    14ea:	81 e0       	ldi	r24, 0x01	; 1
    14ec:	90 e0       	ldi	r25, 0x00	; 0
    14ee:	02 c0       	rjmp	.+4      	; 0x14f4 <DIO_setupPinDirection+0x2d6>
    14f0:	88 0f       	add	r24, r24
    14f2:	99 1f       	adc	r25, r25
    14f4:	2a 95       	dec	r18
    14f6:	e2 f7       	brpl	.-8      	; 0x14f0 <DIO_setupPinDirection+0x2d2>
    14f8:	80 95       	com	r24
    14fa:	84 23       	and	r24, r20
    14fc:	8c 93       	st	X, r24
					SET_BIT(PORTD,PIN_NUM);// put "one" in this bit in port to activate pull up internal
    14fe:	a2 e3       	ldi	r26, 0x32	; 50
    1500:	b0 e0       	ldi	r27, 0x00	; 0
    1502:	e2 e3       	ldi	r30, 0x32	; 50
    1504:	f0 e0       	ldi	r31, 0x00	; 0
    1506:	80 81       	ld	r24, Z
    1508:	48 2f       	mov	r20, r24
    150a:	8a 81       	ldd	r24, Y+2	; 0x02
    150c:	28 2f       	mov	r18, r24
    150e:	30 e0       	ldi	r19, 0x00	; 0
    1510:	81 e0       	ldi	r24, 0x01	; 1
    1512:	90 e0       	ldi	r25, 0x00	; 0
    1514:	02 2e       	mov	r0, r18
    1516:	02 c0       	rjmp	.+4      	; 0x151c <DIO_setupPinDirection+0x2fe>
    1518:	88 0f       	add	r24, r24
    151a:	99 1f       	adc	r25, r25
    151c:	0a 94       	dec	r0
    151e:	e2 f7       	brpl	.-8      	; 0x1518 <DIO_setupPinDirection+0x2fa>
    1520:	84 2b       	or	r24, r20
    1522:	8c 93       	st	X, r24
    1524:	16 c0       	rjmp	.+44     	; 0x1552 <DIO_setupPinDirection+0x334>
				}
				else if(DIRECTION == OUTPUT_PIN)
    1526:	8b 81       	ldd	r24, Y+3	; 0x03
    1528:	82 30       	cpi	r24, 0x02	; 2
    152a:	99 f4       	brne	.+38     	; 0x1552 <DIO_setupPinDirection+0x334>
				{
					SET_BIT(DDRD,PIN_NUM);//put "one" in this bit in DDR to make it output pin
    152c:	a1 e3       	ldi	r26, 0x31	; 49
    152e:	b0 e0       	ldi	r27, 0x00	; 0
    1530:	e1 e3       	ldi	r30, 0x31	; 49
    1532:	f0 e0       	ldi	r31, 0x00	; 0
    1534:	80 81       	ld	r24, Z
    1536:	48 2f       	mov	r20, r24
    1538:	8a 81       	ldd	r24, Y+2	; 0x02
    153a:	28 2f       	mov	r18, r24
    153c:	30 e0       	ldi	r19, 0x00	; 0
    153e:	81 e0       	ldi	r24, 0x01	; 1
    1540:	90 e0       	ldi	r25, 0x00	; 0
    1542:	02 2e       	mov	r0, r18
    1544:	02 c0       	rjmp	.+4      	; 0x154a <DIO_setupPinDirection+0x32c>
    1546:	88 0f       	add	r24, r24
    1548:	99 1f       	adc	r25, r25
    154a:	0a 94       	dec	r0
    154c:	e2 f7       	brpl	.-8      	; 0x1546 <DIO_setupPinDirection+0x328>
    154e:	84 2b       	or	r24, r20
    1550:	8c 93       	st	X, r24
				}
				break;
		}
		
	}
}
    1552:	0f 90       	pop	r0
    1554:	0f 90       	pop	r0
    1556:	0f 90       	pop	r0
    1558:	0f 90       	pop	r0
    155a:	0f 90       	pop	r0
    155c:	cf 91       	pop	r28
    155e:	df 91       	pop	r29
    1560:	08 95       	ret

00001562 <DIO_writePin>:


void DIO_writePin(uint8_t PORT_X ,uint8_t PIN_NUM,uint8_t value )
{
    1562:	df 93       	push	r29
    1564:	cf 93       	push	r28
    1566:	00 d0       	rcall	.+0      	; 0x1568 <DIO_writePin+0x6>
    1568:	00 d0       	rcall	.+0      	; 0x156a <DIO_writePin+0x8>
    156a:	0f 92       	push	r0
    156c:	cd b7       	in	r28, 0x3d	; 61
    156e:	de b7       	in	r29, 0x3e	; 62
    1570:	89 83       	std	Y+1, r24	; 0x01
    1572:	6a 83       	std	Y+2, r22	; 0x02
    1574:	4b 83       	std	Y+3, r20	; 0x03
	if( (PIN_NUM >= NUM_OF_PIN_PER_PORT) || (PORT_X >= NUM_OF_PORT) )
    1576:	8a 81       	ldd	r24, Y+2	; 0x02
    1578:	88 30       	cpi	r24, 0x08	; 8
    157a:	08 f0       	brcs	.+2      	; 0x157e <DIO_writePin+0x1c>
    157c:	34 c1       	rjmp	.+616    	; 0x17e6 <DIO_writePin+0x284>
    157e:	89 81       	ldd	r24, Y+1	; 0x01
    1580:	84 30       	cpi	r24, 0x04	; 4
    1582:	08 f0       	brcs	.+2      	; 0x1586 <DIO_writePin+0x24>
    1584:	30 c1       	rjmp	.+608    	; 0x17e6 <DIO_writePin+0x284>
		//Error handling ,Nothing to do
	}
	
	else
	{
		switch(PORT_X)
    1586:	89 81       	ldd	r24, Y+1	; 0x01
    1588:	28 2f       	mov	r18, r24
    158a:	30 e0       	ldi	r19, 0x00	; 0
    158c:	3d 83       	std	Y+5, r19	; 0x05
    158e:	2c 83       	std	Y+4, r18	; 0x04
    1590:	4c 81       	ldd	r20, Y+4	; 0x04
    1592:	5d 81       	ldd	r21, Y+5	; 0x05
    1594:	41 30       	cpi	r20, 0x01	; 1
    1596:	51 05       	cpc	r21, r1
    1598:	09 f4       	brne	.+2      	; 0x159c <DIO_writePin+0x3a>
    159a:	5c c0       	rjmp	.+184    	; 0x1654 <DIO_writePin+0xf2>
    159c:	8c 81       	ldd	r24, Y+4	; 0x04
    159e:	9d 81       	ldd	r25, Y+5	; 0x05
    15a0:	82 30       	cpi	r24, 0x02	; 2
    15a2:	91 05       	cpc	r25, r1
    15a4:	34 f4       	brge	.+12     	; 0x15b2 <DIO_writePin+0x50>
    15a6:	2c 81       	ldd	r18, Y+4	; 0x04
    15a8:	3d 81       	ldd	r19, Y+5	; 0x05
    15aa:	21 15       	cp	r18, r1
    15ac:	31 05       	cpc	r19, r1
    15ae:	71 f0       	breq	.+28     	; 0x15cc <DIO_writePin+0x6a>
    15b0:	1a c1       	rjmp	.+564    	; 0x17e6 <DIO_writePin+0x284>
    15b2:	4c 81       	ldd	r20, Y+4	; 0x04
    15b4:	5d 81       	ldd	r21, Y+5	; 0x05
    15b6:	42 30       	cpi	r20, 0x02	; 2
    15b8:	51 05       	cpc	r21, r1
    15ba:	09 f4       	brne	.+2      	; 0x15be <DIO_writePin+0x5c>
    15bc:	8f c0       	rjmp	.+286    	; 0x16dc <DIO_writePin+0x17a>
    15be:	8c 81       	ldd	r24, Y+4	; 0x04
    15c0:	9d 81       	ldd	r25, Y+5	; 0x05
    15c2:	83 30       	cpi	r24, 0x03	; 3
    15c4:	91 05       	cpc	r25, r1
    15c6:	09 f4       	brne	.+2      	; 0x15ca <DIO_writePin+0x68>
    15c8:	cd c0       	rjmp	.+410    	; 0x1764 <DIO_writePin+0x202>
    15ca:	0d c1       	rjmp	.+538    	; 0x17e6 <DIO_writePin+0x284>
		{
			case PORTA_ID:
				if(BIT_IS_SET(DDRA,PIN_NUM))//check if this pin is output pin ,as if output will set or clear else will do nothing
    15cc:	ea e3       	ldi	r30, 0x3A	; 58
    15ce:	f0 e0       	ldi	r31, 0x00	; 0
    15d0:	80 81       	ld	r24, Z
    15d2:	28 2f       	mov	r18, r24
    15d4:	30 e0       	ldi	r19, 0x00	; 0
    15d6:	8a 81       	ldd	r24, Y+2	; 0x02
    15d8:	88 2f       	mov	r24, r24
    15da:	90 e0       	ldi	r25, 0x00	; 0
    15dc:	a9 01       	movw	r20, r18
    15de:	02 c0       	rjmp	.+4      	; 0x15e4 <DIO_writePin+0x82>
    15e0:	55 95       	asr	r21
    15e2:	47 95       	ror	r20
    15e4:	8a 95       	dec	r24
    15e6:	e2 f7       	brpl	.-8      	; 0x15e0 <DIO_writePin+0x7e>
    15e8:	ca 01       	movw	r24, r20
    15ea:	81 70       	andi	r24, 0x01	; 1
    15ec:	90 70       	andi	r25, 0x00	; 0
    15ee:	88 23       	and	r24, r24
    15f0:	09 f4       	brne	.+2      	; 0x15f4 <DIO_writePin+0x92>
    15f2:	f9 c0       	rjmp	.+498    	; 0x17e6 <DIO_writePin+0x284>
				{
					if( value == LOGIC_HIGH)
    15f4:	8b 81       	ldd	r24, Y+3	; 0x03
    15f6:	81 30       	cpi	r24, 0x01	; 1
    15f8:	a1 f4       	brne	.+40     	; 0x1622 <DIO_writePin+0xc0>
						SET_BIT(PORTA,PIN_NUM);//write 1 in bit
    15fa:	ab e3       	ldi	r26, 0x3B	; 59
    15fc:	b0 e0       	ldi	r27, 0x00	; 0
    15fe:	eb e3       	ldi	r30, 0x3B	; 59
    1600:	f0 e0       	ldi	r31, 0x00	; 0
    1602:	80 81       	ld	r24, Z
    1604:	48 2f       	mov	r20, r24
    1606:	8a 81       	ldd	r24, Y+2	; 0x02
    1608:	28 2f       	mov	r18, r24
    160a:	30 e0       	ldi	r19, 0x00	; 0
    160c:	81 e0       	ldi	r24, 0x01	; 1
    160e:	90 e0       	ldi	r25, 0x00	; 0
    1610:	02 2e       	mov	r0, r18
    1612:	02 c0       	rjmp	.+4      	; 0x1618 <DIO_writePin+0xb6>
    1614:	88 0f       	add	r24, r24
    1616:	99 1f       	adc	r25, r25
    1618:	0a 94       	dec	r0
    161a:	e2 f7       	brpl	.-8      	; 0x1614 <DIO_writePin+0xb2>
    161c:	84 2b       	or	r24, r20
    161e:	8c 93       	st	X, r24
    1620:	e2 c0       	rjmp	.+452    	; 0x17e6 <DIO_writePin+0x284>
					else if(value == LOGIC_LOW)
    1622:	8b 81       	ldd	r24, Y+3	; 0x03
    1624:	88 23       	and	r24, r24
    1626:	09 f0       	breq	.+2      	; 0x162a <DIO_writePin+0xc8>
    1628:	de c0       	rjmp	.+444    	; 0x17e6 <DIO_writePin+0x284>
						CLEAR_BIT(PORTA,PIN_NUM);//write 0 in bit
    162a:	ab e3       	ldi	r26, 0x3B	; 59
    162c:	b0 e0       	ldi	r27, 0x00	; 0
    162e:	eb e3       	ldi	r30, 0x3B	; 59
    1630:	f0 e0       	ldi	r31, 0x00	; 0
    1632:	80 81       	ld	r24, Z
    1634:	48 2f       	mov	r20, r24
    1636:	8a 81       	ldd	r24, Y+2	; 0x02
    1638:	28 2f       	mov	r18, r24
    163a:	30 e0       	ldi	r19, 0x00	; 0
    163c:	81 e0       	ldi	r24, 0x01	; 1
    163e:	90 e0       	ldi	r25, 0x00	; 0
    1640:	02 2e       	mov	r0, r18
    1642:	02 c0       	rjmp	.+4      	; 0x1648 <DIO_writePin+0xe6>
    1644:	88 0f       	add	r24, r24
    1646:	99 1f       	adc	r25, r25
    1648:	0a 94       	dec	r0
    164a:	e2 f7       	brpl	.-8      	; 0x1644 <DIO_writePin+0xe2>
    164c:	80 95       	com	r24
    164e:	84 23       	and	r24, r20
    1650:	8c 93       	st	X, r24
    1652:	c9 c0       	rjmp	.+402    	; 0x17e6 <DIO_writePin+0x284>
						//nothing to do
					}
				}
				break;
			case PORTB_ID:
				if(BIT_IS_SET(DDRB,PIN_NUM))//check if this pin is output pin ,as if output will set or clear else will do nothing
    1654:	e7 e3       	ldi	r30, 0x37	; 55
    1656:	f0 e0       	ldi	r31, 0x00	; 0
    1658:	80 81       	ld	r24, Z
    165a:	28 2f       	mov	r18, r24
    165c:	30 e0       	ldi	r19, 0x00	; 0
    165e:	8a 81       	ldd	r24, Y+2	; 0x02
    1660:	88 2f       	mov	r24, r24
    1662:	90 e0       	ldi	r25, 0x00	; 0
    1664:	a9 01       	movw	r20, r18
    1666:	02 c0       	rjmp	.+4      	; 0x166c <DIO_writePin+0x10a>
    1668:	55 95       	asr	r21
    166a:	47 95       	ror	r20
    166c:	8a 95       	dec	r24
    166e:	e2 f7       	brpl	.-8      	; 0x1668 <DIO_writePin+0x106>
    1670:	ca 01       	movw	r24, r20
    1672:	81 70       	andi	r24, 0x01	; 1
    1674:	90 70       	andi	r25, 0x00	; 0
    1676:	88 23       	and	r24, r24
    1678:	09 f4       	brne	.+2      	; 0x167c <DIO_writePin+0x11a>
    167a:	b5 c0       	rjmp	.+362    	; 0x17e6 <DIO_writePin+0x284>
				{
					if( value == LOGIC_HIGH)
    167c:	8b 81       	ldd	r24, Y+3	; 0x03
    167e:	81 30       	cpi	r24, 0x01	; 1
    1680:	a1 f4       	brne	.+40     	; 0x16aa <DIO_writePin+0x148>
						SET_BIT(PORTB,PIN_NUM);//write 1 in bit
    1682:	a8 e3       	ldi	r26, 0x38	; 56
    1684:	b0 e0       	ldi	r27, 0x00	; 0
    1686:	e8 e3       	ldi	r30, 0x38	; 56
    1688:	f0 e0       	ldi	r31, 0x00	; 0
    168a:	80 81       	ld	r24, Z
    168c:	48 2f       	mov	r20, r24
    168e:	8a 81       	ldd	r24, Y+2	; 0x02
    1690:	28 2f       	mov	r18, r24
    1692:	30 e0       	ldi	r19, 0x00	; 0
    1694:	81 e0       	ldi	r24, 0x01	; 1
    1696:	90 e0       	ldi	r25, 0x00	; 0
    1698:	02 2e       	mov	r0, r18
    169a:	02 c0       	rjmp	.+4      	; 0x16a0 <DIO_writePin+0x13e>
    169c:	88 0f       	add	r24, r24
    169e:	99 1f       	adc	r25, r25
    16a0:	0a 94       	dec	r0
    16a2:	e2 f7       	brpl	.-8      	; 0x169c <DIO_writePin+0x13a>
    16a4:	84 2b       	or	r24, r20
    16a6:	8c 93       	st	X, r24
    16a8:	9e c0       	rjmp	.+316    	; 0x17e6 <DIO_writePin+0x284>
					else if(value == LOGIC_LOW)
    16aa:	8b 81       	ldd	r24, Y+3	; 0x03
    16ac:	88 23       	and	r24, r24
    16ae:	09 f0       	breq	.+2      	; 0x16b2 <DIO_writePin+0x150>
    16b0:	9a c0       	rjmp	.+308    	; 0x17e6 <DIO_writePin+0x284>
						CLEAR_BIT(PORTB,PIN_NUM);//write 0 in bit
    16b2:	a8 e3       	ldi	r26, 0x38	; 56
    16b4:	b0 e0       	ldi	r27, 0x00	; 0
    16b6:	e8 e3       	ldi	r30, 0x38	; 56
    16b8:	f0 e0       	ldi	r31, 0x00	; 0
    16ba:	80 81       	ld	r24, Z
    16bc:	48 2f       	mov	r20, r24
    16be:	8a 81       	ldd	r24, Y+2	; 0x02
    16c0:	28 2f       	mov	r18, r24
    16c2:	30 e0       	ldi	r19, 0x00	; 0
    16c4:	81 e0       	ldi	r24, 0x01	; 1
    16c6:	90 e0       	ldi	r25, 0x00	; 0
    16c8:	02 2e       	mov	r0, r18
    16ca:	02 c0       	rjmp	.+4      	; 0x16d0 <DIO_writePin+0x16e>
    16cc:	88 0f       	add	r24, r24
    16ce:	99 1f       	adc	r25, r25
    16d0:	0a 94       	dec	r0
    16d2:	e2 f7       	brpl	.-8      	; 0x16cc <DIO_writePin+0x16a>
    16d4:	80 95       	com	r24
    16d6:	84 23       	and	r24, r20
    16d8:	8c 93       	st	X, r24
    16da:	85 c0       	rjmp	.+266    	; 0x17e6 <DIO_writePin+0x284>
						//nothing to do
					}
				}
				break;
			case PORTC_ID:
				if(BIT_IS_SET(DDRC,PIN_NUM))//check if this pin is output pin ,as if output will set or clear else will do nothing
    16dc:	e4 e3       	ldi	r30, 0x34	; 52
    16de:	f0 e0       	ldi	r31, 0x00	; 0
    16e0:	80 81       	ld	r24, Z
    16e2:	28 2f       	mov	r18, r24
    16e4:	30 e0       	ldi	r19, 0x00	; 0
    16e6:	8a 81       	ldd	r24, Y+2	; 0x02
    16e8:	88 2f       	mov	r24, r24
    16ea:	90 e0       	ldi	r25, 0x00	; 0
    16ec:	a9 01       	movw	r20, r18
    16ee:	02 c0       	rjmp	.+4      	; 0x16f4 <DIO_writePin+0x192>
    16f0:	55 95       	asr	r21
    16f2:	47 95       	ror	r20
    16f4:	8a 95       	dec	r24
    16f6:	e2 f7       	brpl	.-8      	; 0x16f0 <DIO_writePin+0x18e>
    16f8:	ca 01       	movw	r24, r20
    16fa:	81 70       	andi	r24, 0x01	; 1
    16fc:	90 70       	andi	r25, 0x00	; 0
    16fe:	88 23       	and	r24, r24
    1700:	09 f4       	brne	.+2      	; 0x1704 <DIO_writePin+0x1a2>
    1702:	71 c0       	rjmp	.+226    	; 0x17e6 <DIO_writePin+0x284>
				{
					if( value == LOGIC_HIGH)
    1704:	8b 81       	ldd	r24, Y+3	; 0x03
    1706:	81 30       	cpi	r24, 0x01	; 1
    1708:	a1 f4       	brne	.+40     	; 0x1732 <DIO_writePin+0x1d0>
						SET_BIT(PORTC,PIN_NUM);//write 1 in bit
    170a:	a5 e3       	ldi	r26, 0x35	; 53
    170c:	b0 e0       	ldi	r27, 0x00	; 0
    170e:	e5 e3       	ldi	r30, 0x35	; 53
    1710:	f0 e0       	ldi	r31, 0x00	; 0
    1712:	80 81       	ld	r24, Z
    1714:	48 2f       	mov	r20, r24
    1716:	8a 81       	ldd	r24, Y+2	; 0x02
    1718:	28 2f       	mov	r18, r24
    171a:	30 e0       	ldi	r19, 0x00	; 0
    171c:	81 e0       	ldi	r24, 0x01	; 1
    171e:	90 e0       	ldi	r25, 0x00	; 0
    1720:	02 2e       	mov	r0, r18
    1722:	02 c0       	rjmp	.+4      	; 0x1728 <DIO_writePin+0x1c6>
    1724:	88 0f       	add	r24, r24
    1726:	99 1f       	adc	r25, r25
    1728:	0a 94       	dec	r0
    172a:	e2 f7       	brpl	.-8      	; 0x1724 <DIO_writePin+0x1c2>
    172c:	84 2b       	or	r24, r20
    172e:	8c 93       	st	X, r24
    1730:	5a c0       	rjmp	.+180    	; 0x17e6 <DIO_writePin+0x284>
					else if(value == LOGIC_LOW)
    1732:	8b 81       	ldd	r24, Y+3	; 0x03
    1734:	88 23       	and	r24, r24
    1736:	09 f0       	breq	.+2      	; 0x173a <DIO_writePin+0x1d8>
    1738:	56 c0       	rjmp	.+172    	; 0x17e6 <DIO_writePin+0x284>
						CLEAR_BIT(PORTC,PIN_NUM);//write 0 in bit
    173a:	a5 e3       	ldi	r26, 0x35	; 53
    173c:	b0 e0       	ldi	r27, 0x00	; 0
    173e:	e5 e3       	ldi	r30, 0x35	; 53
    1740:	f0 e0       	ldi	r31, 0x00	; 0
    1742:	80 81       	ld	r24, Z
    1744:	48 2f       	mov	r20, r24
    1746:	8a 81       	ldd	r24, Y+2	; 0x02
    1748:	28 2f       	mov	r18, r24
    174a:	30 e0       	ldi	r19, 0x00	; 0
    174c:	81 e0       	ldi	r24, 0x01	; 1
    174e:	90 e0       	ldi	r25, 0x00	; 0
    1750:	02 2e       	mov	r0, r18
    1752:	02 c0       	rjmp	.+4      	; 0x1758 <DIO_writePin+0x1f6>
    1754:	88 0f       	add	r24, r24
    1756:	99 1f       	adc	r25, r25
    1758:	0a 94       	dec	r0
    175a:	e2 f7       	brpl	.-8      	; 0x1754 <DIO_writePin+0x1f2>
    175c:	80 95       	com	r24
    175e:	84 23       	and	r24, r20
    1760:	8c 93       	st	X, r24
    1762:	41 c0       	rjmp	.+130    	; 0x17e6 <DIO_writePin+0x284>
						//nothing to do
					}
				}
				break;
			case PORTD_ID:
				if(BIT_IS_SET(DDRD,PIN_NUM))//check if this pin is output pin ,as if output will set or clear else will do nothing
    1764:	e1 e3       	ldi	r30, 0x31	; 49
    1766:	f0 e0       	ldi	r31, 0x00	; 0
    1768:	80 81       	ld	r24, Z
    176a:	28 2f       	mov	r18, r24
    176c:	30 e0       	ldi	r19, 0x00	; 0
    176e:	8a 81       	ldd	r24, Y+2	; 0x02
    1770:	88 2f       	mov	r24, r24
    1772:	90 e0       	ldi	r25, 0x00	; 0
    1774:	a9 01       	movw	r20, r18
    1776:	02 c0       	rjmp	.+4      	; 0x177c <DIO_writePin+0x21a>
    1778:	55 95       	asr	r21
    177a:	47 95       	ror	r20
    177c:	8a 95       	dec	r24
    177e:	e2 f7       	brpl	.-8      	; 0x1778 <DIO_writePin+0x216>
    1780:	ca 01       	movw	r24, r20
    1782:	81 70       	andi	r24, 0x01	; 1
    1784:	90 70       	andi	r25, 0x00	; 0
    1786:	88 23       	and	r24, r24
    1788:	71 f1       	breq	.+92     	; 0x17e6 <DIO_writePin+0x284>
				{
					if( value == LOGIC_HIGH)
    178a:	8b 81       	ldd	r24, Y+3	; 0x03
    178c:	81 30       	cpi	r24, 0x01	; 1
    178e:	a1 f4       	brne	.+40     	; 0x17b8 <DIO_writePin+0x256>
						SET_BIT(PORTD,PIN_NUM);//write 1 in bit
    1790:	a2 e3       	ldi	r26, 0x32	; 50
    1792:	b0 e0       	ldi	r27, 0x00	; 0
    1794:	e2 e3       	ldi	r30, 0x32	; 50
    1796:	f0 e0       	ldi	r31, 0x00	; 0
    1798:	80 81       	ld	r24, Z
    179a:	48 2f       	mov	r20, r24
    179c:	8a 81       	ldd	r24, Y+2	; 0x02
    179e:	28 2f       	mov	r18, r24
    17a0:	30 e0       	ldi	r19, 0x00	; 0
    17a2:	81 e0       	ldi	r24, 0x01	; 1
    17a4:	90 e0       	ldi	r25, 0x00	; 0
    17a6:	02 2e       	mov	r0, r18
    17a8:	02 c0       	rjmp	.+4      	; 0x17ae <DIO_writePin+0x24c>
    17aa:	88 0f       	add	r24, r24
    17ac:	99 1f       	adc	r25, r25
    17ae:	0a 94       	dec	r0
    17b0:	e2 f7       	brpl	.-8      	; 0x17aa <DIO_writePin+0x248>
    17b2:	84 2b       	or	r24, r20
    17b4:	8c 93       	st	X, r24
    17b6:	17 c0       	rjmp	.+46     	; 0x17e6 <DIO_writePin+0x284>
					else if(value == LOGIC_LOW)
    17b8:	8b 81       	ldd	r24, Y+3	; 0x03
    17ba:	88 23       	and	r24, r24
    17bc:	a1 f4       	brne	.+40     	; 0x17e6 <DIO_writePin+0x284>
						CLEAR_BIT(PORTD,PIN_NUM);//write 0 in bit
    17be:	a2 e3       	ldi	r26, 0x32	; 50
    17c0:	b0 e0       	ldi	r27, 0x00	; 0
    17c2:	e2 e3       	ldi	r30, 0x32	; 50
    17c4:	f0 e0       	ldi	r31, 0x00	; 0
    17c6:	80 81       	ld	r24, Z
    17c8:	48 2f       	mov	r20, r24
    17ca:	8a 81       	ldd	r24, Y+2	; 0x02
    17cc:	28 2f       	mov	r18, r24
    17ce:	30 e0       	ldi	r19, 0x00	; 0
    17d0:	81 e0       	ldi	r24, 0x01	; 1
    17d2:	90 e0       	ldi	r25, 0x00	; 0
    17d4:	02 2e       	mov	r0, r18
    17d6:	02 c0       	rjmp	.+4      	; 0x17dc <DIO_writePin+0x27a>
    17d8:	88 0f       	add	r24, r24
    17da:	99 1f       	adc	r25, r25
    17dc:	0a 94       	dec	r0
    17de:	e2 f7       	brpl	.-8      	; 0x17d8 <DIO_writePin+0x276>
    17e0:	80 95       	com	r24
    17e2:	84 23       	and	r24, r20
    17e4:	8c 93       	st	X, r24
				}
				break;
			
		}
	}
}
    17e6:	0f 90       	pop	r0
    17e8:	0f 90       	pop	r0
    17ea:	0f 90       	pop	r0
    17ec:	0f 90       	pop	r0
    17ee:	0f 90       	pop	r0
    17f0:	cf 91       	pop	r28
    17f2:	df 91       	pop	r29
    17f4:	08 95       	ret

000017f6 <DIO_readPin>:


uint8_t DIO_readPin(uint8_t PORT_X ,uint8_t PIN_NUM)
{
    17f6:	df 93       	push	r29
    17f8:	cf 93       	push	r28
    17fa:	00 d0       	rcall	.+0      	; 0x17fc <DIO_readPin+0x6>
    17fc:	00 d0       	rcall	.+0      	; 0x17fe <DIO_readPin+0x8>
    17fe:	0f 92       	push	r0
    1800:	cd b7       	in	r28, 0x3d	; 61
    1802:	de b7       	in	r29, 0x3e	; 62
    1804:	8a 83       	std	Y+2, r24	; 0x02
    1806:	6b 83       	std	Y+3, r22	; 0x03
	uint8_t return_value = LOGIC_LOW;
    1808:	19 82       	std	Y+1, r1	; 0x01
	if( (PIN_NUM >= NUM_OF_PIN_PER_PORT) || (PORT_X >= NUM_OF_PORT) )
    180a:	8b 81       	ldd	r24, Y+3	; 0x03
    180c:	88 30       	cpi	r24, 0x08	; 8
    180e:	08 f0       	brcs	.+2      	; 0x1812 <DIO_readPin+0x1c>
    1810:	84 c0       	rjmp	.+264    	; 0x191a <DIO_readPin+0x124>
    1812:	8a 81       	ldd	r24, Y+2	; 0x02
    1814:	84 30       	cpi	r24, 0x04	; 4
    1816:	08 f0       	brcs	.+2      	; 0x181a <DIO_readPin+0x24>
    1818:	80 c0       	rjmp	.+256    	; 0x191a <DIO_readPin+0x124>
	{
		//Error handling ,Nothing to do
	}
	else
	{
		switch(PORT_X)
    181a:	8a 81       	ldd	r24, Y+2	; 0x02
    181c:	28 2f       	mov	r18, r24
    181e:	30 e0       	ldi	r19, 0x00	; 0
    1820:	3d 83       	std	Y+5, r19	; 0x05
    1822:	2c 83       	std	Y+4, r18	; 0x04
    1824:	4c 81       	ldd	r20, Y+4	; 0x04
    1826:	5d 81       	ldd	r21, Y+5	; 0x05
    1828:	41 30       	cpi	r20, 0x01	; 1
    182a:	51 05       	cpc	r21, r1
    182c:	79 f1       	breq	.+94     	; 0x188c <DIO_readPin+0x96>
    182e:	8c 81       	ldd	r24, Y+4	; 0x04
    1830:	9d 81       	ldd	r25, Y+5	; 0x05
    1832:	82 30       	cpi	r24, 0x02	; 2
    1834:	91 05       	cpc	r25, r1
    1836:	34 f4       	brge	.+12     	; 0x1844 <DIO_readPin+0x4e>
    1838:	2c 81       	ldd	r18, Y+4	; 0x04
    183a:	3d 81       	ldd	r19, Y+5	; 0x05
    183c:	21 15       	cp	r18, r1
    183e:	31 05       	cpc	r19, r1
    1840:	69 f0       	breq	.+26     	; 0x185c <DIO_readPin+0x66>
    1842:	6b c0       	rjmp	.+214    	; 0x191a <DIO_readPin+0x124>
    1844:	4c 81       	ldd	r20, Y+4	; 0x04
    1846:	5d 81       	ldd	r21, Y+5	; 0x05
    1848:	42 30       	cpi	r20, 0x02	; 2
    184a:	51 05       	cpc	r21, r1
    184c:	b9 f1       	breq	.+110    	; 0x18bc <DIO_readPin+0xc6>
    184e:	8c 81       	ldd	r24, Y+4	; 0x04
    1850:	9d 81       	ldd	r25, Y+5	; 0x05
    1852:	83 30       	cpi	r24, 0x03	; 3
    1854:	91 05       	cpc	r25, r1
    1856:	09 f4       	brne	.+2      	; 0x185a <DIO_readPin+0x64>
    1858:	49 c0       	rjmp	.+146    	; 0x18ec <DIO_readPin+0xf6>
    185a:	5f c0       	rjmp	.+190    	; 0x191a <DIO_readPin+0x124>
		{
			case PORTA_ID:
				if(BIT_IS_SET(PINA,PIN_NUM))//mean bit contain logic high
    185c:	e9 e3       	ldi	r30, 0x39	; 57
    185e:	f0 e0       	ldi	r31, 0x00	; 0
    1860:	80 81       	ld	r24, Z
    1862:	28 2f       	mov	r18, r24
    1864:	30 e0       	ldi	r19, 0x00	; 0
    1866:	8b 81       	ldd	r24, Y+3	; 0x03
    1868:	88 2f       	mov	r24, r24
    186a:	90 e0       	ldi	r25, 0x00	; 0
    186c:	a9 01       	movw	r20, r18
    186e:	02 c0       	rjmp	.+4      	; 0x1874 <DIO_readPin+0x7e>
    1870:	55 95       	asr	r21
    1872:	47 95       	ror	r20
    1874:	8a 95       	dec	r24
    1876:	e2 f7       	brpl	.-8      	; 0x1870 <DIO_readPin+0x7a>
    1878:	ca 01       	movw	r24, r20
    187a:	81 70       	andi	r24, 0x01	; 1
    187c:	90 70       	andi	r25, 0x00	; 0
    187e:	88 23       	and	r24, r24
    1880:	19 f0       	breq	.+6      	; 0x1888 <DIO_readPin+0x92>
					return_value = LOGIC_HIGH; // return logic high
    1882:	81 e0       	ldi	r24, 0x01	; 1
    1884:	89 83       	std	Y+1, r24	; 0x01
    1886:	49 c0       	rjmp	.+146    	; 0x191a <DIO_readPin+0x124>
				else //mean bit contain logic low
					return_value = LOGIC_LOW;
    1888:	19 82       	std	Y+1, r1	; 0x01
    188a:	47 c0       	rjmp	.+142    	; 0x191a <DIO_readPin+0x124>
				break;
			case PORTB_ID :
				if(BIT_IS_SET(PINB,PIN_NUM))//mean bit contain logic high
    188c:	e6 e3       	ldi	r30, 0x36	; 54
    188e:	f0 e0       	ldi	r31, 0x00	; 0
    1890:	80 81       	ld	r24, Z
    1892:	28 2f       	mov	r18, r24
    1894:	30 e0       	ldi	r19, 0x00	; 0
    1896:	8b 81       	ldd	r24, Y+3	; 0x03
    1898:	88 2f       	mov	r24, r24
    189a:	90 e0       	ldi	r25, 0x00	; 0
    189c:	a9 01       	movw	r20, r18
    189e:	02 c0       	rjmp	.+4      	; 0x18a4 <DIO_readPin+0xae>
    18a0:	55 95       	asr	r21
    18a2:	47 95       	ror	r20
    18a4:	8a 95       	dec	r24
    18a6:	e2 f7       	brpl	.-8      	; 0x18a0 <DIO_readPin+0xaa>
    18a8:	ca 01       	movw	r24, r20
    18aa:	81 70       	andi	r24, 0x01	; 1
    18ac:	90 70       	andi	r25, 0x00	; 0
    18ae:	88 23       	and	r24, r24
    18b0:	19 f0       	breq	.+6      	; 0x18b8 <DIO_readPin+0xc2>
					return_value = LOGIC_HIGH; // return logic high
    18b2:	81 e0       	ldi	r24, 0x01	; 1
    18b4:	89 83       	std	Y+1, r24	; 0x01
    18b6:	31 c0       	rjmp	.+98     	; 0x191a <DIO_readPin+0x124>
				else //mean bit contain logic low
					return_value = LOGIC_LOW;
    18b8:	19 82       	std	Y+1, r1	; 0x01
    18ba:	2f c0       	rjmp	.+94     	; 0x191a <DIO_readPin+0x124>
				break;
			case PORTC_ID :
				if(BIT_IS_SET(PINC,PIN_NUM))//mean bit contain logic high
    18bc:	e3 e3       	ldi	r30, 0x33	; 51
    18be:	f0 e0       	ldi	r31, 0x00	; 0
    18c0:	80 81       	ld	r24, Z
    18c2:	28 2f       	mov	r18, r24
    18c4:	30 e0       	ldi	r19, 0x00	; 0
    18c6:	8b 81       	ldd	r24, Y+3	; 0x03
    18c8:	88 2f       	mov	r24, r24
    18ca:	90 e0       	ldi	r25, 0x00	; 0
    18cc:	a9 01       	movw	r20, r18
    18ce:	02 c0       	rjmp	.+4      	; 0x18d4 <DIO_readPin+0xde>
    18d0:	55 95       	asr	r21
    18d2:	47 95       	ror	r20
    18d4:	8a 95       	dec	r24
    18d6:	e2 f7       	brpl	.-8      	; 0x18d0 <DIO_readPin+0xda>
    18d8:	ca 01       	movw	r24, r20
    18da:	81 70       	andi	r24, 0x01	; 1
    18dc:	90 70       	andi	r25, 0x00	; 0
    18de:	88 23       	and	r24, r24
    18e0:	19 f0       	breq	.+6      	; 0x18e8 <DIO_readPin+0xf2>
					return_value = LOGIC_HIGH; // return logic high
    18e2:	81 e0       	ldi	r24, 0x01	; 1
    18e4:	89 83       	std	Y+1, r24	; 0x01
    18e6:	19 c0       	rjmp	.+50     	; 0x191a <DIO_readPin+0x124>
				else //mean bit contain logic low
					return_value = LOGIC_LOW;
    18e8:	19 82       	std	Y+1, r1	; 0x01
    18ea:	17 c0       	rjmp	.+46     	; 0x191a <DIO_readPin+0x124>
				break;
			case PORTD_ID :
				if(BIT_IS_SET(PIND,PIN_NUM))//mean bit contain logic high
    18ec:	e0 e3       	ldi	r30, 0x30	; 48
    18ee:	f0 e0       	ldi	r31, 0x00	; 0
    18f0:	80 81       	ld	r24, Z
    18f2:	28 2f       	mov	r18, r24
    18f4:	30 e0       	ldi	r19, 0x00	; 0
    18f6:	8b 81       	ldd	r24, Y+3	; 0x03
    18f8:	88 2f       	mov	r24, r24
    18fa:	90 e0       	ldi	r25, 0x00	; 0
    18fc:	a9 01       	movw	r20, r18
    18fe:	02 c0       	rjmp	.+4      	; 0x1904 <DIO_readPin+0x10e>
    1900:	55 95       	asr	r21
    1902:	47 95       	ror	r20
    1904:	8a 95       	dec	r24
    1906:	e2 f7       	brpl	.-8      	; 0x1900 <DIO_readPin+0x10a>
    1908:	ca 01       	movw	r24, r20
    190a:	81 70       	andi	r24, 0x01	; 1
    190c:	90 70       	andi	r25, 0x00	; 0
    190e:	88 23       	and	r24, r24
    1910:	19 f0       	breq	.+6      	; 0x1918 <DIO_readPin+0x122>
					return_value = LOGIC_HIGH; // return logic high
    1912:	81 e0       	ldi	r24, 0x01	; 1
    1914:	89 83       	std	Y+1, r24	; 0x01
    1916:	01 c0       	rjmp	.+2      	; 0x191a <DIO_readPin+0x124>
				else //mean bit contain logic low
					return_value = LOGIC_LOW;
    1918:	19 82       	std	Y+1, r1	; 0x01
				break;
			
		}
	}
	return return_value;
    191a:	89 81       	ldd	r24, Y+1	; 0x01
}
    191c:	0f 90       	pop	r0
    191e:	0f 90       	pop	r0
    1920:	0f 90       	pop	r0
    1922:	0f 90       	pop	r0
    1924:	0f 90       	pop	r0
    1926:	cf 91       	pop	r28
    1928:	df 91       	pop	r29
    192a:	08 95       	ret

0000192c <DIO_togglePin>:

void DIO_togglePin(uint8_t PORT_X ,uint8_t PIN_NUM)
{
    192c:	df 93       	push	r29
    192e:	cf 93       	push	r28
    1930:	00 d0       	rcall	.+0      	; 0x1932 <DIO_togglePin+0x6>
    1932:	00 d0       	rcall	.+0      	; 0x1934 <DIO_togglePin+0x8>
    1934:	cd b7       	in	r28, 0x3d	; 61
    1936:	de b7       	in	r29, 0x3e	; 62
    1938:	89 83       	std	Y+1, r24	; 0x01
    193a:	6a 83       	std	Y+2, r22	; 0x02
	if( (PIN_NUM >= NUM_OF_PIN_PER_PORT) || (PORT_X >= NUM_OF_PORT) )
    193c:	8a 81       	ldd	r24, Y+2	; 0x02
    193e:	88 30       	cpi	r24, 0x08	; 8
    1940:	08 f0       	brcs	.+2      	; 0x1944 <DIO_togglePin+0x18>
    1942:	c4 c0       	rjmp	.+392    	; 0x1acc <DIO_togglePin+0x1a0>
    1944:	89 81       	ldd	r24, Y+1	; 0x01
    1946:	84 30       	cpi	r24, 0x04	; 4
    1948:	08 f0       	brcs	.+2      	; 0x194c <DIO_togglePin+0x20>
    194a:	c0 c0       	rjmp	.+384    	; 0x1acc <DIO_togglePin+0x1a0>
	{
		//Error handling ,Nothing to do
	}
	else
	{
		switch(PORT_X)
    194c:	89 81       	ldd	r24, Y+1	; 0x01
    194e:	28 2f       	mov	r18, r24
    1950:	30 e0       	ldi	r19, 0x00	; 0
    1952:	3c 83       	std	Y+4, r19	; 0x04
    1954:	2b 83       	std	Y+3, r18	; 0x03
    1956:	4b 81       	ldd	r20, Y+3	; 0x03
    1958:	5c 81       	ldd	r21, Y+4	; 0x04
    195a:	41 30       	cpi	r20, 0x01	; 1
    195c:	51 05       	cpc	r21, r1
    195e:	09 f4       	brne	.+2      	; 0x1962 <DIO_togglePin+0x36>
    1960:	40 c0       	rjmp	.+128    	; 0x19e2 <DIO_togglePin+0xb6>
    1962:	8b 81       	ldd	r24, Y+3	; 0x03
    1964:	9c 81       	ldd	r25, Y+4	; 0x04
    1966:	82 30       	cpi	r24, 0x02	; 2
    1968:	91 05       	cpc	r25, r1
    196a:	34 f4       	brge	.+12     	; 0x1978 <DIO_togglePin+0x4c>
    196c:	2b 81       	ldd	r18, Y+3	; 0x03
    196e:	3c 81       	ldd	r19, Y+4	; 0x04
    1970:	21 15       	cp	r18, r1
    1972:	31 05       	cpc	r19, r1
    1974:	71 f0       	breq	.+28     	; 0x1992 <DIO_togglePin+0x66>
    1976:	aa c0       	rjmp	.+340    	; 0x1acc <DIO_togglePin+0x1a0>
    1978:	4b 81       	ldd	r20, Y+3	; 0x03
    197a:	5c 81       	ldd	r21, Y+4	; 0x04
    197c:	42 30       	cpi	r20, 0x02	; 2
    197e:	51 05       	cpc	r21, r1
    1980:	09 f4       	brne	.+2      	; 0x1984 <DIO_togglePin+0x58>
    1982:	57 c0       	rjmp	.+174    	; 0x1a32 <DIO_togglePin+0x106>
    1984:	8b 81       	ldd	r24, Y+3	; 0x03
    1986:	9c 81       	ldd	r25, Y+4	; 0x04
    1988:	83 30       	cpi	r24, 0x03	; 3
    198a:	91 05       	cpc	r25, r1
    198c:	09 f4       	brne	.+2      	; 0x1990 <DIO_togglePin+0x64>
    198e:	78 c0       	rjmp	.+240    	; 0x1a80 <DIO_togglePin+0x154>
    1990:	9d c0       	rjmp	.+314    	; 0x1acc <DIO_togglePin+0x1a0>
		{
			case PORTA_ID:
				if(BIT_IS_SET(DDRA,PIN_NUM))//check if this pin is output pin ,as if output will toggle else will do nothing
    1992:	ea e3       	ldi	r30, 0x3A	; 58
    1994:	f0 e0       	ldi	r31, 0x00	; 0
    1996:	80 81       	ld	r24, Z
    1998:	28 2f       	mov	r18, r24
    199a:	30 e0       	ldi	r19, 0x00	; 0
    199c:	8a 81       	ldd	r24, Y+2	; 0x02
    199e:	88 2f       	mov	r24, r24
    19a0:	90 e0       	ldi	r25, 0x00	; 0
    19a2:	a9 01       	movw	r20, r18
    19a4:	02 c0       	rjmp	.+4      	; 0x19aa <DIO_togglePin+0x7e>
    19a6:	55 95       	asr	r21
    19a8:	47 95       	ror	r20
    19aa:	8a 95       	dec	r24
    19ac:	e2 f7       	brpl	.-8      	; 0x19a6 <DIO_togglePin+0x7a>
    19ae:	ca 01       	movw	r24, r20
    19b0:	81 70       	andi	r24, 0x01	; 1
    19b2:	90 70       	andi	r25, 0x00	; 0
    19b4:	88 23       	and	r24, r24
    19b6:	09 f4       	brne	.+2      	; 0x19ba <DIO_togglePin+0x8e>
    19b8:	89 c0       	rjmp	.+274    	; 0x1acc <DIO_togglePin+0x1a0>
					TOGGLE_BIT(PORTA,PIN_NUM);
    19ba:	ab e3       	ldi	r26, 0x3B	; 59
    19bc:	b0 e0       	ldi	r27, 0x00	; 0
    19be:	eb e3       	ldi	r30, 0x3B	; 59
    19c0:	f0 e0       	ldi	r31, 0x00	; 0
    19c2:	80 81       	ld	r24, Z
    19c4:	48 2f       	mov	r20, r24
    19c6:	8a 81       	ldd	r24, Y+2	; 0x02
    19c8:	28 2f       	mov	r18, r24
    19ca:	30 e0       	ldi	r19, 0x00	; 0
    19cc:	81 e0       	ldi	r24, 0x01	; 1
    19ce:	90 e0       	ldi	r25, 0x00	; 0
    19d0:	02 2e       	mov	r0, r18
    19d2:	02 c0       	rjmp	.+4      	; 0x19d8 <DIO_togglePin+0xac>
    19d4:	88 0f       	add	r24, r24
    19d6:	99 1f       	adc	r25, r25
    19d8:	0a 94       	dec	r0
    19da:	e2 f7       	brpl	.-8      	; 0x19d4 <DIO_togglePin+0xa8>
    19dc:	84 27       	eor	r24, r20
    19de:	8c 93       	st	X, r24
    19e0:	75 c0       	rjmp	.+234    	; 0x1acc <DIO_togglePin+0x1a0>
				break;
			case PORTB_ID:
				if(BIT_IS_SET(DDRB,PIN_NUM))//check if this pin is output pin ,as if output will toggle else will do nothing
    19e2:	e7 e3       	ldi	r30, 0x37	; 55
    19e4:	f0 e0       	ldi	r31, 0x00	; 0
    19e6:	80 81       	ld	r24, Z
    19e8:	28 2f       	mov	r18, r24
    19ea:	30 e0       	ldi	r19, 0x00	; 0
    19ec:	8a 81       	ldd	r24, Y+2	; 0x02
    19ee:	88 2f       	mov	r24, r24
    19f0:	90 e0       	ldi	r25, 0x00	; 0
    19f2:	a9 01       	movw	r20, r18
    19f4:	02 c0       	rjmp	.+4      	; 0x19fa <DIO_togglePin+0xce>
    19f6:	55 95       	asr	r21
    19f8:	47 95       	ror	r20
    19fa:	8a 95       	dec	r24
    19fc:	e2 f7       	brpl	.-8      	; 0x19f6 <DIO_togglePin+0xca>
    19fe:	ca 01       	movw	r24, r20
    1a00:	81 70       	andi	r24, 0x01	; 1
    1a02:	90 70       	andi	r25, 0x00	; 0
    1a04:	88 23       	and	r24, r24
    1a06:	09 f4       	brne	.+2      	; 0x1a0a <DIO_togglePin+0xde>
    1a08:	61 c0       	rjmp	.+194    	; 0x1acc <DIO_togglePin+0x1a0>
					TOGGLE_BIT(PORTB,PIN_NUM);
    1a0a:	a8 e3       	ldi	r26, 0x38	; 56
    1a0c:	b0 e0       	ldi	r27, 0x00	; 0
    1a0e:	e8 e3       	ldi	r30, 0x38	; 56
    1a10:	f0 e0       	ldi	r31, 0x00	; 0
    1a12:	80 81       	ld	r24, Z
    1a14:	48 2f       	mov	r20, r24
    1a16:	8a 81       	ldd	r24, Y+2	; 0x02
    1a18:	28 2f       	mov	r18, r24
    1a1a:	30 e0       	ldi	r19, 0x00	; 0
    1a1c:	81 e0       	ldi	r24, 0x01	; 1
    1a1e:	90 e0       	ldi	r25, 0x00	; 0
    1a20:	02 2e       	mov	r0, r18
    1a22:	02 c0       	rjmp	.+4      	; 0x1a28 <DIO_togglePin+0xfc>
    1a24:	88 0f       	add	r24, r24
    1a26:	99 1f       	adc	r25, r25
    1a28:	0a 94       	dec	r0
    1a2a:	e2 f7       	brpl	.-8      	; 0x1a24 <DIO_togglePin+0xf8>
    1a2c:	84 27       	eor	r24, r20
    1a2e:	8c 93       	st	X, r24
    1a30:	4d c0       	rjmp	.+154    	; 0x1acc <DIO_togglePin+0x1a0>
				break;
			case PORTC_ID:
				if(BIT_IS_SET(DDRC,PIN_NUM))//check if this pin is output pin ,as if output will toggle else will do nothing
    1a32:	e4 e3       	ldi	r30, 0x34	; 52
    1a34:	f0 e0       	ldi	r31, 0x00	; 0
    1a36:	80 81       	ld	r24, Z
    1a38:	28 2f       	mov	r18, r24
    1a3a:	30 e0       	ldi	r19, 0x00	; 0
    1a3c:	8a 81       	ldd	r24, Y+2	; 0x02
    1a3e:	88 2f       	mov	r24, r24
    1a40:	90 e0       	ldi	r25, 0x00	; 0
    1a42:	a9 01       	movw	r20, r18
    1a44:	02 c0       	rjmp	.+4      	; 0x1a4a <DIO_togglePin+0x11e>
    1a46:	55 95       	asr	r21
    1a48:	47 95       	ror	r20
    1a4a:	8a 95       	dec	r24
    1a4c:	e2 f7       	brpl	.-8      	; 0x1a46 <DIO_togglePin+0x11a>
    1a4e:	ca 01       	movw	r24, r20
    1a50:	81 70       	andi	r24, 0x01	; 1
    1a52:	90 70       	andi	r25, 0x00	; 0
    1a54:	88 23       	and	r24, r24
    1a56:	d1 f1       	breq	.+116    	; 0x1acc <DIO_togglePin+0x1a0>
					TOGGLE_BIT(PORTC,PIN_NUM);
    1a58:	a5 e3       	ldi	r26, 0x35	; 53
    1a5a:	b0 e0       	ldi	r27, 0x00	; 0
    1a5c:	e5 e3       	ldi	r30, 0x35	; 53
    1a5e:	f0 e0       	ldi	r31, 0x00	; 0
    1a60:	80 81       	ld	r24, Z
    1a62:	48 2f       	mov	r20, r24
    1a64:	8a 81       	ldd	r24, Y+2	; 0x02
    1a66:	28 2f       	mov	r18, r24
    1a68:	30 e0       	ldi	r19, 0x00	; 0
    1a6a:	81 e0       	ldi	r24, 0x01	; 1
    1a6c:	90 e0       	ldi	r25, 0x00	; 0
    1a6e:	02 2e       	mov	r0, r18
    1a70:	02 c0       	rjmp	.+4      	; 0x1a76 <DIO_togglePin+0x14a>
    1a72:	88 0f       	add	r24, r24
    1a74:	99 1f       	adc	r25, r25
    1a76:	0a 94       	dec	r0
    1a78:	e2 f7       	brpl	.-8      	; 0x1a72 <DIO_togglePin+0x146>
    1a7a:	84 27       	eor	r24, r20
    1a7c:	8c 93       	st	X, r24
    1a7e:	26 c0       	rjmp	.+76     	; 0x1acc <DIO_togglePin+0x1a0>
				break;
			case PORTD_ID:
				if(BIT_IS_SET(DDRD,PIN_NUM))//check if this pin is output pin ,as if output will toggle else will do nothing
    1a80:	e1 e3       	ldi	r30, 0x31	; 49
    1a82:	f0 e0       	ldi	r31, 0x00	; 0
    1a84:	80 81       	ld	r24, Z
    1a86:	28 2f       	mov	r18, r24
    1a88:	30 e0       	ldi	r19, 0x00	; 0
    1a8a:	8a 81       	ldd	r24, Y+2	; 0x02
    1a8c:	88 2f       	mov	r24, r24
    1a8e:	90 e0       	ldi	r25, 0x00	; 0
    1a90:	a9 01       	movw	r20, r18
    1a92:	02 c0       	rjmp	.+4      	; 0x1a98 <DIO_togglePin+0x16c>
    1a94:	55 95       	asr	r21
    1a96:	47 95       	ror	r20
    1a98:	8a 95       	dec	r24
    1a9a:	e2 f7       	brpl	.-8      	; 0x1a94 <DIO_togglePin+0x168>
    1a9c:	ca 01       	movw	r24, r20
    1a9e:	81 70       	andi	r24, 0x01	; 1
    1aa0:	90 70       	andi	r25, 0x00	; 0
    1aa2:	88 23       	and	r24, r24
    1aa4:	99 f0       	breq	.+38     	; 0x1acc <DIO_togglePin+0x1a0>
					TOGGLE_BIT(PORTD,PIN_NUM);
    1aa6:	a2 e3       	ldi	r26, 0x32	; 50
    1aa8:	b0 e0       	ldi	r27, 0x00	; 0
    1aaa:	e2 e3       	ldi	r30, 0x32	; 50
    1aac:	f0 e0       	ldi	r31, 0x00	; 0
    1aae:	80 81       	ld	r24, Z
    1ab0:	48 2f       	mov	r20, r24
    1ab2:	8a 81       	ldd	r24, Y+2	; 0x02
    1ab4:	28 2f       	mov	r18, r24
    1ab6:	30 e0       	ldi	r19, 0x00	; 0
    1ab8:	81 e0       	ldi	r24, 0x01	; 1
    1aba:	90 e0       	ldi	r25, 0x00	; 0
    1abc:	02 2e       	mov	r0, r18
    1abe:	02 c0       	rjmp	.+4      	; 0x1ac4 <DIO_togglePin+0x198>
    1ac0:	88 0f       	add	r24, r24
    1ac2:	99 1f       	adc	r25, r25
    1ac4:	0a 94       	dec	r0
    1ac6:	e2 f7       	brpl	.-8      	; 0x1ac0 <DIO_togglePin+0x194>
    1ac8:	84 27       	eor	r24, r20
    1aca:	8c 93       	st	X, r24
					break;
		}
	}
}
    1acc:	0f 90       	pop	r0
    1ace:	0f 90       	pop	r0
    1ad0:	0f 90       	pop	r0
    1ad2:	0f 90       	pop	r0
    1ad4:	cf 91       	pop	r28
    1ad6:	df 91       	pop	r29
    1ad8:	08 95       	ret

00001ada <DIO_setupPortDirection>:

void DIO_setupPortDirection(uint8_t PORT_X , GPIO_PortDirectionTypes DIRECTION)
{
    1ada:	df 93       	push	r29
    1adc:	cf 93       	push	r28
    1ade:	00 d0       	rcall	.+0      	; 0x1ae0 <DIO_setupPortDirection+0x6>
    1ae0:	00 d0       	rcall	.+0      	; 0x1ae2 <DIO_setupPortDirection+0x8>
    1ae2:	cd b7       	in	r28, 0x3d	; 61
    1ae4:	de b7       	in	r29, 0x3e	; 62
    1ae6:	89 83       	std	Y+1, r24	; 0x01
    1ae8:	6a 83       	std	Y+2, r22	; 0x02
	if(  (PORT_X >= NUM_OF_PORT) )
    1aea:	89 81       	ldd	r24, Y+1	; 0x01
    1aec:	84 30       	cpi	r24, 0x04	; 4
    1aee:	08 f0       	brcs	.+2      	; 0x1af2 <DIO_setupPortDirection+0x18>
    1af0:	4e c0       	rjmp	.+156    	; 0x1b8e <DIO_setupPortDirection+0xb4>
	{
		//Error handling ,Nothing to do
	}
	else
	{
		switch(PORT_X)
    1af2:	89 81       	ldd	r24, Y+1	; 0x01
    1af4:	28 2f       	mov	r18, r24
    1af6:	30 e0       	ldi	r19, 0x00	; 0
    1af8:	3c 83       	std	Y+4, r19	; 0x04
    1afa:	2b 83       	std	Y+3, r18	; 0x03
    1afc:	8b 81       	ldd	r24, Y+3	; 0x03
    1afe:	9c 81       	ldd	r25, Y+4	; 0x04
    1b00:	81 30       	cpi	r24, 0x01	; 1
    1b02:	91 05       	cpc	r25, r1
    1b04:	09 f1       	breq	.+66     	; 0x1b48 <DIO_setupPortDirection+0x6e>
    1b06:	2b 81       	ldd	r18, Y+3	; 0x03
    1b08:	3c 81       	ldd	r19, Y+4	; 0x04
    1b0a:	22 30       	cpi	r18, 0x02	; 2
    1b0c:	31 05       	cpc	r19, r1
    1b0e:	2c f4       	brge	.+10     	; 0x1b1a <DIO_setupPortDirection+0x40>
    1b10:	8b 81       	ldd	r24, Y+3	; 0x03
    1b12:	9c 81       	ldd	r25, Y+4	; 0x04
    1b14:	00 97       	sbiw	r24, 0x00	; 0
    1b16:	61 f0       	breq	.+24     	; 0x1b30 <DIO_setupPortDirection+0x56>
    1b18:	3a c0       	rjmp	.+116    	; 0x1b8e <DIO_setupPortDirection+0xb4>
    1b1a:	2b 81       	ldd	r18, Y+3	; 0x03
    1b1c:	3c 81       	ldd	r19, Y+4	; 0x04
    1b1e:	22 30       	cpi	r18, 0x02	; 2
    1b20:	31 05       	cpc	r19, r1
    1b22:	f1 f0       	breq	.+60     	; 0x1b60 <DIO_setupPortDirection+0x86>
    1b24:	8b 81       	ldd	r24, Y+3	; 0x03
    1b26:	9c 81       	ldd	r25, Y+4	; 0x04
    1b28:	83 30       	cpi	r24, 0x03	; 3
    1b2a:	91 05       	cpc	r25, r1
    1b2c:	29 f1       	breq	.+74     	; 0x1b78 <DIO_setupPortDirection+0x9e>
    1b2e:	2f c0       	rjmp	.+94     	; 0x1b8e <DIO_setupPortDirection+0xb4>
		{
			case PORTA_ID:
				DDRA = DIRECTION;
    1b30:	ea e3       	ldi	r30, 0x3A	; 58
    1b32:	f0 e0       	ldi	r31, 0x00	; 0
    1b34:	8a 81       	ldd	r24, Y+2	; 0x02
    1b36:	80 83       	st	Z, r24
				if(DIRECTION == INPUT_PORT_PULLUP)
    1b38:	8a 81       	ldd	r24, Y+2	; 0x02
    1b3a:	88 23       	and	r24, r24
    1b3c:	41 f5       	brne	.+80     	; 0x1b8e <DIO_setupPortDirection+0xb4>
					PORTA = 0xFF;
    1b3e:	eb e3       	ldi	r30, 0x3B	; 59
    1b40:	f0 e0       	ldi	r31, 0x00	; 0
    1b42:	8f ef       	ldi	r24, 0xFF	; 255
    1b44:	80 83       	st	Z, r24
    1b46:	23 c0       	rjmp	.+70     	; 0x1b8e <DIO_setupPortDirection+0xb4>
				break;
			case PORTB_ID:
				DDRB = DIRECTION;
    1b48:	e7 e3       	ldi	r30, 0x37	; 55
    1b4a:	f0 e0       	ldi	r31, 0x00	; 0
    1b4c:	8a 81       	ldd	r24, Y+2	; 0x02
    1b4e:	80 83       	st	Z, r24
				if(DIRECTION == INPUT_PORT_PULLUP)
    1b50:	8a 81       	ldd	r24, Y+2	; 0x02
    1b52:	88 23       	and	r24, r24
    1b54:	e1 f4       	brne	.+56     	; 0x1b8e <DIO_setupPortDirection+0xb4>
					PORTB = 0xFF;
    1b56:	e8 e3       	ldi	r30, 0x38	; 56
    1b58:	f0 e0       	ldi	r31, 0x00	; 0
    1b5a:	8f ef       	ldi	r24, 0xFF	; 255
    1b5c:	80 83       	st	Z, r24
    1b5e:	17 c0       	rjmp	.+46     	; 0x1b8e <DIO_setupPortDirection+0xb4>
				break;
			case PORTC_ID:
				DDRC = DIRECTION;
    1b60:	e4 e3       	ldi	r30, 0x34	; 52
    1b62:	f0 e0       	ldi	r31, 0x00	; 0
    1b64:	8a 81       	ldd	r24, Y+2	; 0x02
    1b66:	80 83       	st	Z, r24
				if(DIRECTION == INPUT_PORT_PULLUP)
    1b68:	8a 81       	ldd	r24, Y+2	; 0x02
    1b6a:	88 23       	and	r24, r24
    1b6c:	81 f4       	brne	.+32     	; 0x1b8e <DIO_setupPortDirection+0xb4>
					PORTC = 0xFF;
    1b6e:	e5 e3       	ldi	r30, 0x35	; 53
    1b70:	f0 e0       	ldi	r31, 0x00	; 0
    1b72:	8f ef       	ldi	r24, 0xFF	; 255
    1b74:	80 83       	st	Z, r24
    1b76:	0b c0       	rjmp	.+22     	; 0x1b8e <DIO_setupPortDirection+0xb4>
				break;
			case PORTD_ID:
				DDRD = DIRECTION;
    1b78:	e1 e3       	ldi	r30, 0x31	; 49
    1b7a:	f0 e0       	ldi	r31, 0x00	; 0
    1b7c:	8a 81       	ldd	r24, Y+2	; 0x02
    1b7e:	80 83       	st	Z, r24
				if(DIRECTION == INPUT_PORT_PULLUP)
    1b80:	8a 81       	ldd	r24, Y+2	; 0x02
    1b82:	88 23       	and	r24, r24
    1b84:	21 f4       	brne	.+8      	; 0x1b8e <DIO_setupPortDirection+0xb4>
					PORTD = 0xFF;
    1b86:	e2 e3       	ldi	r30, 0x32	; 50
    1b88:	f0 e0       	ldi	r31, 0x00	; 0
    1b8a:	8f ef       	ldi	r24, 0xFF	; 255
    1b8c:	80 83       	st	Z, r24
				break;
				
			
		}
	}
}
    1b8e:	0f 90       	pop	r0
    1b90:	0f 90       	pop	r0
    1b92:	0f 90       	pop	r0
    1b94:	0f 90       	pop	r0
    1b96:	cf 91       	pop	r28
    1b98:	df 91       	pop	r29
    1b9a:	08 95       	ret

00001b9c <DIO_writePort>:

void DIO_writePort(uint8_t PORT_X, uint8_t value)
{
    1b9c:	df 93       	push	r29
    1b9e:	cf 93       	push	r28
    1ba0:	00 d0       	rcall	.+0      	; 0x1ba2 <DIO_writePort+0x6>
    1ba2:	00 d0       	rcall	.+0      	; 0x1ba4 <DIO_writePort+0x8>
    1ba4:	cd b7       	in	r28, 0x3d	; 61
    1ba6:	de b7       	in	r29, 0x3e	; 62
    1ba8:	89 83       	std	Y+1, r24	; 0x01
    1baa:	6a 83       	std	Y+2, r22	; 0x02
	if(  (PORT_X >= NUM_OF_PORT) )
    1bac:	89 81       	ldd	r24, Y+1	; 0x01
    1bae:	84 30       	cpi	r24, 0x04	; 4
    1bb0:	90 f5       	brcc	.+100    	; 0x1c16 <DIO_writePort+0x7a>
	{
		//Error handling ,Nothing to do
	}
	else
	{
		switch(PORT_X)
    1bb2:	89 81       	ldd	r24, Y+1	; 0x01
    1bb4:	28 2f       	mov	r18, r24
    1bb6:	30 e0       	ldi	r19, 0x00	; 0
    1bb8:	3c 83       	std	Y+4, r19	; 0x04
    1bba:	2b 83       	std	Y+3, r18	; 0x03
    1bbc:	8b 81       	ldd	r24, Y+3	; 0x03
    1bbe:	9c 81       	ldd	r25, Y+4	; 0x04
    1bc0:	81 30       	cpi	r24, 0x01	; 1
    1bc2:	91 05       	cpc	r25, r1
    1bc4:	d1 f0       	breq	.+52     	; 0x1bfa <DIO_writePort+0x5e>
    1bc6:	2b 81       	ldd	r18, Y+3	; 0x03
    1bc8:	3c 81       	ldd	r19, Y+4	; 0x04
    1bca:	22 30       	cpi	r18, 0x02	; 2
    1bcc:	31 05       	cpc	r19, r1
    1bce:	2c f4       	brge	.+10     	; 0x1bda <DIO_writePort+0x3e>
    1bd0:	8b 81       	ldd	r24, Y+3	; 0x03
    1bd2:	9c 81       	ldd	r25, Y+4	; 0x04
    1bd4:	00 97       	sbiw	r24, 0x00	; 0
    1bd6:	61 f0       	breq	.+24     	; 0x1bf0 <DIO_writePort+0x54>
    1bd8:	1e c0       	rjmp	.+60     	; 0x1c16 <DIO_writePort+0x7a>
    1bda:	2b 81       	ldd	r18, Y+3	; 0x03
    1bdc:	3c 81       	ldd	r19, Y+4	; 0x04
    1bde:	22 30       	cpi	r18, 0x02	; 2
    1be0:	31 05       	cpc	r19, r1
    1be2:	81 f0       	breq	.+32     	; 0x1c04 <DIO_writePort+0x68>
    1be4:	8b 81       	ldd	r24, Y+3	; 0x03
    1be6:	9c 81       	ldd	r25, Y+4	; 0x04
    1be8:	83 30       	cpi	r24, 0x03	; 3
    1bea:	91 05       	cpc	r25, r1
    1bec:	81 f0       	breq	.+32     	; 0x1c0e <DIO_writePort+0x72>
    1bee:	13 c0       	rjmp	.+38     	; 0x1c16 <DIO_writePort+0x7a>
		{
			case PORTA_ID:
				//if(DDRA == 0xFF)//check that all port is output port to put value in PORT register
					PORTA = value;
    1bf0:	eb e3       	ldi	r30, 0x3B	; 59
    1bf2:	f0 e0       	ldi	r31, 0x00	; 0
    1bf4:	8a 81       	ldd	r24, Y+2	; 0x02
    1bf6:	80 83       	st	Z, r24
    1bf8:	0e c0       	rjmp	.+28     	; 0x1c16 <DIO_writePort+0x7a>
				break;
			case PORTB_ID:
				//if(DDRB == 0xFF)//check that all port is output port to put value in PORT register
					PORTB = value;
    1bfa:	e8 e3       	ldi	r30, 0x38	; 56
    1bfc:	f0 e0       	ldi	r31, 0x00	; 0
    1bfe:	8a 81       	ldd	r24, Y+2	; 0x02
    1c00:	80 83       	st	Z, r24
    1c02:	09 c0       	rjmp	.+18     	; 0x1c16 <DIO_writePort+0x7a>
				break;
			case PORTC_ID:
				//if(DDRC == 0xFF)//check that all port is output port to put value in PORT register
					PORTC = value;
    1c04:	e5 e3       	ldi	r30, 0x35	; 53
    1c06:	f0 e0       	ldi	r31, 0x00	; 0
    1c08:	8a 81       	ldd	r24, Y+2	; 0x02
    1c0a:	80 83       	st	Z, r24
    1c0c:	04 c0       	rjmp	.+8      	; 0x1c16 <DIO_writePort+0x7a>
				break;
			case PORTD_ID:
				//if(DDRD == 0xFF)//check that all port is output port to put value in PORT register
					PORTD = value;
    1c0e:	e2 e3       	ldi	r30, 0x32	; 50
    1c10:	f0 e0       	ldi	r31, 0x00	; 0
    1c12:	8a 81       	ldd	r24, Y+2	; 0x02
    1c14:	80 83       	st	Z, r24
				break;
		}
	}
}
    1c16:	0f 90       	pop	r0
    1c18:	0f 90       	pop	r0
    1c1a:	0f 90       	pop	r0
    1c1c:	0f 90       	pop	r0
    1c1e:	cf 91       	pop	r28
    1c20:	df 91       	pop	r29
    1c22:	08 95       	ret

00001c24 <DIO_readPort>:

uint8_t DIO_readPort(uint8_t PORT_X)
{
    1c24:	df 93       	push	r29
    1c26:	cf 93       	push	r28
    1c28:	00 d0       	rcall	.+0      	; 0x1c2a <DIO_readPort+0x6>
    1c2a:	00 d0       	rcall	.+0      	; 0x1c2c <DIO_readPort+0x8>
    1c2c:	cd b7       	in	r28, 0x3d	; 61
    1c2e:	de b7       	in	r29, 0x3e	; 62
    1c30:	8a 83       	std	Y+2, r24	; 0x02
	uint8_t return_value = LOGIC_LOW;
    1c32:	19 82       	std	Y+1, r1	; 0x01
	if(  (PORT_X >= NUM_OF_PORT) )
    1c34:	8a 81       	ldd	r24, Y+2	; 0x02
    1c36:	84 30       	cpi	r24, 0x04	; 4
    1c38:	90 f5       	brcc	.+100    	; 0x1c9e <DIO_readPort+0x7a>
	{
		//Error handling ,Nothing to do
	}
	else
	{
		switch(PORT_X)
    1c3a:	8a 81       	ldd	r24, Y+2	; 0x02
    1c3c:	28 2f       	mov	r18, r24
    1c3e:	30 e0       	ldi	r19, 0x00	; 0
    1c40:	3c 83       	std	Y+4, r19	; 0x04
    1c42:	2b 83       	std	Y+3, r18	; 0x03
    1c44:	8b 81       	ldd	r24, Y+3	; 0x03
    1c46:	9c 81       	ldd	r25, Y+4	; 0x04
    1c48:	81 30       	cpi	r24, 0x01	; 1
    1c4a:	91 05       	cpc	r25, r1
    1c4c:	d1 f0       	breq	.+52     	; 0x1c82 <DIO_readPort+0x5e>
    1c4e:	2b 81       	ldd	r18, Y+3	; 0x03
    1c50:	3c 81       	ldd	r19, Y+4	; 0x04
    1c52:	22 30       	cpi	r18, 0x02	; 2
    1c54:	31 05       	cpc	r19, r1
    1c56:	2c f4       	brge	.+10     	; 0x1c62 <DIO_readPort+0x3e>
    1c58:	8b 81       	ldd	r24, Y+3	; 0x03
    1c5a:	9c 81       	ldd	r25, Y+4	; 0x04
    1c5c:	00 97       	sbiw	r24, 0x00	; 0
    1c5e:	61 f0       	breq	.+24     	; 0x1c78 <DIO_readPort+0x54>
    1c60:	1e c0       	rjmp	.+60     	; 0x1c9e <DIO_readPort+0x7a>
    1c62:	2b 81       	ldd	r18, Y+3	; 0x03
    1c64:	3c 81       	ldd	r19, Y+4	; 0x04
    1c66:	22 30       	cpi	r18, 0x02	; 2
    1c68:	31 05       	cpc	r19, r1
    1c6a:	81 f0       	breq	.+32     	; 0x1c8c <DIO_readPort+0x68>
    1c6c:	8b 81       	ldd	r24, Y+3	; 0x03
    1c6e:	9c 81       	ldd	r25, Y+4	; 0x04
    1c70:	83 30       	cpi	r24, 0x03	; 3
    1c72:	91 05       	cpc	r25, r1
    1c74:	81 f0       	breq	.+32     	; 0x1c96 <DIO_readPort+0x72>
    1c76:	13 c0       	rjmp	.+38     	; 0x1c9e <DIO_readPort+0x7a>
		{
			case PORTA_ID:
				return_value = PINA;
    1c78:	e9 e3       	ldi	r30, 0x39	; 57
    1c7a:	f0 e0       	ldi	r31, 0x00	; 0
    1c7c:	80 81       	ld	r24, Z
    1c7e:	89 83       	std	Y+1, r24	; 0x01
    1c80:	0e c0       	rjmp	.+28     	; 0x1c9e <DIO_readPort+0x7a>
				break;
			case PORTB_ID:
				return_value = PINB;
    1c82:	e6 e3       	ldi	r30, 0x36	; 54
    1c84:	f0 e0       	ldi	r31, 0x00	; 0
    1c86:	80 81       	ld	r24, Z
    1c88:	89 83       	std	Y+1, r24	; 0x01
    1c8a:	09 c0       	rjmp	.+18     	; 0x1c9e <DIO_readPort+0x7a>
				break;
			case PORTC_ID:
				return_value = PINC;
    1c8c:	e3 e3       	ldi	r30, 0x33	; 51
    1c8e:	f0 e0       	ldi	r31, 0x00	; 0
    1c90:	80 81       	ld	r24, Z
    1c92:	89 83       	std	Y+1, r24	; 0x01
    1c94:	04 c0       	rjmp	.+8      	; 0x1c9e <DIO_readPort+0x7a>
				break;
			case PORTD_ID:
				return_value = PIND;
    1c96:	e0 e3       	ldi	r30, 0x30	; 48
    1c98:	f0 e0       	ldi	r31, 0x00	; 0
    1c9a:	80 81       	ld	r24, Z
    1c9c:	89 83       	std	Y+1, r24	; 0x01
				break;
				
		}
	}
	return return_value;
    1c9e:	89 81       	ldd	r24, Y+1	; 0x01
    1ca0:	0f 90       	pop	r0
    1ca2:	0f 90       	pop	r0
    1ca4:	0f 90       	pop	r0
    1ca6:	0f 90       	pop	r0
    1ca8:	cf 91       	pop	r28
    1caa:	df 91       	pop	r29
    1cac:	08 95       	ret

00001cae <TC72_init>:
 *******************************************************************************/
#include "../TC72_temperature/tc72_temperature.h"
#include "../LCD/LCD.h"

void TC72_init(TC72_mode mode_parameter)
{
    1cae:	df 93       	push	r29
    1cb0:	cf 93       	push	r28
    1cb2:	0f 92       	push	r0
    1cb4:	cd b7       	in	r28, 0x3d	; 61
    1cb6:	de b7       	in	r29, 0x3e	; 62
    1cb8:	89 83       	std	Y+1, r24	; 0x01
	TC72_enabeSelect(); /*enable selection bit*/
    1cba:	0e 94 ae 0e 	call	0x1d5c	; 0x1d5c <TC72_enabeSelect>

	mode_parameter = mode_parameter |(1<<2); /*because bit 2 should be only 1 🤷‍♂️🔥*/
    1cbe:	89 81       	ldd	r24, Y+1	; 0x01
    1cc0:	84 60       	ori	r24, 0x04	; 4
    1cc2:	89 83       	std	Y+1, r24	; 0x01

	TC72_writeRrgister(CONTROL_WRITE_ADDRESS, mode_parameter);/*call function responsible for write data to set mode wanted*/
    1cc4:	80 e8       	ldi	r24, 0x80	; 128
    1cc6:	69 81       	ldd	r22, Y+1	; 0x01
    1cc8:	0e 94 6c 0e 	call	0x1cd8	; 0x1cd8 <TC72_writeRrgister>
	TC72_disableSelect();/*disable selection bit*/
    1ccc:	0e 94 ba 0e 	call	0x1d74	; 0x1d74 <TC72_disableSelect>
}
    1cd0:	0f 90       	pop	r0
    1cd2:	cf 91       	pop	r28
    1cd4:	df 91       	pop	r29
    1cd6:	08 95       	ret

00001cd8 <TC72_writeRrgister>:


void TC72_writeRrgister(uint8_t address,uint8_t data )
{
    1cd8:	df 93       	push	r29
    1cda:	cf 93       	push	r28
    1cdc:	00 d0       	rcall	.+0      	; 0x1cde <TC72_writeRrgister+0x6>
    1cde:	cd b7       	in	r28, 0x3d	; 61
    1ce0:	de b7       	in	r29, 0x3e	; 62
    1ce2:	89 83       	std	Y+1, r24	; 0x01
    1ce4:	6a 83       	std	Y+2, r22	; 0x02

	SPI_sendByte(address);/*send address  wanted to access*/
    1ce6:	89 81       	ldd	r24, Y+1	; 0x01
    1ce8:	0e 94 4f 08 	call	0x109e	; 0x109e <SPI_sendByte>

	SPI_sendByte(data); /*put data in this address*/
    1cec:	8a 81       	ldd	r24, Y+2	; 0x02
    1cee:	0e 94 4f 08 	call	0x109e	; 0x109e <SPI_sendByte>
}
    1cf2:	0f 90       	pop	r0
    1cf4:	0f 90       	pop	r0
    1cf6:	cf 91       	pop	r28
    1cf8:	df 91       	pop	r29
    1cfa:	08 95       	ret

00001cfc <TC72_readRegister>:

sint16_t TC72_readRegister(uint8_t address )
{
    1cfc:	df 93       	push	r29
    1cfe:	cf 93       	push	r28
    1d00:	00 d0       	rcall	.+0      	; 0x1d02 <TC72_readRegister+0x6>
    1d02:	0f 92       	push	r0
    1d04:	cd b7       	in	r28, 0x3d	; 61
    1d06:	de b7       	in	r29, 0x3e	; 62
    1d08:	8b 83       	std	Y+3, r24	; 0x03
	sint16_t data ;
	TC72_enabeSelect();
    1d0a:	0e 94 ae 0e 	call	0x1d5c	; 0x1d5c <TC72_enabeSelect>

	SPI_sendReceiveByte(address);/*send address  wanted to access*/
    1d0e:	8b 81       	ldd	r24, Y+3	; 0x03
    1d10:	0e 94 62 08 	call	0x10c4	; 0x10c4 <SPI_sendReceiveByte>
	/*and if send address 0x03 and continue sending dummy data to receive data from TC72  will give data in address 0x03 then address 0x02 and repeat this
	 until stop sending dummy data*/
	data = 0 ;
    1d14:	1a 82       	std	Y+2, r1	; 0x02
    1d16:	19 82       	std	Y+1, r1	; 0x01
	data = SPI_sendReceiveByte(SPI_DEFAULT_DATA_VALUE);/*here will receive data of MSB of temperature  */
    1d18:	8f ef       	ldi	r24, 0xFF	; 255
    1d1a:	0e 94 62 08 	call	0x10c4	; 0x10c4 <SPI_sendReceiveByte>
    1d1e:	88 2f       	mov	r24, r24
    1d20:	90 e0       	ldi	r25, 0x00	; 0
    1d22:	9a 83       	std	Y+2, r25	; 0x02
    1d24:	89 83       	std	Y+1, r24	; 0x01
	data = (data << 8); /*here will shift MSB of temperature to add LSB temperature  to same variable to process on it */
    1d26:	89 81       	ldd	r24, Y+1	; 0x01
    1d28:	9a 81       	ldd	r25, Y+2	; 0x02
    1d2a:	98 2f       	mov	r25, r24
    1d2c:	88 27       	eor	r24, r24
    1d2e:	9a 83       	std	Y+2, r25	; 0x02
    1d30:	89 83       	std	Y+1, r24	; 0x01
	data += SPI_sendReceiveByte(SPI_DEFAULT_DATA_VALUE);/*here will receive data of LSB of temperature  */
    1d32:	8f ef       	ldi	r24, 0xFF	; 255
    1d34:	0e 94 62 08 	call	0x10c4	; 0x10c4 <SPI_sendReceiveByte>
    1d38:	28 2f       	mov	r18, r24
    1d3a:	30 e0       	ldi	r19, 0x00	; 0
    1d3c:	89 81       	ldd	r24, Y+1	; 0x01
    1d3e:	9a 81       	ldd	r25, Y+2	; 0x02
    1d40:	82 0f       	add	r24, r18
    1d42:	93 1f       	adc	r25, r19
    1d44:	9a 83       	std	Y+2, r25	; 0x02
    1d46:	89 83       	std	Y+1, r24	; 0x01
	TC72_disableSelect();
    1d48:	0e 94 ba 0e 	call	0x1d74	; 0x1d74 <TC72_disableSelect>
	return data;
    1d4c:	89 81       	ldd	r24, Y+1	; 0x01
    1d4e:	9a 81       	ldd	r25, Y+2	; 0x02

}
    1d50:	0f 90       	pop	r0
    1d52:	0f 90       	pop	r0
    1d54:	0f 90       	pop	r0
    1d56:	cf 91       	pop	r28
    1d58:	df 91       	pop	r29
    1d5a:	08 95       	ret

00001d5c <TC72_enabeSelect>:

void TC72_enabeSelect(void)
{
    1d5c:	df 93       	push	r29
    1d5e:	cf 93       	push	r28
    1d60:	cd b7       	in	r28, 0x3d	; 61
    1d62:	de b7       	in	r29, 0x3e	; 62
	DIO_writePin(SPI_PORT_NUM,SPI_PIN_SS,LOGIC_HIGH);
    1d64:	81 e0       	ldi	r24, 0x01	; 1
    1d66:	64 e0       	ldi	r22, 0x04	; 4
    1d68:	41 e0       	ldi	r20, 0x01	; 1
    1d6a:	0e 94 b1 0a 	call	0x1562	; 0x1562 <DIO_writePin>
}
    1d6e:	cf 91       	pop	r28
    1d70:	df 91       	pop	r29
    1d72:	08 95       	ret

00001d74 <TC72_disableSelect>:

void TC72_disableSelect(void)
{
    1d74:	df 93       	push	r29
    1d76:	cf 93       	push	r28
    1d78:	cd b7       	in	r28, 0x3d	; 61
    1d7a:	de b7       	in	r29, 0x3e	; 62
	DIO_writePin(SPI_PORT_NUM,SPI_PIN_SS,LOGIC_LOW);
    1d7c:	81 e0       	ldi	r24, 0x01	; 1
    1d7e:	64 e0       	ldi	r22, 0x04	; 4
    1d80:	40 e0       	ldi	r20, 0x00	; 0
    1d82:	0e 94 b1 0a 	call	0x1562	; 0x1562 <DIO_writePin>
}
    1d86:	cf 91       	pop	r28
    1d88:	df 91       	pop	r29
    1d8a:	08 95       	ret

00001d8c <TC72_temperatureRead>:


void TC72_temperatureRead(float *temperatureValue)
{
    1d8c:	ef 92       	push	r14
    1d8e:	ff 92       	push	r15
    1d90:	0f 93       	push	r16
    1d92:	1f 93       	push	r17
    1d94:	df 93       	push	r29
    1d96:	cf 93       	push	r28
    1d98:	cd b7       	in	r28, 0x3d	; 61
    1d9a:	de b7       	in	r29, 0x3e	; 62
    1d9c:	27 97       	sbiw	r28, 0x07	; 7
    1d9e:	0f b6       	in	r0, 0x3f	; 63
    1da0:	f8 94       	cli
    1da2:	de bf       	out	0x3e, r29	; 62
    1da4:	0f be       	out	0x3f, r0	; 63
    1da6:	cd bf       	out	0x3d, r28	; 61
    1da8:	9d 83       	std	Y+5, r25	; 0x05
    1daa:	8c 83       	std	Y+4, r24	; 0x04
	*temperatureValue =0;  /*to remove old value and update it with new read in next steps*/
    1dac:	ec 81       	ldd	r30, Y+4	; 0x04
    1dae:	fd 81       	ldd	r31, Y+5	; 0x05
    1db0:	80 e0       	ldi	r24, 0x00	; 0
    1db2:	90 e0       	ldi	r25, 0x00	; 0
    1db4:	a0 e0       	ldi	r26, 0x00	; 0
    1db6:	b0 e0       	ldi	r27, 0x00	; 0
    1db8:	80 83       	st	Z, r24
    1dba:	91 83       	std	Z+1, r25	; 0x01
    1dbc:	a2 83       	std	Z+2, r26	; 0x02
    1dbe:	b3 83       	std	Z+3, r27	; 0x03
	sint16_t tempTemperatureValue = 0 ;
    1dc0:	1b 82       	std	Y+3, r1	; 0x03
    1dc2:	1a 82       	std	Y+2, r1	; 0x02
	tempTemperatureValue =TC72_readRegister(MSB_TEMPERATURE_READ_ADDRESS);
    1dc4:	82 e0       	ldi	r24, 0x02	; 2
    1dc6:	0e 94 7e 0e 	call	0x1cfc	; 0x1cfc <TC72_readRegister>
    1dca:	9b 83       	std	Y+3, r25	; 0x03
    1dcc:	8a 83       	std	Y+2, r24	; 0x02
	tempTemperatureValue = (tempTemperatureValue >> 6) ;/*as temperature data has 16 bit and first 6 don't change and not important*/
    1dce:	8a 81       	ldd	r24, Y+2	; 0x02
    1dd0:	9b 81       	ldd	r25, Y+3	; 0x03
    1dd2:	08 2e       	mov	r0, r24
    1dd4:	89 2f       	mov	r24, r25
    1dd6:	00 0c       	add	r0, r0
    1dd8:	88 1f       	adc	r24, r24
    1dda:	99 0b       	sbc	r25, r25
    1ddc:	00 0c       	add	r0, r0
    1dde:	88 1f       	adc	r24, r24
    1de0:	99 1f       	adc	r25, r25
    1de2:	9b 83       	std	Y+3, r25	; 0x03
    1de4:	8a 83       	std	Y+2, r24	; 0x02
	unsigned char tempValueToCheckfloat =0;/*variable that contain float value of temperature to make on it operation*/
    1de6:	19 82       	std	Y+1, r1	; 0x01
	tempValueToCheckfloat = tempTemperatureValue & 3; /*0b0000011*/
    1de8:	8a 81       	ldd	r24, Y+2	; 0x02
    1dea:	83 70       	andi	r24, 0x03	; 3
    1dec:	89 83       	std	Y+1, r24	; 0x01
	switch (tempValueToCheckfloat)
    1dee:	89 81       	ldd	r24, Y+1	; 0x01
    1df0:	28 2f       	mov	r18, r24
    1df2:	30 e0       	ldi	r19, 0x00	; 0
    1df4:	3f 83       	std	Y+7, r19	; 0x07
    1df6:	2e 83       	std	Y+6, r18	; 0x06
    1df8:	8e 81       	ldd	r24, Y+6	; 0x06
    1dfa:	9f 81       	ldd	r25, Y+7	; 0x07
    1dfc:	82 30       	cpi	r24, 0x02	; 2
    1dfe:	91 05       	cpc	r25, r1
    1e00:	a9 f0       	breq	.+42     	; 0x1e2c <TC72_temperatureRead+0xa0>
    1e02:	2e 81       	ldd	r18, Y+6	; 0x06
    1e04:	3f 81       	ldd	r19, Y+7	; 0x07
    1e06:	23 30       	cpi	r18, 0x03	; 3
    1e08:	31 05       	cpc	r19, r1
    1e0a:	d9 f0       	breq	.+54     	; 0x1e42 <TC72_temperatureRead+0xb6>
    1e0c:	8e 81       	ldd	r24, Y+6	; 0x06
    1e0e:	9f 81       	ldd	r25, Y+7	; 0x07
    1e10:	81 30       	cpi	r24, 0x01	; 1
    1e12:	91 05       	cpc	r25, r1
    1e14:	01 f5       	brne	.+64     	; 0x1e56 <TC72_temperatureRead+0xca>
	{
	case 1 :
		*temperatureValue = 0.25;
    1e16:	ec 81       	ldd	r30, Y+4	; 0x04
    1e18:	fd 81       	ldd	r31, Y+5	; 0x05
    1e1a:	80 e0       	ldi	r24, 0x00	; 0
    1e1c:	90 e0       	ldi	r25, 0x00	; 0
    1e1e:	a0 e8       	ldi	r26, 0x80	; 128
    1e20:	be e3       	ldi	r27, 0x3E	; 62
    1e22:	80 83       	st	Z, r24
    1e24:	91 83       	std	Z+1, r25	; 0x01
    1e26:	a2 83       	std	Z+2, r26	; 0x02
    1e28:	b3 83       	std	Z+3, r27	; 0x03
    1e2a:	15 c0       	rjmp	.+42     	; 0x1e56 <TC72_temperatureRead+0xca>
		break;
	case 2:
		*temperatureValue = 0.5;
    1e2c:	ec 81       	ldd	r30, Y+4	; 0x04
    1e2e:	fd 81       	ldd	r31, Y+5	; 0x05
    1e30:	80 e0       	ldi	r24, 0x00	; 0
    1e32:	90 e0       	ldi	r25, 0x00	; 0
    1e34:	a0 e0       	ldi	r26, 0x00	; 0
    1e36:	bf e3       	ldi	r27, 0x3F	; 63
    1e38:	80 83       	st	Z, r24
    1e3a:	91 83       	std	Z+1, r25	; 0x01
    1e3c:	a2 83       	std	Z+2, r26	; 0x02
    1e3e:	b3 83       	std	Z+3, r27	; 0x03
    1e40:	0a c0       	rjmp	.+20     	; 0x1e56 <TC72_temperatureRead+0xca>
		break;
	case 3:
		*temperatureValue = 0.75;
    1e42:	ec 81       	ldd	r30, Y+4	; 0x04
    1e44:	fd 81       	ldd	r31, Y+5	; 0x05
    1e46:	80 e0       	ldi	r24, 0x00	; 0
    1e48:	90 e0       	ldi	r25, 0x00	; 0
    1e4a:	a0 e4       	ldi	r26, 0x40	; 64
    1e4c:	bf e3       	ldi	r27, 0x3F	; 63
    1e4e:	80 83       	st	Z, r24
    1e50:	91 83       	std	Z+1, r25	; 0x01
    1e52:	a2 83       	std	Z+2, r26	; 0x02
    1e54:	b3 83       	std	Z+3, r27	; 0x03
		break;
	}
	tempTemperatureValue =(tempTemperatureValue >> 2);/*to remove bits responsible for fraction and store only integer value */
    1e56:	8a 81       	ldd	r24, Y+2	; 0x02
    1e58:	9b 81       	ldd	r25, Y+3	; 0x03
    1e5a:	95 95       	asr	r25
    1e5c:	87 95       	ror	r24
    1e5e:	95 95       	asr	r25
    1e60:	87 95       	ror	r24
    1e62:	9b 83       	std	Y+3, r25	; 0x03
    1e64:	8a 83       	std	Y+2, r24	; 0x02
	*temperatureValue = *temperatureValue + tempTemperatureValue;
    1e66:	ec 81       	ldd	r30, Y+4	; 0x04
    1e68:	fd 81       	ldd	r31, Y+5	; 0x05
    1e6a:	e0 80       	ld	r14, Z
    1e6c:	f1 80       	ldd	r15, Z+1	; 0x01
    1e6e:	02 81       	ldd	r16, Z+2	; 0x02
    1e70:	13 81       	ldd	r17, Z+3	; 0x03
    1e72:	8a 81       	ldd	r24, Y+2	; 0x02
    1e74:	9b 81       	ldd	r25, Y+3	; 0x03
    1e76:	aa 27       	eor	r26, r26
    1e78:	97 fd       	sbrc	r25, 7
    1e7a:	a0 95       	com	r26
    1e7c:	ba 2f       	mov	r27, r26
    1e7e:	bc 01       	movw	r22, r24
    1e80:	cd 01       	movw	r24, r26
    1e82:	0e 94 09 04 	call	0x812	; 0x812 <__floatsisf>
    1e86:	9b 01       	movw	r18, r22
    1e88:	ac 01       	movw	r20, r24
    1e8a:	c8 01       	movw	r24, r16
    1e8c:	b7 01       	movw	r22, r14
    1e8e:	0e 94 f2 01 	call	0x3e4	; 0x3e4 <__addsf3>
    1e92:	dc 01       	movw	r26, r24
    1e94:	cb 01       	movw	r24, r22
    1e96:	ec 81       	ldd	r30, Y+4	; 0x04
    1e98:	fd 81       	ldd	r31, Y+5	; 0x05
    1e9a:	80 83       	st	Z, r24
    1e9c:	91 83       	std	Z+1, r25	; 0x01
    1e9e:	a2 83       	std	Z+2, r26	; 0x02
    1ea0:	b3 83       	std	Z+3, r27	; 0x03
}
    1ea2:	27 96       	adiw	r28, 0x07	; 7
    1ea4:	0f b6       	in	r0, 0x3f	; 63
    1ea6:	f8 94       	cli
    1ea8:	de bf       	out	0x3e, r29	; 62
    1eaa:	0f be       	out	0x3f, r0	; 63
    1eac:	cd bf       	out	0x3d, r28	; 61
    1eae:	cf 91       	pop	r28
    1eb0:	df 91       	pop	r29
    1eb2:	1f 91       	pop	r17
    1eb4:	0f 91       	pop	r16
    1eb6:	ff 90       	pop	r15
    1eb8:	ef 90       	pop	r14
    1eba:	08 95       	ret

00001ebc <TC72_displayTemperature>:

void TC72_displayTemperature (float temperature)
{
    1ebc:	df 93       	push	r29
    1ebe:	cf 93       	push	r28
    1ec0:	00 d0       	rcall	.+0      	; 0x1ec2 <TC72_displayTemperature+0x6>
    1ec2:	00 d0       	rcall	.+0      	; 0x1ec4 <TC72_displayTemperature+0x8>
    1ec4:	cd b7       	in	r28, 0x3d	; 61
    1ec6:	de b7       	in	r29, 0x3e	; 62
    1ec8:	69 83       	std	Y+1, r22	; 0x01
    1eca:	7a 83       	std	Y+2, r23	; 0x02
    1ecc:	8b 83       	std	Y+3, r24	; 0x03
    1ece:	9c 83       	std	Y+4, r25	; 0x04
	LCD_moveCursor(0,0);
    1ed0:	80 e0       	ldi	r24, 0x00	; 0
    1ed2:	60 e0       	ldi	r22, 0x00	; 0
    1ed4:	0e 94 0e 15 	call	0x2a1c	; 0x2a1c <LCD_moveCursor>
	LCD_intToString(temperature);
    1ed8:	69 81       	ldd	r22, Y+1	; 0x01
    1eda:	7a 81       	ldd	r23, Y+2	; 0x02
    1edc:	8b 81       	ldd	r24, Y+3	; 0x03
    1ede:	9c 81       	ldd	r25, Y+4	; 0x04
    1ee0:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1ee4:	dc 01       	movw	r26, r24
    1ee6:	cb 01       	movw	r24, r22
    1ee8:	bc 01       	movw	r22, r24
    1eea:	cd 01       	movw	r24, r26
    1eec:	0e 94 6a 15 	call	0x2ad4	; 0x2ad4 <LCD_intToString>
	temperature =  temperature - ( (int ) temperature);/*update temperature value only with fraction value */
    1ef0:	69 81       	ldd	r22, Y+1	; 0x01
    1ef2:	7a 81       	ldd	r23, Y+2	; 0x02
    1ef4:	8b 81       	ldd	r24, Y+3	; 0x03
    1ef6:	9c 81       	ldd	r25, Y+4	; 0x04
    1ef8:	0e 94 67 04 	call	0x8ce	; 0x8ce <__fixsfsi>
    1efc:	dc 01       	movw	r26, r24
    1efe:	cb 01       	movw	r24, r22
    1f00:	aa 27       	eor	r26, r26
    1f02:	97 fd       	sbrc	r25, 7
    1f04:	a0 95       	com	r26
    1f06:	ba 2f       	mov	r27, r26
    1f08:	bc 01       	movw	r22, r24
    1f0a:	cd 01       	movw	r24, r26
    1f0c:	0e 94 09 04 	call	0x812	; 0x812 <__floatsisf>
    1f10:	9b 01       	movw	r18, r22
    1f12:	ac 01       	movw	r20, r24
    1f14:	69 81       	ldd	r22, Y+1	; 0x01
    1f16:	7a 81       	ldd	r23, Y+2	; 0x02
    1f18:	8b 81       	ldd	r24, Y+3	; 0x03
    1f1a:	9c 81       	ldd	r25, Y+4	; 0x04
    1f1c:	0e 94 c1 01 	call	0x382	; 0x382 <__subsf3>
    1f20:	dc 01       	movw	r26, r24
    1f22:	cb 01       	movw	r24, r22
    1f24:	89 83       	std	Y+1, r24	; 0x01
    1f26:	9a 83       	std	Y+2, r25	; 0x02
    1f28:	ab 83       	std	Y+3, r26	; 0x03
    1f2a:	bc 83       	std	Y+4, r27	; 0x04

	if( temperature && ((float) temperature >= (float) 0.25 ) )
    1f2c:	69 81       	ldd	r22, Y+1	; 0x01
    1f2e:	7a 81       	ldd	r23, Y+2	; 0x02
    1f30:	8b 81       	ldd	r24, Y+3	; 0x03
    1f32:	9c 81       	ldd	r25, Y+4	; 0x04
    1f34:	20 e0       	ldi	r18, 0x00	; 0
    1f36:	30 e0       	ldi	r19, 0x00	; 0
    1f38:	40 e0       	ldi	r20, 0x00	; 0
    1f3a:	50 e0       	ldi	r21, 0x00	; 0
    1f3c:	0e 94 19 03 	call	0x632	; 0x632 <__nesf2>
    1f40:	88 23       	and	r24, r24
    1f42:	09 f4       	brne	.+2      	; 0x1f46 <TC72_displayTemperature+0x8a>
    1f44:	5b c0       	rjmp	.+182    	; 0x1ffc <TC72_displayTemperature+0x140>
    1f46:	69 81       	ldd	r22, Y+1	; 0x01
    1f48:	7a 81       	ldd	r23, Y+2	; 0x02
    1f4a:	8b 81       	ldd	r24, Y+3	; 0x03
    1f4c:	9c 81       	ldd	r25, Y+4	; 0x04
    1f4e:	20 e0       	ldi	r18, 0x00	; 0
    1f50:	30 e0       	ldi	r19, 0x00	; 0
    1f52:	40 e8       	ldi	r20, 0x80	; 128
    1f54:	5e e3       	ldi	r21, 0x3E	; 62
    1f56:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__gesf2>
    1f5a:	88 23       	and	r24, r24
    1f5c:	0c f4       	brge	.+2      	; 0x1f60 <TC72_displayTemperature+0xa4>
    1f5e:	4e c0       	rjmp	.+156    	; 0x1ffc <TC72_displayTemperature+0x140>
	{
		LCD_displayCharacter('.');
    1f60:	8e e2       	ldi	r24, 0x2E	; 46
    1f62:	0e 94 fe 12 	call	0x25fc	; 0x25fc <LCD_displayCharacter>
		if((float) temperature <= (float) 0.2 )
    1f66:	69 81       	ldd	r22, Y+1	; 0x01
    1f68:	7a 81       	ldd	r23, Y+2	; 0x02
    1f6a:	8b 81       	ldd	r24, Y+3	; 0x03
    1f6c:	9c 81       	ldd	r25, Y+4	; 0x04
    1f6e:	2d ec       	ldi	r18, 0xCD	; 205
    1f70:	3c ec       	ldi	r19, 0xCC	; 204
    1f72:	4c e4       	ldi	r20, 0x4C	; 76
    1f74:	5e e3       	ldi	r21, 0x3E	; 62
    1f76:	0e 94 d9 03 	call	0x7b2	; 0x7b2 <__lesf2>
    1f7a:	18 16       	cp	r1, r24
    1f7c:	3c f0       	brlt	.+14     	; 0x1f8c <TC72_displayTemperature+0xd0>
		{
			LCD_displayStringRowColumn(" ",0,2);
    1f7e:	80 e6       	ldi	r24, 0x60	; 96
    1f80:	90 e0       	ldi	r25, 0x00	; 0
    1f82:	60 e0       	ldi	r22, 0x00	; 0
    1f84:	42 e0       	ldi	r20, 0x02	; 2
    1f86:	0e 94 51 15 	call	0x2aa2	; 0x2aa2 <LCD_displayStringRowColumn>
    1f8a:	38 c0       	rjmp	.+112    	; 0x1ffc <TC72_displayTemperature+0x140>
		}
		else if((float) temperature < (float) 0.5 )
    1f8c:	69 81       	ldd	r22, Y+1	; 0x01
    1f8e:	7a 81       	ldd	r23, Y+2	; 0x02
    1f90:	8b 81       	ldd	r24, Y+3	; 0x03
    1f92:	9c 81       	ldd	r25, Y+4	; 0x04
    1f94:	20 e0       	ldi	r18, 0x00	; 0
    1f96:	30 e0       	ldi	r19, 0x00	; 0
    1f98:	40 e0       	ldi	r20, 0x00	; 0
    1f9a:	5f e3       	ldi	r21, 0x3F	; 63
    1f9c:	0e 94 a9 03 	call	0x752	; 0x752 <__ltsf2>
    1fa0:	88 23       	and	r24, r24
    1fa2:	3c f4       	brge	.+14     	; 0x1fb2 <TC72_displayTemperature+0xf6>
		{
			LCD_intToString(25);
    1fa4:	69 e1       	ldi	r22, 0x19	; 25
    1fa6:	70 e0       	ldi	r23, 0x00	; 0
    1fa8:	80 e0       	ldi	r24, 0x00	; 0
    1faa:	90 e0       	ldi	r25, 0x00	; 0
    1fac:	0e 94 6a 15 	call	0x2ad4	; 0x2ad4 <LCD_intToString>
    1fb0:	25 c0       	rjmp	.+74     	; 0x1ffc <TC72_displayTemperature+0x140>
		}
		else if((float)temperature < (float) 0.75 )
    1fb2:	69 81       	ldd	r22, Y+1	; 0x01
    1fb4:	7a 81       	ldd	r23, Y+2	; 0x02
    1fb6:	8b 81       	ldd	r24, Y+3	; 0x03
    1fb8:	9c 81       	ldd	r25, Y+4	; 0x04
    1fba:	20 e0       	ldi	r18, 0x00	; 0
    1fbc:	30 e0       	ldi	r19, 0x00	; 0
    1fbe:	40 e4       	ldi	r20, 0x40	; 64
    1fc0:	5f e3       	ldi	r21, 0x3F	; 63
    1fc2:	0e 94 a9 03 	call	0x752	; 0x752 <__ltsf2>
    1fc6:	88 23       	and	r24, r24
    1fc8:	3c f4       	brge	.+14     	; 0x1fd8 <TC72_displayTemperature+0x11c>
		{
			LCD_intToString(5);
    1fca:	65 e0       	ldi	r22, 0x05	; 5
    1fcc:	70 e0       	ldi	r23, 0x00	; 0
    1fce:	80 e0       	ldi	r24, 0x00	; 0
    1fd0:	90 e0       	ldi	r25, 0x00	; 0
    1fd2:	0e 94 6a 15 	call	0x2ad4	; 0x2ad4 <LCD_intToString>
    1fd6:	12 c0       	rjmp	.+36     	; 0x1ffc <TC72_displayTemperature+0x140>
		}
		else if((float)temperature < (float) 1)
    1fd8:	69 81       	ldd	r22, Y+1	; 0x01
    1fda:	7a 81       	ldd	r23, Y+2	; 0x02
    1fdc:	8b 81       	ldd	r24, Y+3	; 0x03
    1fde:	9c 81       	ldd	r25, Y+4	; 0x04
    1fe0:	20 e0       	ldi	r18, 0x00	; 0
    1fe2:	30 e0       	ldi	r19, 0x00	; 0
    1fe4:	40 e8       	ldi	r20, 0x80	; 128
    1fe6:	5f e3       	ldi	r21, 0x3F	; 63
    1fe8:	0e 94 a9 03 	call	0x752	; 0x752 <__ltsf2>
    1fec:	88 23       	and	r24, r24
    1fee:	34 f4       	brge	.+12     	; 0x1ffc <TC72_displayTemperature+0x140>
		{
			LCD_intToString(75);
    1ff0:	6b e4       	ldi	r22, 0x4B	; 75
    1ff2:	70 e0       	ldi	r23, 0x00	; 0
    1ff4:	80 e0       	ldi	r24, 0x00	; 0
    1ff6:	90 e0       	ldi	r25, 0x00	; 0
    1ff8:	0e 94 6a 15 	call	0x2ad4	; 0x2ad4 <LCD_intToString>
		}

	}
}
    1ffc:	0f 90       	pop	r0
    1ffe:	0f 90       	pop	r0
    2000:	0f 90       	pop	r0
    2002:	0f 90       	pop	r0
    2004:	cf 91       	pop	r28
    2006:	df 91       	pop	r29
    2008:	08 95       	ret

0000200a <TC72_temperatureGetData>:

#include "Poll_Devices.h"


float TC72_temperatureGetData(void)
{
    200a:	df 93       	push	r29
    200c:	cf 93       	push	r28
    200e:	00 d0       	rcall	.+0      	; 0x2010 <TC72_temperatureGetData+0x6>
    2010:	00 d0       	rcall	.+0      	; 0x2012 <TC72_temperatureGetData+0x8>
    2012:	cd b7       	in	r28, 0x3d	; 61
    2014:	de b7       	in	r29, 0x3e	; 62
	float temperature =0;
    2016:	80 e0       	ldi	r24, 0x00	; 0
    2018:	90 e0       	ldi	r25, 0x00	; 0
    201a:	a0 e0       	ldi	r26, 0x00	; 0
    201c:	b0 e0       	ldi	r27, 0x00	; 0
    201e:	89 83       	std	Y+1, r24	; 0x01
    2020:	9a 83       	std	Y+2, r25	; 0x02
    2022:	ab 83       	std	Y+3, r26	; 0x03
    2024:	bc 83       	std	Y+4, r27	; 0x04
	TC72_temperatureRead(&temperature);
    2026:	ce 01       	movw	r24, r28
    2028:	01 96       	adiw	r24, 0x01	; 1
    202a:	0e 94 c6 0e 	call	0x1d8c	; 0x1d8c <TC72_temperatureRead>
	return temperature;
    202e:	89 81       	ldd	r24, Y+1	; 0x01
    2030:	9a 81       	ldd	r25, Y+2	; 0x02
    2032:	ab 81       	ldd	r26, Y+3	; 0x03
    2034:	bc 81       	ldd	r27, Y+4	; 0x04
}
    2036:	bc 01       	movw	r22, r24
    2038:	cd 01       	movw	r24, r26
    203a:	0f 90       	pop	r0
    203c:	0f 90       	pop	r0
    203e:	0f 90       	pop	r0
    2040:	0f 90       	pop	r0
    2042:	cf 91       	pop	r28
    2044:	df 91       	pop	r29
    2046:	08 95       	ret

00002048 <Tc72_temperatureDataHandle>:
#define KP  0.1f
#define KI  0.01f
float integral =0;

void Tc72_temperatureDataHandle(float temperature)
{
    2048:	ef 92       	push	r14
    204a:	ff 92       	push	r15
    204c:	0f 93       	push	r16
    204e:	1f 93       	push	r17
    2050:	df 93       	push	r29
    2052:	cf 93       	push	r28
    2054:	cd b7       	in	r28, 0x3d	; 61
    2056:	de b7       	in	r29, 0x3e	; 62
    2058:	62 97       	sbiw	r28, 0x12	; 18
    205a:	0f b6       	in	r0, 0x3f	; 63
    205c:	f8 94       	cli
    205e:	de bf       	out	0x3e, r29	; 62
    2060:	0f be       	out	0x3f, r0	; 63
    2062:	cd bf       	out	0x3d, r28	; 61
    2064:	6f 87       	std	Y+15, r22	; 0x0f
    2066:	78 8b       	std	Y+16, r23	; 0x10
    2068:	89 8b       	std	Y+17, r24	; 0x11
    206a:	9a 8b       	std	Y+18, r25	; 0x12
	float current_temperature = temperature;
    206c:	8f 85       	ldd	r24, Y+15	; 0x0f
    206e:	98 89       	ldd	r25, Y+16	; 0x10
    2070:	a9 89       	ldd	r26, Y+17	; 0x11
    2072:	ba 89       	ldd	r27, Y+18	; 0x12
    2074:	8b 87       	std	Y+11, r24	; 0x0b
    2076:	9c 87       	std	Y+12, r25	; 0x0c
    2078:	ad 87       	std	Y+13, r26	; 0x0d
    207a:	be 87       	std	Y+14, r27	; 0x0e
	float target_temperature = 30;
    207c:	80 e0       	ldi	r24, 0x00	; 0
    207e:	90 e0       	ldi	r25, 0x00	; 0
    2080:	a0 ef       	ldi	r26, 0xF0	; 240
    2082:	b1 e4       	ldi	r27, 0x41	; 65
    2084:	8f 83       	std	Y+7, r24	; 0x07
    2086:	98 87       	std	Y+8, r25	; 0x08
    2088:	a9 87       	std	Y+9, r26	; 0x09
    208a:	ba 87       	std	Y+10, r27	; 0x0a

	float error =  current_temperature - target_temperature;
    208c:	6b 85       	ldd	r22, Y+11	; 0x0b
    208e:	7c 85       	ldd	r23, Y+12	; 0x0c
    2090:	8d 85       	ldd	r24, Y+13	; 0x0d
    2092:	9e 85       	ldd	r25, Y+14	; 0x0e
    2094:	2f 81       	ldd	r18, Y+7	; 0x07
    2096:	38 85       	ldd	r19, Y+8	; 0x08
    2098:	49 85       	ldd	r20, Y+9	; 0x09
    209a:	5a 85       	ldd	r21, Y+10	; 0x0a
    209c:	0e 94 c1 01 	call	0x382	; 0x382 <__subsf3>
    20a0:	dc 01       	movw	r26, r24
    20a2:	cb 01       	movw	r24, r22
    20a4:	8b 83       	std	Y+3, r24	; 0x03
    20a6:	9c 83       	std	Y+4, r25	; 0x04
    20a8:	ad 83       	std	Y+5, r26	; 0x05
    20aa:	be 83       	std	Y+6, r27	; 0x06
	integral = integral + (error);
    20ac:	80 91 84 01 	lds	r24, 0x0184
    20b0:	90 91 85 01 	lds	r25, 0x0185
    20b4:	a0 91 86 01 	lds	r26, 0x0186
    20b8:	b0 91 87 01 	lds	r27, 0x0187
    20bc:	bc 01       	movw	r22, r24
    20be:	cd 01       	movw	r24, r26
    20c0:	2b 81       	ldd	r18, Y+3	; 0x03
    20c2:	3c 81       	ldd	r19, Y+4	; 0x04
    20c4:	4d 81       	ldd	r20, Y+5	; 0x05
    20c6:	5e 81       	ldd	r21, Y+6	; 0x06
    20c8:	0e 94 f2 01 	call	0x3e4	; 0x3e4 <__addsf3>
    20cc:	dc 01       	movw	r26, r24
    20ce:	cb 01       	movw	r24, r22
    20d0:	80 93 84 01 	sts	0x0184, r24
    20d4:	90 93 85 01 	sts	0x0185, r25
    20d8:	a0 93 86 01 	sts	0x0186, r26
    20dc:	b0 93 87 01 	sts	0x0187, r27
	int PWM_signal = (KP * error*10) +(KI * integral*10);
    20e0:	6b 81       	ldd	r22, Y+3	; 0x03
    20e2:	7c 81       	ldd	r23, Y+4	; 0x04
    20e4:	8d 81       	ldd	r24, Y+5	; 0x05
    20e6:	9e 81       	ldd	r25, Y+6	; 0x06
    20e8:	2d ec       	ldi	r18, 0xCD	; 205
    20ea:	3c ec       	ldi	r19, 0xCC	; 204
    20ec:	4c ec       	ldi	r20, 0xCC	; 204
    20ee:	5d e3       	ldi	r21, 0x3D	; 61
    20f0:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    20f4:	dc 01       	movw	r26, r24
    20f6:	cb 01       	movw	r24, r22
    20f8:	bc 01       	movw	r22, r24
    20fa:	cd 01       	movw	r24, r26
    20fc:	20 e0       	ldi	r18, 0x00	; 0
    20fe:	30 e0       	ldi	r19, 0x00	; 0
    2100:	40 e2       	ldi	r20, 0x20	; 32
    2102:	51 e4       	ldi	r21, 0x41	; 65
    2104:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    2108:	dc 01       	movw	r26, r24
    210a:	cb 01       	movw	r24, r22
    210c:	7c 01       	movw	r14, r24
    210e:	8d 01       	movw	r16, r26
    2110:	80 91 84 01 	lds	r24, 0x0184
    2114:	90 91 85 01 	lds	r25, 0x0185
    2118:	a0 91 86 01 	lds	r26, 0x0186
    211c:	b0 91 87 01 	lds	r27, 0x0187
    2120:	bc 01       	movw	r22, r24
    2122:	cd 01       	movw	r24, r26
    2124:	2a e0       	ldi	r18, 0x0A	; 10
    2126:	37 ed       	ldi	r19, 0xD7	; 215
    2128:	43 e2       	ldi	r20, 0x23	; 35
    212a:	5c e3       	ldi	r21, 0x3C	; 60
    212c:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    2130:	dc 01       	movw	r26, r24
    2132:	cb 01       	movw	r24, r22
    2134:	bc 01       	movw	r22, r24
    2136:	cd 01       	movw	r24, r26
    2138:	20 e0       	ldi	r18, 0x00	; 0
    213a:	30 e0       	ldi	r19, 0x00	; 0
    213c:	40 e2       	ldi	r20, 0x20	; 32
    213e:	51 e4       	ldi	r21, 0x41	; 65
    2140:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    2144:	dc 01       	movw	r26, r24
    2146:	cb 01       	movw	r24, r22
    2148:	9c 01       	movw	r18, r24
    214a:	ad 01       	movw	r20, r26
    214c:	c8 01       	movw	r24, r16
    214e:	b7 01       	movw	r22, r14
    2150:	0e 94 f2 01 	call	0x3e4	; 0x3e4 <__addsf3>
    2154:	dc 01       	movw	r26, r24
    2156:	cb 01       	movw	r24, r22
    2158:	bc 01       	movw	r22, r24
    215a:	cd 01       	movw	r24, r26
    215c:	0e 94 67 04 	call	0x8ce	; 0x8ce <__fixsfsi>
    2160:	dc 01       	movw	r26, r24
    2162:	cb 01       	movw	r24, r22
    2164:	9a 83       	std	Y+2, r25	; 0x02
    2166:	89 83       	std	Y+1, r24	; 0x01
	if(PWM_signal > 186 )
    2168:	89 81       	ldd	r24, Y+1	; 0x01
    216a:	9a 81       	ldd	r25, Y+2	; 0x02
    216c:	8b 3b       	cpi	r24, 0xBB	; 187
    216e:	91 05       	cpc	r25, r1
    2170:	2c f0       	brlt	.+10     	; 0x217c <Tc72_temperatureDataHandle+0x134>
	{
		PWM_signal = 186;
    2172:	8a eb       	ldi	r24, 0xBA	; 186
    2174:	90 e0       	ldi	r25, 0x00	; 0
    2176:	9a 83       	std	Y+2, r25	; 0x02
    2178:	89 83       	std	Y+1, r24	; 0x01
    217a:	06 c0       	rjmp	.+12     	; 0x2188 <Tc72_temperatureDataHandle+0x140>
	}
	else if(PWM_signal  < 0)
    217c:	89 81       	ldd	r24, Y+1	; 0x01
    217e:	9a 81       	ldd	r25, Y+2	; 0x02
    2180:	99 23       	and	r25, r25
    2182:	14 f4       	brge	.+4      	; 0x2188 <Tc72_temperatureDataHandle+0x140>
	{
		PWM_signal = 0;
    2184:	1a 82       	std	Y+2, r1	; 0x02
    2186:	19 82       	std	Y+1, r1	; 0x01
	}

	DcMotor_Rotate(CW,PWM_signal);
    2188:	99 81       	ldd	r25, Y+1	; 0x01
    218a:	82 e0       	ldi	r24, 0x02	; 2
    218c:	69 2f       	mov	r22, r25
    218e:	0e 94 1c 16 	call	0x2c38	; 0x2c38 <DcMotor_Rotate>
	LCD_moveCursor(1,3);
    2192:	81 e0       	ldi	r24, 0x01	; 1
    2194:	63 e0       	ldi	r22, 0x03	; 3
    2196:	0e 94 0e 15 	call	0x2a1c	; 0x2a1c <LCD_moveCursor>
	LCD_intToString(PWM_signal);
    219a:	89 81       	ldd	r24, Y+1	; 0x01
    219c:	9a 81       	ldd	r25, Y+2	; 0x02
    219e:	aa 27       	eor	r26, r26
    21a0:	97 fd       	sbrc	r25, 7
    21a2:	a0 95       	com	r26
    21a4:	ba 2f       	mov	r27, r26
    21a6:	bc 01       	movw	r22, r24
    21a8:	cd 01       	movw	r24, r26
    21aa:	0e 94 6a 15 	call	0x2ad4	; 0x2ad4 <LCD_intToString>


}
    21ae:	62 96       	adiw	r28, 0x12	; 18
    21b0:	0f b6       	in	r0, 0x3f	; 63
    21b2:	f8 94       	cli
    21b4:	de bf       	out	0x3e, r29	; 62
    21b6:	0f be       	out	0x3f, r0	; 63
    21b8:	cd bf       	out	0x3d, r28	; 61
    21ba:	cf 91       	pop	r28
    21bc:	df 91       	pop	r29
    21be:	1f 91       	pop	r17
    21c0:	0f 91       	pop	r16
    21c2:	ff 90       	pop	r15
    21c4:	ef 90       	pop	r14
    21c6:	08 95       	ret

000021c8 <LCD_init>:
 
 uint8_t human_1_Move[] ={0x0E,0x04,0x0E,0x16,0x04,0x0A,0x12,0x00};
 uint8_t human_2_Move[]={0x0E,0x04,0x0E,0x0D,0x04,0x0A,0x09,0x00};
	 
 void LCD_init(void)
 {
    21c8:	df 93       	push	r29
    21ca:	cf 93       	push	r28
    21cc:	cd b7       	in	r28, 0x3d	; 61
    21ce:	de b7       	in	r29, 0x3e	; 62
	 //set direction for pin RS, R/W & E
	 DIO_setupPinDirection(LCD_RS_PORT_ID , LCD_RS_PIN_ID ,OUTPUT_PIN);
    21d0:	82 e0       	ldi	r24, 0x02	; 2
    21d2:	60 e0       	ldi	r22, 0x00	; 0
    21d4:	42 e0       	ldi	r20, 0x02	; 2
    21d6:	0e 94 0f 09 	call	0x121e	; 0x121e <DIO_setupPinDirection>
	 DIO_setupPinDirection(LCD_RW_PORT_ID , LCD_RW_Pin_ID ,OUTPUT_PIN);
    21da:	82 e0       	ldi	r24, 0x02	; 2
    21dc:	61 e0       	ldi	r22, 0x01	; 1
    21de:	42 e0       	ldi	r20, 0x02	; 2
    21e0:	0e 94 0f 09 	call	0x121e	; 0x121e <DIO_setupPinDirection>
	 DIO_setupPinDirection(LCD_E_PORT_ID , LCD_E_PIN_ID ,OUTPUT_PIN);
    21e4:	82 e0       	ldi	r24, 0x02	; 2
    21e6:	62 e0       	ldi	r22, 0x02	; 2
    21e8:	42 e0       	ldi	r20, 0x02	; 2
    21ea:	0e 94 0f 09 	call	0x121e	; 0x121e <DIO_setupPinDirection>
		DIO_setupPinDirection(LCD_DATA_PORT_ID , LCD_FIRST_DATA_PIN_ID +1 ,OUTPUT_PIN);
		DIO_setupPinDirection(LCD_DATA_PORT_ID , LCD_FIRST_DATA_PIN_ID +2 ,OUTPUT_PIN);
		DIO_setupPinDirection(LCD_DATA_PORT_ID , LCD_FIRST_DATA_PIN_ID +3,OUTPUT_PIN);
		LCD_sendCommand(LCD_RETURN_HOME);/*this line important in 4 bit mode will not work without this line and I don't know reason*/
	 #else
		DIO_setupPortDirection(LCD_DATA_PORT_ID , OUTPUT_PORT);
    21ee:	83 e0       	ldi	r24, 0x03	; 3
    21f0:	6f ef       	ldi	r22, 0xFF	; 255
    21f2:	0e 94 6d 0d 	call	0x1ada	; 0x1ada <DIO_setupPortDirection>
	 */
	 /* choose 8bit or 4bit depend on macros in configuration */
	 #if (LCD_DATA_BITS_MODE == 4 )
		 LCD_sendCommand(LCD_4_BITS_2_LINES);
	 #else
		 LCD_sendCommand(LCD_8_BITS_2_LINES);
    21f6:	88 e3       	ldi	r24, 0x38	; 56
    21f8:	0e 94 0a 11 	call	0x2214	; 0x2214 <LCD_sendCommand>
	 #endif
	 LCD_sendCommand(LCD_DISPLAY_ON_CURSOR_OFF);/*should call to make display on*/
    21fc:	8c e0       	ldi	r24, 0x0C	; 12
    21fe:	0e 94 0a 11 	call	0x2214	; 0x2214 <LCD_sendCommand>
	 LCD_sendCommand(LCD_SHIFT_ENTIRE_DISPLAY_RIGHT);
    2202:	84 e0       	ldi	r24, 0x04	; 4
    2204:	0e 94 0a 11 	call	0x2214	; 0x2214 <LCD_sendCommand>
	 LCD_sendCommand(LCD_CLEAR_SCREEN);
    2208:	81 e0       	ldi	r24, 0x01	; 1
    220a:	0e 94 0a 11 	call	0x2214	; 0x2214 <LCD_sendCommand>
	 
	 
	 
 }
    220e:	cf 91       	pop	r28
    2210:	df 91       	pop	r29
    2212:	08 95       	ret

00002214 <LCD_sendCommand>:
 
 void LCD_sendCommand(uint8_t command)
 {
    2214:	df 93       	push	r29
    2216:	cf 93       	push	r28
    2218:	cd b7       	in	r28, 0x3d	; 61
    221a:	de b7       	in	r29, 0x3e	; 62
    221c:	e9 97       	sbiw	r28, 0x39	; 57
    221e:	0f b6       	in	r0, 0x3f	; 63
    2220:	f8 94       	cli
    2222:	de bf       	out	0x3e, r29	; 62
    2224:	0f be       	out	0x3f, r0	; 63
    2226:	cd bf       	out	0x3d, r28	; 61
    2228:	89 af       	std	Y+57, r24	; 0x39
	 DIO_writePin(LCD_RS_PORT_ID , LCD_RS_PIN_ID ,LOGIC_LOW); /*clear RS to use command register*/
    222a:	82 e0       	ldi	r24, 0x02	; 2
    222c:	60 e0       	ldi	r22, 0x00	; 0
    222e:	40 e0       	ldi	r20, 0x00	; 0
    2230:	0e 94 b1 0a 	call	0x1562	; 0x1562 <DIO_writePin>
	 DIO_writePin(LCD_RW_PORT_ID , LCD_RW_Pin_ID ,LOGIC_LOW); /*clear R/W to write data to LCD*/
    2234:	82 e0       	ldi	r24, 0x02	; 2
    2236:	61 e0       	ldi	r22, 0x01	; 1
    2238:	40 e0       	ldi	r20, 0x00	; 0
    223a:	0e 94 b1 0a 	call	0x1562	; 0x1562 <DIO_writePin>
    223e:	80 e0       	ldi	r24, 0x00	; 0
    2240:	90 e0       	ldi	r25, 0x00	; 0
    2242:	a0 e8       	ldi	r26, 0x80	; 128
    2244:	bf e3       	ldi	r27, 0x3F	; 63
    2246:	8d ab       	std	Y+53, r24	; 0x35
    2248:	9e ab       	std	Y+54, r25	; 0x36
    224a:	af ab       	std	Y+55, r26	; 0x37
    224c:	b8 af       	std	Y+56, r27	; 0x38
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    224e:	6d a9       	ldd	r22, Y+53	; 0x35
    2250:	7e a9       	ldd	r23, Y+54	; 0x36
    2252:	8f a9       	ldd	r24, Y+55	; 0x37
    2254:	98 ad       	ldd	r25, Y+56	; 0x38
    2256:	20 e0       	ldi	r18, 0x00	; 0
    2258:	30 e0       	ldi	r19, 0x00	; 0
    225a:	4a e7       	ldi	r20, 0x7A	; 122
    225c:	53 e4       	ldi	r21, 0x43	; 67
    225e:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    2262:	dc 01       	movw	r26, r24
    2264:	cb 01       	movw	r24, r22
    2266:	89 ab       	std	Y+49, r24	; 0x31
    2268:	9a ab       	std	Y+50, r25	; 0x32
    226a:	ab ab       	std	Y+51, r26	; 0x33
    226c:	bc ab       	std	Y+52, r27	; 0x34
	if (__tmp < 1.0)
    226e:	69 a9       	ldd	r22, Y+49	; 0x31
    2270:	7a a9       	ldd	r23, Y+50	; 0x32
    2272:	8b a9       	ldd	r24, Y+51	; 0x33
    2274:	9c a9       	ldd	r25, Y+52	; 0x34
    2276:	20 e0       	ldi	r18, 0x00	; 0
    2278:	30 e0       	ldi	r19, 0x00	; 0
    227a:	40 e8       	ldi	r20, 0x80	; 128
    227c:	5f e3       	ldi	r21, 0x3F	; 63
    227e:	0e 94 a9 03 	call	0x752	; 0x752 <__ltsf2>
    2282:	88 23       	and	r24, r24
    2284:	2c f4       	brge	.+10     	; 0x2290 <LCD_sendCommand+0x7c>
		__ticks = 1;
    2286:	81 e0       	ldi	r24, 0x01	; 1
    2288:	90 e0       	ldi	r25, 0x00	; 0
    228a:	98 ab       	std	Y+48, r25	; 0x30
    228c:	8f a7       	std	Y+47, r24	; 0x2f
    228e:	3f c0       	rjmp	.+126    	; 0x230e <LCD_sendCommand+0xfa>
	else if (__tmp > 65535)
    2290:	69 a9       	ldd	r22, Y+49	; 0x31
    2292:	7a a9       	ldd	r23, Y+50	; 0x32
    2294:	8b a9       	ldd	r24, Y+51	; 0x33
    2296:	9c a9       	ldd	r25, Y+52	; 0x34
    2298:	20 e0       	ldi	r18, 0x00	; 0
    229a:	3f ef       	ldi	r19, 0xFF	; 255
    229c:	4f e7       	ldi	r20, 0x7F	; 127
    229e:	57 e4       	ldi	r21, 0x47	; 71
    22a0:	0e 94 49 03 	call	0x692	; 0x692 <__gtsf2>
    22a4:	18 16       	cp	r1, r24
    22a6:	4c f5       	brge	.+82     	; 0x22fa <LCD_sendCommand+0xe6>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    22a8:	6d a9       	ldd	r22, Y+53	; 0x35
    22aa:	7e a9       	ldd	r23, Y+54	; 0x36
    22ac:	8f a9       	ldd	r24, Y+55	; 0x37
    22ae:	98 ad       	ldd	r25, Y+56	; 0x38
    22b0:	20 e0       	ldi	r18, 0x00	; 0
    22b2:	30 e0       	ldi	r19, 0x00	; 0
    22b4:	40 e2       	ldi	r20, 0x20	; 32
    22b6:	51 e4       	ldi	r21, 0x41	; 65
    22b8:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    22bc:	dc 01       	movw	r26, r24
    22be:	cb 01       	movw	r24, r22
    22c0:	bc 01       	movw	r22, r24
    22c2:	cd 01       	movw	r24, r26
    22c4:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    22c8:	dc 01       	movw	r26, r24
    22ca:	cb 01       	movw	r24, r22
    22cc:	98 ab       	std	Y+48, r25	; 0x30
    22ce:	8f a7       	std	Y+47, r24	; 0x2f
    22d0:	0f c0       	rjmp	.+30     	; 0x22f0 <LCD_sendCommand+0xdc>
    22d2:	89 e1       	ldi	r24, 0x19	; 25
    22d4:	90 e0       	ldi	r25, 0x00	; 0
    22d6:	9e a7       	std	Y+46, r25	; 0x2e
    22d8:	8d a7       	std	Y+45, r24	; 0x2d
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    22da:	8d a5       	ldd	r24, Y+45	; 0x2d
    22dc:	9e a5       	ldd	r25, Y+46	; 0x2e
    22de:	01 97       	sbiw	r24, 0x01	; 1
    22e0:	f1 f7       	brne	.-4      	; 0x22de <LCD_sendCommand+0xca>
    22e2:	9e a7       	std	Y+46, r25	; 0x2e
    22e4:	8d a7       	std	Y+45, r24	; 0x2d
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    22e6:	8f a5       	ldd	r24, Y+47	; 0x2f
    22e8:	98 a9       	ldd	r25, Y+48	; 0x30
    22ea:	01 97       	sbiw	r24, 0x01	; 1
    22ec:	98 ab       	std	Y+48, r25	; 0x30
    22ee:	8f a7       	std	Y+47, r24	; 0x2f
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    22f0:	8f a5       	ldd	r24, Y+47	; 0x2f
    22f2:	98 a9       	ldd	r25, Y+48	; 0x30
    22f4:	00 97       	sbiw	r24, 0x00	; 0
    22f6:	69 f7       	brne	.-38     	; 0x22d2 <LCD_sendCommand+0xbe>
    22f8:	14 c0       	rjmp	.+40     	; 0x2322 <LCD_sendCommand+0x10e>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    22fa:	69 a9       	ldd	r22, Y+49	; 0x31
    22fc:	7a a9       	ldd	r23, Y+50	; 0x32
    22fe:	8b a9       	ldd	r24, Y+51	; 0x33
    2300:	9c a9       	ldd	r25, Y+52	; 0x34
    2302:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2306:	dc 01       	movw	r26, r24
    2308:	cb 01       	movw	r24, r22
    230a:	98 ab       	std	Y+48, r25	; 0x30
    230c:	8f a7       	std	Y+47, r24	; 0x2f
    230e:	8f a5       	ldd	r24, Y+47	; 0x2f
    2310:	98 a9       	ldd	r25, Y+48	; 0x30
    2312:	9c a7       	std	Y+44, r25	; 0x2c
    2314:	8b a7       	std	Y+43, r24	; 0x2b
    2316:	8b a5       	ldd	r24, Y+43	; 0x2b
    2318:	9c a5       	ldd	r25, Y+44	; 0x2c
    231a:	01 97       	sbiw	r24, 0x01	; 1
    231c:	f1 f7       	brne	.-4      	; 0x231a <LCD_sendCommand+0x106>
    231e:	9c a7       	std	Y+44, r25	; 0x2c
    2320:	8b a7       	std	Y+43, r24	; 0x2b
//	 TIMER0_Delay_ms(1300); /* delay for processing Tas = 50ns */
	 _delay_ms(1);
	 DIO_writePin(LCD_E_PORT_ID , LCD_E_PIN_ID ,LOGIC_HIGH);  /* Enable LCD E=1 */
    2322:	82 e0       	ldi	r24, 0x02	; 2
    2324:	62 e0       	ldi	r22, 0x02	; 2
    2326:	41 e0       	ldi	r20, 0x01	; 1
    2328:	0e 94 b1 0a 	call	0x1562	; 0x1562 <DIO_writePin>
    232c:	80 e0       	ldi	r24, 0x00	; 0
    232e:	90 e0       	ldi	r25, 0x00	; 0
    2330:	a0 e8       	ldi	r26, 0x80	; 128
    2332:	bf e3       	ldi	r27, 0x3F	; 63
    2334:	8f a3       	std	Y+39, r24	; 0x27
    2336:	98 a7       	std	Y+40, r25	; 0x28
    2338:	a9 a7       	std	Y+41, r26	; 0x29
    233a:	ba a7       	std	Y+42, r27	; 0x2a
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    233c:	6f a1       	ldd	r22, Y+39	; 0x27
    233e:	78 a5       	ldd	r23, Y+40	; 0x28
    2340:	89 a5       	ldd	r24, Y+41	; 0x29
    2342:	9a a5       	ldd	r25, Y+42	; 0x2a
    2344:	20 e0       	ldi	r18, 0x00	; 0
    2346:	30 e0       	ldi	r19, 0x00	; 0
    2348:	4a e7       	ldi	r20, 0x7A	; 122
    234a:	53 e4       	ldi	r21, 0x43	; 67
    234c:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    2350:	dc 01       	movw	r26, r24
    2352:	cb 01       	movw	r24, r22
    2354:	8b a3       	std	Y+35, r24	; 0x23
    2356:	9c a3       	std	Y+36, r25	; 0x24
    2358:	ad a3       	std	Y+37, r26	; 0x25
    235a:	be a3       	std	Y+38, r27	; 0x26
	if (__tmp < 1.0)
    235c:	6b a1       	ldd	r22, Y+35	; 0x23
    235e:	7c a1       	ldd	r23, Y+36	; 0x24
    2360:	8d a1       	ldd	r24, Y+37	; 0x25
    2362:	9e a1       	ldd	r25, Y+38	; 0x26
    2364:	20 e0       	ldi	r18, 0x00	; 0
    2366:	30 e0       	ldi	r19, 0x00	; 0
    2368:	40 e8       	ldi	r20, 0x80	; 128
    236a:	5f e3       	ldi	r21, 0x3F	; 63
    236c:	0e 94 a9 03 	call	0x752	; 0x752 <__ltsf2>
    2370:	88 23       	and	r24, r24
    2372:	2c f4       	brge	.+10     	; 0x237e <LCD_sendCommand+0x16a>
		__ticks = 1;
    2374:	81 e0       	ldi	r24, 0x01	; 1
    2376:	90 e0       	ldi	r25, 0x00	; 0
    2378:	9a a3       	std	Y+34, r25	; 0x22
    237a:	89 a3       	std	Y+33, r24	; 0x21
    237c:	3f c0       	rjmp	.+126    	; 0x23fc <LCD_sendCommand+0x1e8>
	else if (__tmp > 65535)
    237e:	6b a1       	ldd	r22, Y+35	; 0x23
    2380:	7c a1       	ldd	r23, Y+36	; 0x24
    2382:	8d a1       	ldd	r24, Y+37	; 0x25
    2384:	9e a1       	ldd	r25, Y+38	; 0x26
    2386:	20 e0       	ldi	r18, 0x00	; 0
    2388:	3f ef       	ldi	r19, 0xFF	; 255
    238a:	4f e7       	ldi	r20, 0x7F	; 127
    238c:	57 e4       	ldi	r21, 0x47	; 71
    238e:	0e 94 49 03 	call	0x692	; 0x692 <__gtsf2>
    2392:	18 16       	cp	r1, r24
    2394:	4c f5       	brge	.+82     	; 0x23e8 <LCD_sendCommand+0x1d4>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    2396:	6f a1       	ldd	r22, Y+39	; 0x27
    2398:	78 a5       	ldd	r23, Y+40	; 0x28
    239a:	89 a5       	ldd	r24, Y+41	; 0x29
    239c:	9a a5       	ldd	r25, Y+42	; 0x2a
    239e:	20 e0       	ldi	r18, 0x00	; 0
    23a0:	30 e0       	ldi	r19, 0x00	; 0
    23a2:	40 e2       	ldi	r20, 0x20	; 32
    23a4:	51 e4       	ldi	r21, 0x41	; 65
    23a6:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    23aa:	dc 01       	movw	r26, r24
    23ac:	cb 01       	movw	r24, r22
    23ae:	bc 01       	movw	r22, r24
    23b0:	cd 01       	movw	r24, r26
    23b2:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    23b6:	dc 01       	movw	r26, r24
    23b8:	cb 01       	movw	r24, r22
    23ba:	9a a3       	std	Y+34, r25	; 0x22
    23bc:	89 a3       	std	Y+33, r24	; 0x21
    23be:	0f c0       	rjmp	.+30     	; 0x23de <LCD_sendCommand+0x1ca>
    23c0:	89 e1       	ldi	r24, 0x19	; 25
    23c2:	90 e0       	ldi	r25, 0x00	; 0
    23c4:	98 a3       	std	Y+32, r25	; 0x20
    23c6:	8f 8f       	std	Y+31, r24	; 0x1f
    23c8:	8f 8d       	ldd	r24, Y+31	; 0x1f
    23ca:	98 a1       	ldd	r25, Y+32	; 0x20
    23cc:	01 97       	sbiw	r24, 0x01	; 1
    23ce:	f1 f7       	brne	.-4      	; 0x23cc <LCD_sendCommand+0x1b8>
    23d0:	98 a3       	std	Y+32, r25	; 0x20
    23d2:	8f 8f       	std	Y+31, r24	; 0x1f
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    23d4:	89 a1       	ldd	r24, Y+33	; 0x21
    23d6:	9a a1       	ldd	r25, Y+34	; 0x22
    23d8:	01 97       	sbiw	r24, 0x01	; 1
    23da:	9a a3       	std	Y+34, r25	; 0x22
    23dc:	89 a3       	std	Y+33, r24	; 0x21
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    23de:	89 a1       	ldd	r24, Y+33	; 0x21
    23e0:	9a a1       	ldd	r25, Y+34	; 0x22
    23e2:	00 97       	sbiw	r24, 0x00	; 0
    23e4:	69 f7       	brne	.-38     	; 0x23c0 <LCD_sendCommand+0x1ac>
    23e6:	14 c0       	rjmp	.+40     	; 0x2410 <LCD_sendCommand+0x1fc>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    23e8:	6b a1       	ldd	r22, Y+35	; 0x23
    23ea:	7c a1       	ldd	r23, Y+36	; 0x24
    23ec:	8d a1       	ldd	r24, Y+37	; 0x25
    23ee:	9e a1       	ldd	r25, Y+38	; 0x26
    23f0:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    23f4:	dc 01       	movw	r26, r24
    23f6:	cb 01       	movw	r24, r22
    23f8:	9a a3       	std	Y+34, r25	; 0x22
    23fa:	89 a3       	std	Y+33, r24	; 0x21
    23fc:	89 a1       	ldd	r24, Y+33	; 0x21
    23fe:	9a a1       	ldd	r25, Y+34	; 0x22
    2400:	9e 8f       	std	Y+30, r25	; 0x1e
    2402:	8d 8f       	std	Y+29, r24	; 0x1d
    2404:	8d 8d       	ldd	r24, Y+29	; 0x1d
    2406:	9e 8d       	ldd	r25, Y+30	; 0x1e
    2408:	01 97       	sbiw	r24, 0x01	; 1
    240a:	f1 f7       	brne	.-4      	; 0x2408 <LCD_sendCommand+0x1f4>
    240c:	9e 8f       	std	Y+30, r25	; 0x1e
    240e:	8d 8f       	std	Y+29, r24	; 0x1d
		 DIO_writePin(LCD_E_PORT_ID , LCD_E_PIN_ID ,LOGIC_LOW);  /* Disable LCD E=1 */
//		 TIMER0_Delay_ms(1300); /* delay for processing Th = 13ns */
		 _delay_ms(1);
	 
	 #elif( LCD_DATA_BITS_MODE == 8)
		 DIO_writePort( LCD_DATA_PORT_ID ,command);
    2410:	83 e0       	ldi	r24, 0x03	; 3
    2412:	69 ad       	ldd	r22, Y+57	; 0x39
    2414:	0e 94 ce 0d 	call	0x1b9c	; 0x1b9c <DIO_writePort>
    2418:	80 e0       	ldi	r24, 0x00	; 0
    241a:	90 e0       	ldi	r25, 0x00	; 0
    241c:	a0 e8       	ldi	r26, 0x80	; 128
    241e:	bf e3       	ldi	r27, 0x3F	; 63
    2420:	89 8f       	std	Y+25, r24	; 0x19
    2422:	9a 8f       	std	Y+26, r25	; 0x1a
    2424:	ab 8f       	std	Y+27, r26	; 0x1b
    2426:	bc 8f       	std	Y+28, r27	; 0x1c
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    2428:	69 8d       	ldd	r22, Y+25	; 0x19
    242a:	7a 8d       	ldd	r23, Y+26	; 0x1a
    242c:	8b 8d       	ldd	r24, Y+27	; 0x1b
    242e:	9c 8d       	ldd	r25, Y+28	; 0x1c
    2430:	20 e0       	ldi	r18, 0x00	; 0
    2432:	30 e0       	ldi	r19, 0x00	; 0
    2434:	4a e7       	ldi	r20, 0x7A	; 122
    2436:	53 e4       	ldi	r21, 0x43	; 67
    2438:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    243c:	dc 01       	movw	r26, r24
    243e:	cb 01       	movw	r24, r22
    2440:	8d 8b       	std	Y+21, r24	; 0x15
    2442:	9e 8b       	std	Y+22, r25	; 0x16
    2444:	af 8b       	std	Y+23, r26	; 0x17
    2446:	b8 8f       	std	Y+24, r27	; 0x18
	if (__tmp < 1.0)
    2448:	6d 89       	ldd	r22, Y+21	; 0x15
    244a:	7e 89       	ldd	r23, Y+22	; 0x16
    244c:	8f 89       	ldd	r24, Y+23	; 0x17
    244e:	98 8d       	ldd	r25, Y+24	; 0x18
    2450:	20 e0       	ldi	r18, 0x00	; 0
    2452:	30 e0       	ldi	r19, 0x00	; 0
    2454:	40 e8       	ldi	r20, 0x80	; 128
    2456:	5f e3       	ldi	r21, 0x3F	; 63
    2458:	0e 94 a9 03 	call	0x752	; 0x752 <__ltsf2>
    245c:	88 23       	and	r24, r24
    245e:	2c f4       	brge	.+10     	; 0x246a <LCD_sendCommand+0x256>
		__ticks = 1;
    2460:	81 e0       	ldi	r24, 0x01	; 1
    2462:	90 e0       	ldi	r25, 0x00	; 0
    2464:	9c 8b       	std	Y+20, r25	; 0x14
    2466:	8b 8b       	std	Y+19, r24	; 0x13
    2468:	3f c0       	rjmp	.+126    	; 0x24e8 <LCD_sendCommand+0x2d4>
	else if (__tmp > 65535)
    246a:	6d 89       	ldd	r22, Y+21	; 0x15
    246c:	7e 89       	ldd	r23, Y+22	; 0x16
    246e:	8f 89       	ldd	r24, Y+23	; 0x17
    2470:	98 8d       	ldd	r25, Y+24	; 0x18
    2472:	20 e0       	ldi	r18, 0x00	; 0
    2474:	3f ef       	ldi	r19, 0xFF	; 255
    2476:	4f e7       	ldi	r20, 0x7F	; 127
    2478:	57 e4       	ldi	r21, 0x47	; 71
    247a:	0e 94 49 03 	call	0x692	; 0x692 <__gtsf2>
    247e:	18 16       	cp	r1, r24
    2480:	4c f5       	brge	.+82     	; 0x24d4 <LCD_sendCommand+0x2c0>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    2482:	69 8d       	ldd	r22, Y+25	; 0x19
    2484:	7a 8d       	ldd	r23, Y+26	; 0x1a
    2486:	8b 8d       	ldd	r24, Y+27	; 0x1b
    2488:	9c 8d       	ldd	r25, Y+28	; 0x1c
    248a:	20 e0       	ldi	r18, 0x00	; 0
    248c:	30 e0       	ldi	r19, 0x00	; 0
    248e:	40 e2       	ldi	r20, 0x20	; 32
    2490:	51 e4       	ldi	r21, 0x41	; 65
    2492:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    2496:	dc 01       	movw	r26, r24
    2498:	cb 01       	movw	r24, r22
    249a:	bc 01       	movw	r22, r24
    249c:	cd 01       	movw	r24, r26
    249e:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    24a2:	dc 01       	movw	r26, r24
    24a4:	cb 01       	movw	r24, r22
    24a6:	9c 8b       	std	Y+20, r25	; 0x14
    24a8:	8b 8b       	std	Y+19, r24	; 0x13
    24aa:	0f c0       	rjmp	.+30     	; 0x24ca <LCD_sendCommand+0x2b6>
    24ac:	89 e1       	ldi	r24, 0x19	; 25
    24ae:	90 e0       	ldi	r25, 0x00	; 0
    24b0:	9a 8b       	std	Y+18, r25	; 0x12
    24b2:	89 8b       	std	Y+17, r24	; 0x11
    24b4:	89 89       	ldd	r24, Y+17	; 0x11
    24b6:	9a 89       	ldd	r25, Y+18	; 0x12
    24b8:	01 97       	sbiw	r24, 0x01	; 1
    24ba:	f1 f7       	brne	.-4      	; 0x24b8 <LCD_sendCommand+0x2a4>
    24bc:	9a 8b       	std	Y+18, r25	; 0x12
    24be:	89 8b       	std	Y+17, r24	; 0x11
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    24c0:	8b 89       	ldd	r24, Y+19	; 0x13
    24c2:	9c 89       	ldd	r25, Y+20	; 0x14
    24c4:	01 97       	sbiw	r24, 0x01	; 1
    24c6:	9c 8b       	std	Y+20, r25	; 0x14
    24c8:	8b 8b       	std	Y+19, r24	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    24ca:	8b 89       	ldd	r24, Y+19	; 0x13
    24cc:	9c 89       	ldd	r25, Y+20	; 0x14
    24ce:	00 97       	sbiw	r24, 0x00	; 0
    24d0:	69 f7       	brne	.-38     	; 0x24ac <LCD_sendCommand+0x298>
    24d2:	14 c0       	rjmp	.+40     	; 0x24fc <LCD_sendCommand+0x2e8>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    24d4:	6d 89       	ldd	r22, Y+21	; 0x15
    24d6:	7e 89       	ldd	r23, Y+22	; 0x16
    24d8:	8f 89       	ldd	r24, Y+23	; 0x17
    24da:	98 8d       	ldd	r25, Y+24	; 0x18
    24dc:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    24e0:	dc 01       	movw	r26, r24
    24e2:	cb 01       	movw	r24, r22
    24e4:	9c 8b       	std	Y+20, r25	; 0x14
    24e6:	8b 8b       	std	Y+19, r24	; 0x13
    24e8:	8b 89       	ldd	r24, Y+19	; 0x13
    24ea:	9c 89       	ldd	r25, Y+20	; 0x14
    24ec:	98 8b       	std	Y+16, r25	; 0x10
    24ee:	8f 87       	std	Y+15, r24	; 0x0f
    24f0:	8f 85       	ldd	r24, Y+15	; 0x0f
    24f2:	98 89       	ldd	r25, Y+16	; 0x10
    24f4:	01 97       	sbiw	r24, 0x01	; 1
    24f6:	f1 f7       	brne	.-4      	; 0x24f4 <LCD_sendCommand+0x2e0>
    24f8:	98 8b       	std	Y+16, r25	; 0x10
    24fa:	8f 87       	std	Y+15, r24	; 0x0f
//		 TIMER0_Delay_ms(1300); /* delay for processing Tdsw = 100ns */
		 _delay_ms(1);
		 DIO_writePin(LCD_E_PORT_ID , LCD_E_PIN_ID ,LOGIC_LOW);  /* Disable LCD E=1 */
    24fc:	82 e0       	ldi	r24, 0x02	; 2
    24fe:	62 e0       	ldi	r22, 0x02	; 2
    2500:	40 e0       	ldi	r20, 0x00	; 0
    2502:	0e 94 b1 0a 	call	0x1562	; 0x1562 <DIO_writePin>
    2506:	80 e0       	ldi	r24, 0x00	; 0
    2508:	90 e0       	ldi	r25, 0x00	; 0
    250a:	a0 e8       	ldi	r26, 0x80	; 128
    250c:	bf e3       	ldi	r27, 0x3F	; 63
    250e:	8b 87       	std	Y+11, r24	; 0x0b
    2510:	9c 87       	std	Y+12, r25	; 0x0c
    2512:	ad 87       	std	Y+13, r26	; 0x0d
    2514:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    2516:	6b 85       	ldd	r22, Y+11	; 0x0b
    2518:	7c 85       	ldd	r23, Y+12	; 0x0c
    251a:	8d 85       	ldd	r24, Y+13	; 0x0d
    251c:	9e 85       	ldd	r25, Y+14	; 0x0e
    251e:	20 e0       	ldi	r18, 0x00	; 0
    2520:	30 e0       	ldi	r19, 0x00	; 0
    2522:	4a e7       	ldi	r20, 0x7A	; 122
    2524:	53 e4       	ldi	r21, 0x43	; 67
    2526:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    252a:	dc 01       	movw	r26, r24
    252c:	cb 01       	movw	r24, r22
    252e:	8f 83       	std	Y+7, r24	; 0x07
    2530:	98 87       	std	Y+8, r25	; 0x08
    2532:	a9 87       	std	Y+9, r26	; 0x09
    2534:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    2536:	6f 81       	ldd	r22, Y+7	; 0x07
    2538:	78 85       	ldd	r23, Y+8	; 0x08
    253a:	89 85       	ldd	r24, Y+9	; 0x09
    253c:	9a 85       	ldd	r25, Y+10	; 0x0a
    253e:	20 e0       	ldi	r18, 0x00	; 0
    2540:	30 e0       	ldi	r19, 0x00	; 0
    2542:	40 e8       	ldi	r20, 0x80	; 128
    2544:	5f e3       	ldi	r21, 0x3F	; 63
    2546:	0e 94 a9 03 	call	0x752	; 0x752 <__ltsf2>
    254a:	88 23       	and	r24, r24
    254c:	2c f4       	brge	.+10     	; 0x2558 <LCD_sendCommand+0x344>
		__ticks = 1;
    254e:	81 e0       	ldi	r24, 0x01	; 1
    2550:	90 e0       	ldi	r25, 0x00	; 0
    2552:	9e 83       	std	Y+6, r25	; 0x06
    2554:	8d 83       	std	Y+5, r24	; 0x05
    2556:	3f c0       	rjmp	.+126    	; 0x25d6 <LCD_sendCommand+0x3c2>
	else if (__tmp > 65535)
    2558:	6f 81       	ldd	r22, Y+7	; 0x07
    255a:	78 85       	ldd	r23, Y+8	; 0x08
    255c:	89 85       	ldd	r24, Y+9	; 0x09
    255e:	9a 85       	ldd	r25, Y+10	; 0x0a
    2560:	20 e0       	ldi	r18, 0x00	; 0
    2562:	3f ef       	ldi	r19, 0xFF	; 255
    2564:	4f e7       	ldi	r20, 0x7F	; 127
    2566:	57 e4       	ldi	r21, 0x47	; 71
    2568:	0e 94 49 03 	call	0x692	; 0x692 <__gtsf2>
    256c:	18 16       	cp	r1, r24
    256e:	4c f5       	brge	.+82     	; 0x25c2 <LCD_sendCommand+0x3ae>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    2570:	6b 85       	ldd	r22, Y+11	; 0x0b
    2572:	7c 85       	ldd	r23, Y+12	; 0x0c
    2574:	8d 85       	ldd	r24, Y+13	; 0x0d
    2576:	9e 85       	ldd	r25, Y+14	; 0x0e
    2578:	20 e0       	ldi	r18, 0x00	; 0
    257a:	30 e0       	ldi	r19, 0x00	; 0
    257c:	40 e2       	ldi	r20, 0x20	; 32
    257e:	51 e4       	ldi	r21, 0x41	; 65
    2580:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    2584:	dc 01       	movw	r26, r24
    2586:	cb 01       	movw	r24, r22
    2588:	bc 01       	movw	r22, r24
    258a:	cd 01       	movw	r24, r26
    258c:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2590:	dc 01       	movw	r26, r24
    2592:	cb 01       	movw	r24, r22
    2594:	9e 83       	std	Y+6, r25	; 0x06
    2596:	8d 83       	std	Y+5, r24	; 0x05
    2598:	0f c0       	rjmp	.+30     	; 0x25b8 <LCD_sendCommand+0x3a4>
    259a:	89 e1       	ldi	r24, 0x19	; 25
    259c:	90 e0       	ldi	r25, 0x00	; 0
    259e:	9c 83       	std	Y+4, r25	; 0x04
    25a0:	8b 83       	std	Y+3, r24	; 0x03
    25a2:	8b 81       	ldd	r24, Y+3	; 0x03
    25a4:	9c 81       	ldd	r25, Y+4	; 0x04
    25a6:	01 97       	sbiw	r24, 0x01	; 1
    25a8:	f1 f7       	brne	.-4      	; 0x25a6 <LCD_sendCommand+0x392>
    25aa:	9c 83       	std	Y+4, r25	; 0x04
    25ac:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    25ae:	8d 81       	ldd	r24, Y+5	; 0x05
    25b0:	9e 81       	ldd	r25, Y+6	; 0x06
    25b2:	01 97       	sbiw	r24, 0x01	; 1
    25b4:	9e 83       	std	Y+6, r25	; 0x06
    25b6:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    25b8:	8d 81       	ldd	r24, Y+5	; 0x05
    25ba:	9e 81       	ldd	r25, Y+6	; 0x06
    25bc:	00 97       	sbiw	r24, 0x00	; 0
    25be:	69 f7       	brne	.-38     	; 0x259a <LCD_sendCommand+0x386>
    25c0:	14 c0       	rjmp	.+40     	; 0x25ea <LCD_sendCommand+0x3d6>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    25c2:	6f 81       	ldd	r22, Y+7	; 0x07
    25c4:	78 85       	ldd	r23, Y+8	; 0x08
    25c6:	89 85       	ldd	r24, Y+9	; 0x09
    25c8:	9a 85       	ldd	r25, Y+10	; 0x0a
    25ca:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    25ce:	dc 01       	movw	r26, r24
    25d0:	cb 01       	movw	r24, r22
    25d2:	9e 83       	std	Y+6, r25	; 0x06
    25d4:	8d 83       	std	Y+5, r24	; 0x05
    25d6:	8d 81       	ldd	r24, Y+5	; 0x05
    25d8:	9e 81       	ldd	r25, Y+6	; 0x06
    25da:	9a 83       	std	Y+2, r25	; 0x02
    25dc:	89 83       	std	Y+1, r24	; 0x01
    25de:	89 81       	ldd	r24, Y+1	; 0x01
    25e0:	9a 81       	ldd	r25, Y+2	; 0x02
    25e2:	01 97       	sbiw	r24, 0x01	; 1
    25e4:	f1 f7       	brne	.-4      	; 0x25e2 <LCD_sendCommand+0x3ce>
    25e6:	9a 83       	std	Y+2, r25	; 0x02
    25e8:	89 83       	std	Y+1, r24	; 0x01
//		 TIMER0_Delay_ms(1300); /* delay for processing Th = 13ns */
		 _delay_ms(1);
		 
	 #endif
 }
    25ea:	e9 96       	adiw	r28, 0x39	; 57
    25ec:	0f b6       	in	r0, 0x3f	; 63
    25ee:	f8 94       	cli
    25f0:	de bf       	out	0x3e, r29	; 62
    25f2:	0f be       	out	0x3f, r0	; 63
    25f4:	cd bf       	out	0x3d, r28	; 61
    25f6:	cf 91       	pop	r28
    25f8:	df 91       	pop	r29
    25fa:	08 95       	ret

000025fc <LCD_displayCharacter>:
 
 void LCD_displayCharacter(uint8_t data)
 {
    25fc:	df 93       	push	r29
    25fe:	cf 93       	push	r28
    2600:	cd b7       	in	r28, 0x3d	; 61
    2602:	de b7       	in	r29, 0x3e	; 62
    2604:	e9 97       	sbiw	r28, 0x39	; 57
    2606:	0f b6       	in	r0, 0x3f	; 63
    2608:	f8 94       	cli
    260a:	de bf       	out	0x3e, r29	; 62
    260c:	0f be       	out	0x3f, r0	; 63
    260e:	cd bf       	out	0x3d, r28	; 61
    2610:	89 af       	std	Y+57, r24	; 0x39
	 DIO_writePin(LCD_RS_PORT_ID , LCD_RS_PIN_ID ,LOGIC_HIGH); /*set RS to use data register*/
    2612:	82 e0       	ldi	r24, 0x02	; 2
    2614:	60 e0       	ldi	r22, 0x00	; 0
    2616:	41 e0       	ldi	r20, 0x01	; 1
    2618:	0e 94 b1 0a 	call	0x1562	; 0x1562 <DIO_writePin>
	 DIO_writePin(LCD_RW_PORT_ID , LCD_RW_Pin_ID ,LOGIC_LOW); /*clear R/W to write data to LCD*/
    261c:	82 e0       	ldi	r24, 0x02	; 2
    261e:	61 e0       	ldi	r22, 0x01	; 1
    2620:	40 e0       	ldi	r20, 0x00	; 0
    2622:	0e 94 b1 0a 	call	0x1562	; 0x1562 <DIO_writePin>
    2626:	80 e0       	ldi	r24, 0x00	; 0
    2628:	90 e0       	ldi	r25, 0x00	; 0
    262a:	a0 e8       	ldi	r26, 0x80	; 128
    262c:	bf e3       	ldi	r27, 0x3F	; 63
    262e:	8d ab       	std	Y+53, r24	; 0x35
    2630:	9e ab       	std	Y+54, r25	; 0x36
    2632:	af ab       	std	Y+55, r26	; 0x37
    2634:	b8 af       	std	Y+56, r27	; 0x38
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    2636:	6d a9       	ldd	r22, Y+53	; 0x35
    2638:	7e a9       	ldd	r23, Y+54	; 0x36
    263a:	8f a9       	ldd	r24, Y+55	; 0x37
    263c:	98 ad       	ldd	r25, Y+56	; 0x38
    263e:	20 e0       	ldi	r18, 0x00	; 0
    2640:	30 e0       	ldi	r19, 0x00	; 0
    2642:	4a e7       	ldi	r20, 0x7A	; 122
    2644:	53 e4       	ldi	r21, 0x43	; 67
    2646:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    264a:	dc 01       	movw	r26, r24
    264c:	cb 01       	movw	r24, r22
    264e:	89 ab       	std	Y+49, r24	; 0x31
    2650:	9a ab       	std	Y+50, r25	; 0x32
    2652:	ab ab       	std	Y+51, r26	; 0x33
    2654:	bc ab       	std	Y+52, r27	; 0x34
	if (__tmp < 1.0)
    2656:	69 a9       	ldd	r22, Y+49	; 0x31
    2658:	7a a9       	ldd	r23, Y+50	; 0x32
    265a:	8b a9       	ldd	r24, Y+51	; 0x33
    265c:	9c a9       	ldd	r25, Y+52	; 0x34
    265e:	20 e0       	ldi	r18, 0x00	; 0
    2660:	30 e0       	ldi	r19, 0x00	; 0
    2662:	40 e8       	ldi	r20, 0x80	; 128
    2664:	5f e3       	ldi	r21, 0x3F	; 63
    2666:	0e 94 a9 03 	call	0x752	; 0x752 <__ltsf2>
    266a:	88 23       	and	r24, r24
    266c:	2c f4       	brge	.+10     	; 0x2678 <LCD_displayCharacter+0x7c>
		__ticks = 1;
    266e:	81 e0       	ldi	r24, 0x01	; 1
    2670:	90 e0       	ldi	r25, 0x00	; 0
    2672:	98 ab       	std	Y+48, r25	; 0x30
    2674:	8f a7       	std	Y+47, r24	; 0x2f
    2676:	3f c0       	rjmp	.+126    	; 0x26f6 <LCD_displayCharacter+0xfa>
	else if (__tmp > 65535)
    2678:	69 a9       	ldd	r22, Y+49	; 0x31
    267a:	7a a9       	ldd	r23, Y+50	; 0x32
    267c:	8b a9       	ldd	r24, Y+51	; 0x33
    267e:	9c a9       	ldd	r25, Y+52	; 0x34
    2680:	20 e0       	ldi	r18, 0x00	; 0
    2682:	3f ef       	ldi	r19, 0xFF	; 255
    2684:	4f e7       	ldi	r20, 0x7F	; 127
    2686:	57 e4       	ldi	r21, 0x47	; 71
    2688:	0e 94 49 03 	call	0x692	; 0x692 <__gtsf2>
    268c:	18 16       	cp	r1, r24
    268e:	4c f5       	brge	.+82     	; 0x26e2 <LCD_displayCharacter+0xe6>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    2690:	6d a9       	ldd	r22, Y+53	; 0x35
    2692:	7e a9       	ldd	r23, Y+54	; 0x36
    2694:	8f a9       	ldd	r24, Y+55	; 0x37
    2696:	98 ad       	ldd	r25, Y+56	; 0x38
    2698:	20 e0       	ldi	r18, 0x00	; 0
    269a:	30 e0       	ldi	r19, 0x00	; 0
    269c:	40 e2       	ldi	r20, 0x20	; 32
    269e:	51 e4       	ldi	r21, 0x41	; 65
    26a0:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    26a4:	dc 01       	movw	r26, r24
    26a6:	cb 01       	movw	r24, r22
    26a8:	bc 01       	movw	r22, r24
    26aa:	cd 01       	movw	r24, r26
    26ac:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    26b0:	dc 01       	movw	r26, r24
    26b2:	cb 01       	movw	r24, r22
    26b4:	98 ab       	std	Y+48, r25	; 0x30
    26b6:	8f a7       	std	Y+47, r24	; 0x2f
    26b8:	0f c0       	rjmp	.+30     	; 0x26d8 <LCD_displayCharacter+0xdc>
    26ba:	89 e1       	ldi	r24, 0x19	; 25
    26bc:	90 e0       	ldi	r25, 0x00	; 0
    26be:	9e a7       	std	Y+46, r25	; 0x2e
    26c0:	8d a7       	std	Y+45, r24	; 0x2d
    26c2:	8d a5       	ldd	r24, Y+45	; 0x2d
    26c4:	9e a5       	ldd	r25, Y+46	; 0x2e
    26c6:	01 97       	sbiw	r24, 0x01	; 1
    26c8:	f1 f7       	brne	.-4      	; 0x26c6 <LCD_displayCharacter+0xca>
    26ca:	9e a7       	std	Y+46, r25	; 0x2e
    26cc:	8d a7       	std	Y+45, r24	; 0x2d
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    26ce:	8f a5       	ldd	r24, Y+47	; 0x2f
    26d0:	98 a9       	ldd	r25, Y+48	; 0x30
    26d2:	01 97       	sbiw	r24, 0x01	; 1
    26d4:	98 ab       	std	Y+48, r25	; 0x30
    26d6:	8f a7       	std	Y+47, r24	; 0x2f
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    26d8:	8f a5       	ldd	r24, Y+47	; 0x2f
    26da:	98 a9       	ldd	r25, Y+48	; 0x30
    26dc:	00 97       	sbiw	r24, 0x00	; 0
    26de:	69 f7       	brne	.-38     	; 0x26ba <LCD_displayCharacter+0xbe>
    26e0:	14 c0       	rjmp	.+40     	; 0x270a <LCD_displayCharacter+0x10e>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    26e2:	69 a9       	ldd	r22, Y+49	; 0x31
    26e4:	7a a9       	ldd	r23, Y+50	; 0x32
    26e6:	8b a9       	ldd	r24, Y+51	; 0x33
    26e8:	9c a9       	ldd	r25, Y+52	; 0x34
    26ea:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    26ee:	dc 01       	movw	r26, r24
    26f0:	cb 01       	movw	r24, r22
    26f2:	98 ab       	std	Y+48, r25	; 0x30
    26f4:	8f a7       	std	Y+47, r24	; 0x2f
    26f6:	8f a5       	ldd	r24, Y+47	; 0x2f
    26f8:	98 a9       	ldd	r25, Y+48	; 0x30
    26fa:	9c a7       	std	Y+44, r25	; 0x2c
    26fc:	8b a7       	std	Y+43, r24	; 0x2b
    26fe:	8b a5       	ldd	r24, Y+43	; 0x2b
    2700:	9c a5       	ldd	r25, Y+44	; 0x2c
    2702:	01 97       	sbiw	r24, 0x01	; 1
    2704:	f1 f7       	brne	.-4      	; 0x2702 <LCD_displayCharacter+0x106>
    2706:	9c a7       	std	Y+44, r25	; 0x2c
    2708:	8b a7       	std	Y+43, r24	; 0x2b
//	 TIMER0_Delay_ms(1300); /* delay for processing Tas = 50ns */
	 _delay_ms(1);
	 DIO_writePin(LCD_E_PORT_ID , LCD_E_PIN_ID ,LOGIC_HIGH);  /* Enable LCD E=1 */
    270a:	82 e0       	ldi	r24, 0x02	; 2
    270c:	62 e0       	ldi	r22, 0x02	; 2
    270e:	41 e0       	ldi	r20, 0x01	; 1
    2710:	0e 94 b1 0a 	call	0x1562	; 0x1562 <DIO_writePin>
    2714:	80 e0       	ldi	r24, 0x00	; 0
    2716:	90 e0       	ldi	r25, 0x00	; 0
    2718:	a0 e8       	ldi	r26, 0x80	; 128
    271a:	bf e3       	ldi	r27, 0x3F	; 63
    271c:	8f a3       	std	Y+39, r24	; 0x27
    271e:	98 a7       	std	Y+40, r25	; 0x28
    2720:	a9 a7       	std	Y+41, r26	; 0x29
    2722:	ba a7       	std	Y+42, r27	; 0x2a
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    2724:	6f a1       	ldd	r22, Y+39	; 0x27
    2726:	78 a5       	ldd	r23, Y+40	; 0x28
    2728:	89 a5       	ldd	r24, Y+41	; 0x29
    272a:	9a a5       	ldd	r25, Y+42	; 0x2a
    272c:	20 e0       	ldi	r18, 0x00	; 0
    272e:	30 e0       	ldi	r19, 0x00	; 0
    2730:	4a e7       	ldi	r20, 0x7A	; 122
    2732:	53 e4       	ldi	r21, 0x43	; 67
    2734:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    2738:	dc 01       	movw	r26, r24
    273a:	cb 01       	movw	r24, r22
    273c:	8b a3       	std	Y+35, r24	; 0x23
    273e:	9c a3       	std	Y+36, r25	; 0x24
    2740:	ad a3       	std	Y+37, r26	; 0x25
    2742:	be a3       	std	Y+38, r27	; 0x26
	if (__tmp < 1.0)
    2744:	6b a1       	ldd	r22, Y+35	; 0x23
    2746:	7c a1       	ldd	r23, Y+36	; 0x24
    2748:	8d a1       	ldd	r24, Y+37	; 0x25
    274a:	9e a1       	ldd	r25, Y+38	; 0x26
    274c:	20 e0       	ldi	r18, 0x00	; 0
    274e:	30 e0       	ldi	r19, 0x00	; 0
    2750:	40 e8       	ldi	r20, 0x80	; 128
    2752:	5f e3       	ldi	r21, 0x3F	; 63
    2754:	0e 94 a9 03 	call	0x752	; 0x752 <__ltsf2>
    2758:	88 23       	and	r24, r24
    275a:	2c f4       	brge	.+10     	; 0x2766 <LCD_displayCharacter+0x16a>
		__ticks = 1;
    275c:	81 e0       	ldi	r24, 0x01	; 1
    275e:	90 e0       	ldi	r25, 0x00	; 0
    2760:	9a a3       	std	Y+34, r25	; 0x22
    2762:	89 a3       	std	Y+33, r24	; 0x21
    2764:	3f c0       	rjmp	.+126    	; 0x27e4 <LCD_displayCharacter+0x1e8>
	else if (__tmp > 65535)
    2766:	6b a1       	ldd	r22, Y+35	; 0x23
    2768:	7c a1       	ldd	r23, Y+36	; 0x24
    276a:	8d a1       	ldd	r24, Y+37	; 0x25
    276c:	9e a1       	ldd	r25, Y+38	; 0x26
    276e:	20 e0       	ldi	r18, 0x00	; 0
    2770:	3f ef       	ldi	r19, 0xFF	; 255
    2772:	4f e7       	ldi	r20, 0x7F	; 127
    2774:	57 e4       	ldi	r21, 0x47	; 71
    2776:	0e 94 49 03 	call	0x692	; 0x692 <__gtsf2>
    277a:	18 16       	cp	r1, r24
    277c:	4c f5       	brge	.+82     	; 0x27d0 <LCD_displayCharacter+0x1d4>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    277e:	6f a1       	ldd	r22, Y+39	; 0x27
    2780:	78 a5       	ldd	r23, Y+40	; 0x28
    2782:	89 a5       	ldd	r24, Y+41	; 0x29
    2784:	9a a5       	ldd	r25, Y+42	; 0x2a
    2786:	20 e0       	ldi	r18, 0x00	; 0
    2788:	30 e0       	ldi	r19, 0x00	; 0
    278a:	40 e2       	ldi	r20, 0x20	; 32
    278c:	51 e4       	ldi	r21, 0x41	; 65
    278e:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    2792:	dc 01       	movw	r26, r24
    2794:	cb 01       	movw	r24, r22
    2796:	bc 01       	movw	r22, r24
    2798:	cd 01       	movw	r24, r26
    279a:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    279e:	dc 01       	movw	r26, r24
    27a0:	cb 01       	movw	r24, r22
    27a2:	9a a3       	std	Y+34, r25	; 0x22
    27a4:	89 a3       	std	Y+33, r24	; 0x21
    27a6:	0f c0       	rjmp	.+30     	; 0x27c6 <LCD_displayCharacter+0x1ca>
    27a8:	89 e1       	ldi	r24, 0x19	; 25
    27aa:	90 e0       	ldi	r25, 0x00	; 0
    27ac:	98 a3       	std	Y+32, r25	; 0x20
    27ae:	8f 8f       	std	Y+31, r24	; 0x1f
    27b0:	8f 8d       	ldd	r24, Y+31	; 0x1f
    27b2:	98 a1       	ldd	r25, Y+32	; 0x20
    27b4:	01 97       	sbiw	r24, 0x01	; 1
    27b6:	f1 f7       	brne	.-4      	; 0x27b4 <LCD_displayCharacter+0x1b8>
    27b8:	98 a3       	std	Y+32, r25	; 0x20
    27ba:	8f 8f       	std	Y+31, r24	; 0x1f
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    27bc:	89 a1       	ldd	r24, Y+33	; 0x21
    27be:	9a a1       	ldd	r25, Y+34	; 0x22
    27c0:	01 97       	sbiw	r24, 0x01	; 1
    27c2:	9a a3       	std	Y+34, r25	; 0x22
    27c4:	89 a3       	std	Y+33, r24	; 0x21
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    27c6:	89 a1       	ldd	r24, Y+33	; 0x21
    27c8:	9a a1       	ldd	r25, Y+34	; 0x22
    27ca:	00 97       	sbiw	r24, 0x00	; 0
    27cc:	69 f7       	brne	.-38     	; 0x27a8 <LCD_displayCharacter+0x1ac>
    27ce:	14 c0       	rjmp	.+40     	; 0x27f8 <LCD_displayCharacter+0x1fc>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    27d0:	6b a1       	ldd	r22, Y+35	; 0x23
    27d2:	7c a1       	ldd	r23, Y+36	; 0x24
    27d4:	8d a1       	ldd	r24, Y+37	; 0x25
    27d6:	9e a1       	ldd	r25, Y+38	; 0x26
    27d8:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    27dc:	dc 01       	movw	r26, r24
    27de:	cb 01       	movw	r24, r22
    27e0:	9a a3       	std	Y+34, r25	; 0x22
    27e2:	89 a3       	std	Y+33, r24	; 0x21
    27e4:	89 a1       	ldd	r24, Y+33	; 0x21
    27e6:	9a a1       	ldd	r25, Y+34	; 0x22
    27e8:	9e 8f       	std	Y+30, r25	; 0x1e
    27ea:	8d 8f       	std	Y+29, r24	; 0x1d
    27ec:	8d 8d       	ldd	r24, Y+29	; 0x1d
    27ee:	9e 8d       	ldd	r25, Y+30	; 0x1e
    27f0:	01 97       	sbiw	r24, 0x01	; 1
    27f2:	f1 f7       	brne	.-4      	; 0x27f0 <LCD_displayCharacter+0x1f4>
    27f4:	9e 8f       	std	Y+30, r25	; 0x1e
    27f6:	8d 8f       	std	Y+29, r24	; 0x1d
		 DIO_writePin(LCD_E_PORT_ID , LCD_E_PIN_ID ,LOGIC_LOW);  /* Disable LCD E=1 */
//		 TIMER0_Delay_ms(1300); /* delay for processing Th = 13ns */
		 _delay_ms(1);
	 
	 #elif( LCD_DATA_BITS_MODE == 8)
		 DIO_writePort( LCD_DATA_PORT_ID ,data);
    27f8:	83 e0       	ldi	r24, 0x03	; 3
    27fa:	69 ad       	ldd	r22, Y+57	; 0x39
    27fc:	0e 94 ce 0d 	call	0x1b9c	; 0x1b9c <DIO_writePort>
    2800:	80 e0       	ldi	r24, 0x00	; 0
    2802:	90 e0       	ldi	r25, 0x00	; 0
    2804:	a0 e8       	ldi	r26, 0x80	; 128
    2806:	bf e3       	ldi	r27, 0x3F	; 63
    2808:	89 8f       	std	Y+25, r24	; 0x19
    280a:	9a 8f       	std	Y+26, r25	; 0x1a
    280c:	ab 8f       	std	Y+27, r26	; 0x1b
    280e:	bc 8f       	std	Y+28, r27	; 0x1c
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    2810:	69 8d       	ldd	r22, Y+25	; 0x19
    2812:	7a 8d       	ldd	r23, Y+26	; 0x1a
    2814:	8b 8d       	ldd	r24, Y+27	; 0x1b
    2816:	9c 8d       	ldd	r25, Y+28	; 0x1c
    2818:	20 e0       	ldi	r18, 0x00	; 0
    281a:	30 e0       	ldi	r19, 0x00	; 0
    281c:	4a e7       	ldi	r20, 0x7A	; 122
    281e:	53 e4       	ldi	r21, 0x43	; 67
    2820:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    2824:	dc 01       	movw	r26, r24
    2826:	cb 01       	movw	r24, r22
    2828:	8d 8b       	std	Y+21, r24	; 0x15
    282a:	9e 8b       	std	Y+22, r25	; 0x16
    282c:	af 8b       	std	Y+23, r26	; 0x17
    282e:	b8 8f       	std	Y+24, r27	; 0x18
	if (__tmp < 1.0)
    2830:	6d 89       	ldd	r22, Y+21	; 0x15
    2832:	7e 89       	ldd	r23, Y+22	; 0x16
    2834:	8f 89       	ldd	r24, Y+23	; 0x17
    2836:	98 8d       	ldd	r25, Y+24	; 0x18
    2838:	20 e0       	ldi	r18, 0x00	; 0
    283a:	30 e0       	ldi	r19, 0x00	; 0
    283c:	40 e8       	ldi	r20, 0x80	; 128
    283e:	5f e3       	ldi	r21, 0x3F	; 63
    2840:	0e 94 a9 03 	call	0x752	; 0x752 <__ltsf2>
    2844:	88 23       	and	r24, r24
    2846:	2c f4       	brge	.+10     	; 0x2852 <LCD_displayCharacter+0x256>
		__ticks = 1;
    2848:	81 e0       	ldi	r24, 0x01	; 1
    284a:	90 e0       	ldi	r25, 0x00	; 0
    284c:	9c 8b       	std	Y+20, r25	; 0x14
    284e:	8b 8b       	std	Y+19, r24	; 0x13
    2850:	3f c0       	rjmp	.+126    	; 0x28d0 <LCD_displayCharacter+0x2d4>
	else if (__tmp > 65535)
    2852:	6d 89       	ldd	r22, Y+21	; 0x15
    2854:	7e 89       	ldd	r23, Y+22	; 0x16
    2856:	8f 89       	ldd	r24, Y+23	; 0x17
    2858:	98 8d       	ldd	r25, Y+24	; 0x18
    285a:	20 e0       	ldi	r18, 0x00	; 0
    285c:	3f ef       	ldi	r19, 0xFF	; 255
    285e:	4f e7       	ldi	r20, 0x7F	; 127
    2860:	57 e4       	ldi	r21, 0x47	; 71
    2862:	0e 94 49 03 	call	0x692	; 0x692 <__gtsf2>
    2866:	18 16       	cp	r1, r24
    2868:	4c f5       	brge	.+82     	; 0x28bc <LCD_displayCharacter+0x2c0>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    286a:	69 8d       	ldd	r22, Y+25	; 0x19
    286c:	7a 8d       	ldd	r23, Y+26	; 0x1a
    286e:	8b 8d       	ldd	r24, Y+27	; 0x1b
    2870:	9c 8d       	ldd	r25, Y+28	; 0x1c
    2872:	20 e0       	ldi	r18, 0x00	; 0
    2874:	30 e0       	ldi	r19, 0x00	; 0
    2876:	40 e2       	ldi	r20, 0x20	; 32
    2878:	51 e4       	ldi	r21, 0x41	; 65
    287a:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    287e:	dc 01       	movw	r26, r24
    2880:	cb 01       	movw	r24, r22
    2882:	bc 01       	movw	r22, r24
    2884:	cd 01       	movw	r24, r26
    2886:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    288a:	dc 01       	movw	r26, r24
    288c:	cb 01       	movw	r24, r22
    288e:	9c 8b       	std	Y+20, r25	; 0x14
    2890:	8b 8b       	std	Y+19, r24	; 0x13
    2892:	0f c0       	rjmp	.+30     	; 0x28b2 <LCD_displayCharacter+0x2b6>
    2894:	89 e1       	ldi	r24, 0x19	; 25
    2896:	90 e0       	ldi	r25, 0x00	; 0
    2898:	9a 8b       	std	Y+18, r25	; 0x12
    289a:	89 8b       	std	Y+17, r24	; 0x11
    289c:	89 89       	ldd	r24, Y+17	; 0x11
    289e:	9a 89       	ldd	r25, Y+18	; 0x12
    28a0:	01 97       	sbiw	r24, 0x01	; 1
    28a2:	f1 f7       	brne	.-4      	; 0x28a0 <LCD_displayCharacter+0x2a4>
    28a4:	9a 8b       	std	Y+18, r25	; 0x12
    28a6:	89 8b       	std	Y+17, r24	; 0x11
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    28a8:	8b 89       	ldd	r24, Y+19	; 0x13
    28aa:	9c 89       	ldd	r25, Y+20	; 0x14
    28ac:	01 97       	sbiw	r24, 0x01	; 1
    28ae:	9c 8b       	std	Y+20, r25	; 0x14
    28b0:	8b 8b       	std	Y+19, r24	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    28b2:	8b 89       	ldd	r24, Y+19	; 0x13
    28b4:	9c 89       	ldd	r25, Y+20	; 0x14
    28b6:	00 97       	sbiw	r24, 0x00	; 0
    28b8:	69 f7       	brne	.-38     	; 0x2894 <LCD_displayCharacter+0x298>
    28ba:	14 c0       	rjmp	.+40     	; 0x28e4 <LCD_displayCharacter+0x2e8>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    28bc:	6d 89       	ldd	r22, Y+21	; 0x15
    28be:	7e 89       	ldd	r23, Y+22	; 0x16
    28c0:	8f 89       	ldd	r24, Y+23	; 0x17
    28c2:	98 8d       	ldd	r25, Y+24	; 0x18
    28c4:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    28c8:	dc 01       	movw	r26, r24
    28ca:	cb 01       	movw	r24, r22
    28cc:	9c 8b       	std	Y+20, r25	; 0x14
    28ce:	8b 8b       	std	Y+19, r24	; 0x13
    28d0:	8b 89       	ldd	r24, Y+19	; 0x13
    28d2:	9c 89       	ldd	r25, Y+20	; 0x14
    28d4:	98 8b       	std	Y+16, r25	; 0x10
    28d6:	8f 87       	std	Y+15, r24	; 0x0f
    28d8:	8f 85       	ldd	r24, Y+15	; 0x0f
    28da:	98 89       	ldd	r25, Y+16	; 0x10
    28dc:	01 97       	sbiw	r24, 0x01	; 1
    28de:	f1 f7       	brne	.-4      	; 0x28dc <LCD_displayCharacter+0x2e0>
    28e0:	98 8b       	std	Y+16, r25	; 0x10
    28e2:	8f 87       	std	Y+15, r24	; 0x0f
//		 TIMER0_Delay_ms(1300); /* delay for processing Tdsw = 100ns */
		 _delay_ms(1);
		 DIO_writePin(LCD_E_PORT_ID , LCD_E_PIN_ID ,LOGIC_LOW);  /* Disable LCD E=1 */
    28e4:	82 e0       	ldi	r24, 0x02	; 2
    28e6:	62 e0       	ldi	r22, 0x02	; 2
    28e8:	40 e0       	ldi	r20, 0x00	; 0
    28ea:	0e 94 b1 0a 	call	0x1562	; 0x1562 <DIO_writePin>
    28ee:	80 e0       	ldi	r24, 0x00	; 0
    28f0:	90 e0       	ldi	r25, 0x00	; 0
    28f2:	a0 e8       	ldi	r26, 0x80	; 128
    28f4:	bf e3       	ldi	r27, 0x3F	; 63
    28f6:	8b 87       	std	Y+11, r24	; 0x0b
    28f8:	9c 87       	std	Y+12, r25	; 0x0c
    28fa:	ad 87       	std	Y+13, r26	; 0x0d
    28fc:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    28fe:	6b 85       	ldd	r22, Y+11	; 0x0b
    2900:	7c 85       	ldd	r23, Y+12	; 0x0c
    2902:	8d 85       	ldd	r24, Y+13	; 0x0d
    2904:	9e 85       	ldd	r25, Y+14	; 0x0e
    2906:	20 e0       	ldi	r18, 0x00	; 0
    2908:	30 e0       	ldi	r19, 0x00	; 0
    290a:	4a e7       	ldi	r20, 0x7A	; 122
    290c:	53 e4       	ldi	r21, 0x43	; 67
    290e:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    2912:	dc 01       	movw	r26, r24
    2914:	cb 01       	movw	r24, r22
    2916:	8f 83       	std	Y+7, r24	; 0x07
    2918:	98 87       	std	Y+8, r25	; 0x08
    291a:	a9 87       	std	Y+9, r26	; 0x09
    291c:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    291e:	6f 81       	ldd	r22, Y+7	; 0x07
    2920:	78 85       	ldd	r23, Y+8	; 0x08
    2922:	89 85       	ldd	r24, Y+9	; 0x09
    2924:	9a 85       	ldd	r25, Y+10	; 0x0a
    2926:	20 e0       	ldi	r18, 0x00	; 0
    2928:	30 e0       	ldi	r19, 0x00	; 0
    292a:	40 e8       	ldi	r20, 0x80	; 128
    292c:	5f e3       	ldi	r21, 0x3F	; 63
    292e:	0e 94 a9 03 	call	0x752	; 0x752 <__ltsf2>
    2932:	88 23       	and	r24, r24
    2934:	2c f4       	brge	.+10     	; 0x2940 <LCD_displayCharacter+0x344>
		__ticks = 1;
    2936:	81 e0       	ldi	r24, 0x01	; 1
    2938:	90 e0       	ldi	r25, 0x00	; 0
    293a:	9e 83       	std	Y+6, r25	; 0x06
    293c:	8d 83       	std	Y+5, r24	; 0x05
    293e:	3f c0       	rjmp	.+126    	; 0x29be <LCD_displayCharacter+0x3c2>
	else if (__tmp > 65535)
    2940:	6f 81       	ldd	r22, Y+7	; 0x07
    2942:	78 85       	ldd	r23, Y+8	; 0x08
    2944:	89 85       	ldd	r24, Y+9	; 0x09
    2946:	9a 85       	ldd	r25, Y+10	; 0x0a
    2948:	20 e0       	ldi	r18, 0x00	; 0
    294a:	3f ef       	ldi	r19, 0xFF	; 255
    294c:	4f e7       	ldi	r20, 0x7F	; 127
    294e:	57 e4       	ldi	r21, 0x47	; 71
    2950:	0e 94 49 03 	call	0x692	; 0x692 <__gtsf2>
    2954:	18 16       	cp	r1, r24
    2956:	4c f5       	brge	.+82     	; 0x29aa <LCD_displayCharacter+0x3ae>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    2958:	6b 85       	ldd	r22, Y+11	; 0x0b
    295a:	7c 85       	ldd	r23, Y+12	; 0x0c
    295c:	8d 85       	ldd	r24, Y+13	; 0x0d
    295e:	9e 85       	ldd	r25, Y+14	; 0x0e
    2960:	20 e0       	ldi	r18, 0x00	; 0
    2962:	30 e0       	ldi	r19, 0x00	; 0
    2964:	40 e2       	ldi	r20, 0x20	; 32
    2966:	51 e4       	ldi	r21, 0x41	; 65
    2968:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    296c:	dc 01       	movw	r26, r24
    296e:	cb 01       	movw	r24, r22
    2970:	bc 01       	movw	r22, r24
    2972:	cd 01       	movw	r24, r26
    2974:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2978:	dc 01       	movw	r26, r24
    297a:	cb 01       	movw	r24, r22
    297c:	9e 83       	std	Y+6, r25	; 0x06
    297e:	8d 83       	std	Y+5, r24	; 0x05
    2980:	0f c0       	rjmp	.+30     	; 0x29a0 <LCD_displayCharacter+0x3a4>
    2982:	89 e1       	ldi	r24, 0x19	; 25
    2984:	90 e0       	ldi	r25, 0x00	; 0
    2986:	9c 83       	std	Y+4, r25	; 0x04
    2988:	8b 83       	std	Y+3, r24	; 0x03
    298a:	8b 81       	ldd	r24, Y+3	; 0x03
    298c:	9c 81       	ldd	r25, Y+4	; 0x04
    298e:	01 97       	sbiw	r24, 0x01	; 1
    2990:	f1 f7       	brne	.-4      	; 0x298e <LCD_displayCharacter+0x392>
    2992:	9c 83       	std	Y+4, r25	; 0x04
    2994:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    2996:	8d 81       	ldd	r24, Y+5	; 0x05
    2998:	9e 81       	ldd	r25, Y+6	; 0x06
    299a:	01 97       	sbiw	r24, 0x01	; 1
    299c:	9e 83       	std	Y+6, r25	; 0x06
    299e:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    29a0:	8d 81       	ldd	r24, Y+5	; 0x05
    29a2:	9e 81       	ldd	r25, Y+6	; 0x06
    29a4:	00 97       	sbiw	r24, 0x00	; 0
    29a6:	69 f7       	brne	.-38     	; 0x2982 <LCD_displayCharacter+0x386>
    29a8:	14 c0       	rjmp	.+40     	; 0x29d2 <LCD_displayCharacter+0x3d6>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    29aa:	6f 81       	ldd	r22, Y+7	; 0x07
    29ac:	78 85       	ldd	r23, Y+8	; 0x08
    29ae:	89 85       	ldd	r24, Y+9	; 0x09
    29b0:	9a 85       	ldd	r25, Y+10	; 0x0a
    29b2:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    29b6:	dc 01       	movw	r26, r24
    29b8:	cb 01       	movw	r24, r22
    29ba:	9e 83       	std	Y+6, r25	; 0x06
    29bc:	8d 83       	std	Y+5, r24	; 0x05
    29be:	8d 81       	ldd	r24, Y+5	; 0x05
    29c0:	9e 81       	ldd	r25, Y+6	; 0x06
    29c2:	9a 83       	std	Y+2, r25	; 0x02
    29c4:	89 83       	std	Y+1, r24	; 0x01
    29c6:	89 81       	ldd	r24, Y+1	; 0x01
    29c8:	9a 81       	ldd	r25, Y+2	; 0x02
    29ca:	01 97       	sbiw	r24, 0x01	; 1
    29cc:	f1 f7       	brne	.-4      	; 0x29ca <LCD_displayCharacter+0x3ce>
    29ce:	9a 83       	std	Y+2, r25	; 0x02
    29d0:	89 83       	std	Y+1, r24	; 0x01
//		 TIMER0_Delay_ms(1300); /* delay for processing Th = 13ns */
		 _delay_ms(1);
		 
	 #endif
 }
    29d2:	e9 96       	adiw	r28, 0x39	; 57
    29d4:	0f b6       	in	r0, 0x3f	; 63
    29d6:	f8 94       	cli
    29d8:	de bf       	out	0x3e, r29	; 62
    29da:	0f be       	out	0x3f, r0	; 63
    29dc:	cd bf       	out	0x3d, r28	; 61
    29de:	cf 91       	pop	r28
    29e0:	df 91       	pop	r29
    29e2:	08 95       	ret

000029e4 <LCD_displayString>:
 
void LCD_displayString(const uint8_t * string)
{
    29e4:	df 93       	push	r29
    29e6:	cf 93       	push	r28
    29e8:	00 d0       	rcall	.+0      	; 0x29ea <LCD_displayString+0x6>
    29ea:	cd b7       	in	r28, 0x3d	; 61
    29ec:	de b7       	in	r29, 0x3e	; 62
    29ee:	9a 83       	std	Y+2, r25	; 0x02
    29f0:	89 83       	std	Y+1, r24	; 0x01
    29f2:	0a c0       	rjmp	.+20     	; 0x2a08 <LCD_displayString+0x24>
	 /* print string until NULL character */
	 while( (*string) != '\0')
	 {
		 LCD_displayCharacter(*string);
    29f4:	e9 81       	ldd	r30, Y+1	; 0x01
    29f6:	fa 81       	ldd	r31, Y+2	; 0x02
    29f8:	80 81       	ld	r24, Z
    29fa:	0e 94 fe 12 	call	0x25fc	; 0x25fc <LCD_displayCharacter>
		 string++;
    29fe:	89 81       	ldd	r24, Y+1	; 0x01
    2a00:	9a 81       	ldd	r25, Y+2	; 0x02
    2a02:	01 96       	adiw	r24, 0x01	; 1
    2a04:	9a 83       	std	Y+2, r25	; 0x02
    2a06:	89 83       	std	Y+1, r24	; 0x01
 }
 
void LCD_displayString(const uint8_t * string)
{
	 /* print string until NULL character */
	 while( (*string) != '\0')
    2a08:	e9 81       	ldd	r30, Y+1	; 0x01
    2a0a:	fa 81       	ldd	r31, Y+2	; 0x02
    2a0c:	80 81       	ld	r24, Z
    2a0e:	88 23       	and	r24, r24
    2a10:	89 f7       	brne	.-30     	; 0x29f4 <LCD_displayString+0x10>
	 {
		 LCD_displayCharacter(*string);
		 I++;
	 }
	*********************************************************/	
}
    2a12:	0f 90       	pop	r0
    2a14:	0f 90       	pop	r0
    2a16:	cf 91       	pop	r28
    2a18:	df 91       	pop	r29
    2a1a:	08 95       	ret

00002a1c <LCD_moveCursor>:


void LCD_moveCursor(uint8_t row ,uint8_t column)
{
    2a1c:	df 93       	push	r29
    2a1e:	cf 93       	push	r28
    2a20:	00 d0       	rcall	.+0      	; 0x2a22 <LCD_moveCursor+0x6>
    2a22:	00 d0       	rcall	.+0      	; 0x2a24 <LCD_moveCursor+0x8>
    2a24:	0f 92       	push	r0
    2a26:	cd b7       	in	r28, 0x3d	; 61
    2a28:	de b7       	in	r29, 0x3e	; 62
    2a2a:	8a 83       	std	Y+2, r24	; 0x02
    2a2c:	6b 83       	std	Y+3, r22	; 0x03
	 uint8_t address_DDRAM = 0 ;
    2a2e:	19 82       	std	Y+1, r1	; 0x01
	 switch( row )
    2a30:	8a 81       	ldd	r24, Y+2	; 0x02
    2a32:	28 2f       	mov	r18, r24
    2a34:	30 e0       	ldi	r19, 0x00	; 0
    2a36:	3d 83       	std	Y+5, r19	; 0x05
    2a38:	2c 83       	std	Y+4, r18	; 0x04
    2a3a:	8c 81       	ldd	r24, Y+4	; 0x04
    2a3c:	9d 81       	ldd	r25, Y+5	; 0x05
    2a3e:	81 30       	cpi	r24, 0x01	; 1
    2a40:	91 05       	cpc	r25, r1
    2a42:	c1 f0       	breq	.+48     	; 0x2a74 <LCD_moveCursor+0x58>
    2a44:	2c 81       	ldd	r18, Y+4	; 0x04
    2a46:	3d 81       	ldd	r19, Y+5	; 0x05
    2a48:	22 30       	cpi	r18, 0x02	; 2
    2a4a:	31 05       	cpc	r19, r1
    2a4c:	2c f4       	brge	.+10     	; 0x2a58 <LCD_moveCursor+0x3c>
    2a4e:	8c 81       	ldd	r24, Y+4	; 0x04
    2a50:	9d 81       	ldd	r25, Y+5	; 0x05
    2a52:	00 97       	sbiw	r24, 0x00	; 0
    2a54:	61 f0       	breq	.+24     	; 0x2a6e <LCD_moveCursor+0x52>
    2a56:	19 c0       	rjmp	.+50     	; 0x2a8a <LCD_moveCursor+0x6e>
    2a58:	2c 81       	ldd	r18, Y+4	; 0x04
    2a5a:	3d 81       	ldd	r19, Y+5	; 0x05
    2a5c:	22 30       	cpi	r18, 0x02	; 2
    2a5e:	31 05       	cpc	r19, r1
    2a60:	69 f0       	breq	.+26     	; 0x2a7c <LCD_moveCursor+0x60>
    2a62:	8c 81       	ldd	r24, Y+4	; 0x04
    2a64:	9d 81       	ldd	r25, Y+5	; 0x05
    2a66:	83 30       	cpi	r24, 0x03	; 3
    2a68:	91 05       	cpc	r25, r1
    2a6a:	61 f0       	breq	.+24     	; 0x2a84 <LCD_moveCursor+0x68>
    2a6c:	0e c0       	rjmp	.+28     	; 0x2a8a <LCD_moveCursor+0x6e>
	 {
		 case 0:
			address_DDRAM = column ;
    2a6e:	8b 81       	ldd	r24, Y+3	; 0x03
    2a70:	89 83       	std	Y+1, r24	; 0x01
    2a72:	0b c0       	rjmp	.+22     	; 0x2a8a <LCD_moveCursor+0x6e>
			break;
		 case 1:
			address_DDRAM = 0x40 + column ;
    2a74:	8b 81       	ldd	r24, Y+3	; 0x03
    2a76:	80 5c       	subi	r24, 0xC0	; 192
    2a78:	89 83       	std	Y+1, r24	; 0x01
    2a7a:	07 c0       	rjmp	.+14     	; 0x2a8a <LCD_moveCursor+0x6e>
			break;
		 case 2:
			address_DDRAM = 0x10 + column ;
    2a7c:	8b 81       	ldd	r24, Y+3	; 0x03
    2a7e:	80 5f       	subi	r24, 0xF0	; 240
    2a80:	89 83       	std	Y+1, r24	; 0x01
    2a82:	03 c0       	rjmp	.+6      	; 0x2a8a <LCD_moveCursor+0x6e>
			break;
		 case 3:
			address_DDRAM = 0x50 + column ;
    2a84:	8b 81       	ldd	r24, Y+3	; 0x03
    2a86:	80 5b       	subi	r24, 0xB0	; 176
    2a88:	89 83       	std	Y+1, r24	; 0x01
			break;
			
	 }
	 LCD_sendCommand(address_DDRAM | LCD_SET_CURSOR_LOCATION_DDRAM);
    2a8a:	89 81       	ldd	r24, Y+1	; 0x01
    2a8c:	80 68       	ori	r24, 0x80	; 128
    2a8e:	0e 94 0a 11 	call	0x2214	; 0x2214 <LCD_sendCommand>
}
    2a92:	0f 90       	pop	r0
    2a94:	0f 90       	pop	r0
    2a96:	0f 90       	pop	r0
    2a98:	0f 90       	pop	r0
    2a9a:	0f 90       	pop	r0
    2a9c:	cf 91       	pop	r28
    2a9e:	df 91       	pop	r29
    2aa0:	08 95       	ret

00002aa2 <LCD_displayStringRowColumn>:


void LCD_displayStringRowColumn(const uint8_t * string ,uint8_t row ,uint8_t column)
{
    2aa2:	df 93       	push	r29
    2aa4:	cf 93       	push	r28
    2aa6:	00 d0       	rcall	.+0      	; 0x2aa8 <LCD_displayStringRowColumn+0x6>
    2aa8:	00 d0       	rcall	.+0      	; 0x2aaa <LCD_displayStringRowColumn+0x8>
    2aaa:	cd b7       	in	r28, 0x3d	; 61
    2aac:	de b7       	in	r29, 0x3e	; 62
    2aae:	9a 83       	std	Y+2, r25	; 0x02
    2ab0:	89 83       	std	Y+1, r24	; 0x01
    2ab2:	6b 83       	std	Y+3, r22	; 0x03
    2ab4:	4c 83       	std	Y+4, r20	; 0x04
	 LCD_moveCursor(row,column);
    2ab6:	8b 81       	ldd	r24, Y+3	; 0x03
    2ab8:	6c 81       	ldd	r22, Y+4	; 0x04
    2aba:	0e 94 0e 15 	call	0x2a1c	; 0x2a1c <LCD_moveCursor>
	 LCD_displayString(string);
    2abe:	89 81       	ldd	r24, Y+1	; 0x01
    2ac0:	9a 81       	ldd	r25, Y+2	; 0x02
    2ac2:	0e 94 f2 14 	call	0x29e4	; 0x29e4 <LCD_displayString>
}
    2ac6:	0f 90       	pop	r0
    2ac8:	0f 90       	pop	r0
    2aca:	0f 90       	pop	r0
    2acc:	0f 90       	pop	r0
    2ace:	cf 91       	pop	r28
    2ad0:	df 91       	pop	r29
    2ad2:	08 95       	ret

00002ad4 <LCD_intToString>:

void LCD_intToString(uint32_t data)
{
    2ad4:	df 93       	push	r29
    2ad6:	cf 93       	push	r28
    2ad8:	cd b7       	in	r28, 0x3d	; 61
    2ada:	de b7       	in	r29, 0x3e	; 62
    2adc:	65 97       	sbiw	r28, 0x15	; 21
    2ade:	0f b6       	in	r0, 0x3f	; 63
    2ae0:	f8 94       	cli
    2ae2:	de bf       	out	0x3e, r29	; 62
    2ae4:	0f be       	out	0x3f, r0	; 63
    2ae6:	cd bf       	out	0x3d, r28	; 61
    2ae8:	6a 8b       	std	Y+18, r22	; 0x12
    2aea:	7b 8b       	std	Y+19, r23	; 0x13
    2aec:	8c 8b       	std	Y+20, r24	; 0x14
    2aee:	9d 8b       	std	Y+21, r25	; 0x15
	 char string_buff[17];// I write char not sint8_t(signed char ) to avoid warning
	 itoa(data , string_buff , 10); /* Use itoa C function to convert the data to its corresponding ASCII value, 10 for decimal */
    2af0:	8a 89       	ldd	r24, Y+18	; 0x12
    2af2:	9b 89       	ldd	r25, Y+19	; 0x13
    2af4:	9e 01       	movw	r18, r28
    2af6:	2f 5f       	subi	r18, 0xFF	; 255
    2af8:	3f 4f       	sbci	r19, 0xFF	; 255
    2afa:	b9 01       	movw	r22, r18
    2afc:	4a e0       	ldi	r20, 0x0A	; 10
    2afe:	50 e0       	ldi	r21, 0x00	; 0
    2b00:	0e 94 9f 17 	call	0x2f3e	; 0x2f3e <itoa>
	 LCD_displayString( (uint8_t *)string_buff);
    2b04:	ce 01       	movw	r24, r28
    2b06:	01 96       	adiw	r24, 0x01	; 1
    2b08:	0e 94 f2 14 	call	0x29e4	; 0x29e4 <LCD_displayString>
}
    2b0c:	65 96       	adiw	r28, 0x15	; 21
    2b0e:	0f b6       	in	r0, 0x3f	; 63
    2b10:	f8 94       	cli
    2b12:	de bf       	out	0x3e, r29	; 62
    2b14:	0f be       	out	0x3f, r0	; 63
    2b16:	cd bf       	out	0x3d, r28	; 61
    2b18:	cf 91       	pop	r28
    2b1a:	df 91       	pop	r29
    2b1c:	08 95       	ret

00002b1e <LCD_clearScreen>:

void LCD_clearScreen(void)
{
    2b1e:	df 93       	push	r29
    2b20:	cf 93       	push	r28
    2b22:	cd b7       	in	r28, 0x3d	; 61
    2b24:	de b7       	in	r29, 0x3e	; 62
	 LCD_sendCommand(LCD_CLEAR_SCREEN); /* Send clear display command */
    2b26:	81 e0       	ldi	r24, 0x01	; 1
    2b28:	0e 94 0a 11 	call	0x2214	; 0x2214 <LCD_sendCommand>
}
    2b2c:	cf 91       	pop	r28
    2b2e:	df 91       	pop	r29
    2b30:	08 95       	ret

00002b32 <LCD_goBeginOfScreen>:

void LCD_goBeginOfScreen(void)
{
    2b32:	df 93       	push	r29
    2b34:	cf 93       	push	r28
    2b36:	cd b7       	in	r28, 0x3d	; 61
    2b38:	de b7       	in	r29, 0x3e	; 62
	LCD_sendCommand(LCD_RETURN_HOME);
    2b3a:	82 e0       	ldi	r24, 0x02	; 2
    2b3c:	0e 94 0a 11 	call	0x2214	; 0x2214 <LCD_sendCommand>
}
    2b40:	cf 91       	pop	r28
    2b42:	df 91       	pop	r29
    2b44:	08 95       	ret

00002b46 <LCD_generateCustomCharacter>:

void LCD_generateCustomCharacter(uint8_t *ptr_newchar,uint8_t location)
{
    2b46:	df 93       	push	r29
    2b48:	cf 93       	push	r28
    2b4a:	00 d0       	rcall	.+0      	; 0x2b4c <LCD_generateCustomCharacter+0x6>
    2b4c:	00 d0       	rcall	.+0      	; 0x2b4e <LCD_generateCustomCharacter+0x8>
    2b4e:	cd b7       	in	r28, 0x3d	; 61
    2b50:	de b7       	in	r29, 0x3e	; 62
    2b52:	9b 83       	std	Y+3, r25	; 0x03
    2b54:	8a 83       	std	Y+2, r24	; 0x02
    2b56:	6c 83       	std	Y+4, r22	; 0x04
	LCD_sendCommand( LCD_SET_CURSOR_LOCATION_CGRAM + (location *8));
    2b58:	8c 81       	ldd	r24, Y+4	; 0x04
    2b5a:	88 2f       	mov	r24, r24
    2b5c:	90 e0       	ldi	r25, 0x00	; 0
    2b5e:	08 96       	adiw	r24, 0x08	; 8
    2b60:	88 0f       	add	r24, r24
    2b62:	99 1f       	adc	r25, r25
    2b64:	88 0f       	add	r24, r24
    2b66:	99 1f       	adc	r25, r25
    2b68:	88 0f       	add	r24, r24
    2b6a:	99 1f       	adc	r25, r25
    2b6c:	0e 94 0a 11 	call	0x2214	; 0x2214 <LCD_sendCommand>
	 for(uint8_t count=0; count<8 ; count++)
    2b70:	19 82       	std	Y+1, r1	; 0x01
    2b72:	0e c0       	rjmp	.+28     	; 0x2b90 <LCD_generateCustomCharacter+0x4a>
	 {
		 
		 LCD_displayCharacter(ptr_newchar[count]);
    2b74:	89 81       	ldd	r24, Y+1	; 0x01
    2b76:	28 2f       	mov	r18, r24
    2b78:	30 e0       	ldi	r19, 0x00	; 0
    2b7a:	8a 81       	ldd	r24, Y+2	; 0x02
    2b7c:	9b 81       	ldd	r25, Y+3	; 0x03
    2b7e:	fc 01       	movw	r30, r24
    2b80:	e2 0f       	add	r30, r18
    2b82:	f3 1f       	adc	r31, r19
    2b84:	80 81       	ld	r24, Z
    2b86:	0e 94 fe 12 	call	0x25fc	; 0x25fc <LCD_displayCharacter>
}

void LCD_generateCustomCharacter(uint8_t *ptr_newchar,uint8_t location)
{
	LCD_sendCommand( LCD_SET_CURSOR_LOCATION_CGRAM + (location *8));
	 for(uint8_t count=0; count<8 ; count++)
    2b8a:	89 81       	ldd	r24, Y+1	; 0x01
    2b8c:	8f 5f       	subi	r24, 0xFF	; 255
    2b8e:	89 83       	std	Y+1, r24	; 0x01
    2b90:	89 81       	ldd	r24, Y+1	; 0x01
    2b92:	88 30       	cpi	r24, 0x08	; 8
    2b94:	78 f3       	brcs	.-34     	; 0x2b74 <LCD_generateCustomCharacter+0x2e>
	 {
		 
		 LCD_displayCharacter(ptr_newchar[count]);
	 }
	 LCD_moveCursor(0,0);
    2b96:	80 e0       	ldi	r24, 0x00	; 0
    2b98:	60 e0       	ldi	r22, 0x00	; 0
    2b9a:	0e 94 0e 15 	call	0x2a1c	; 0x2a1c <LCD_moveCursor>
}
    2b9e:	0f 90       	pop	r0
    2ba0:	0f 90       	pop	r0
    2ba2:	0f 90       	pop	r0
    2ba4:	0f 90       	pop	r0
    2ba6:	cf 91       	pop	r28
    2ba8:	df 91       	pop	r29
    2baa:	08 95       	ret

00002bac <LCD_humanMoveInit>:

void LCD_humanMoveInit(void)
{
    2bac:	df 93       	push	r29
    2bae:	cf 93       	push	r28
    2bb0:	cd b7       	in	r28, 0x3d	; 61
    2bb2:	de b7       	in	r29, 0x3e	; 62
	LCD_generateCustomCharacter(human_1_Move , LCD_CGRAM_LOCATION_1);
    2bb4:	8b e6       	ldi	r24, 0x6B	; 107
    2bb6:	91 e0       	ldi	r25, 0x01	; 1
    2bb8:	60 e0       	ldi	r22, 0x00	; 0
    2bba:	0e 94 a3 15 	call	0x2b46	; 0x2b46 <LCD_generateCustomCharacter>
	LCD_generateCustomCharacter(human_2_Move , LCD_CGRAM_LOCATION_2);
    2bbe:	83 e7       	ldi	r24, 0x73	; 115
    2bc0:	91 e0       	ldi	r25, 0x01	; 1
    2bc2:	61 e0       	ldi	r22, 0x01	; 1
    2bc4:	0e 94 a3 15 	call	0x2b46	; 0x2b46 <LCD_generateCustomCharacter>
}
    2bc8:	cf 91       	pop	r28
    2bca:	df 91       	pop	r29
    2bcc:	08 95       	ret

00002bce <LCD_humanMoveDisplay>:

void LCD_humanMoveDisplay(uint8_t row ,uint8_t column)
{
    2bce:	df 93       	push	r29
    2bd0:	cf 93       	push	r28
    2bd2:	00 d0       	rcall	.+0      	; 0x2bd4 <LCD_humanMoveDisplay+0x6>
    2bd4:	cd b7       	in	r28, 0x3d	; 61
    2bd6:	de b7       	in	r29, 0x3e	; 62
    2bd8:	89 83       	std	Y+1, r24	; 0x01
    2bda:	6a 83       	std	Y+2, r22	; 0x02
	LCD_moveCursor(row,column);
    2bdc:	89 81       	ldd	r24, Y+1	; 0x01
    2bde:	6a 81       	ldd	r22, Y+2	; 0x02
    2be0:	0e 94 0e 15 	call	0x2a1c	; 0x2a1c <LCD_moveCursor>
	LCD_displayCharacter(LCD_CGRAM_LOCATION_1);
    2be4:	80 e0       	ldi	r24, 0x00	; 0
    2be6:	0e 94 fe 12 	call	0x25fc	; 0x25fc <LCD_displayCharacter>
	LCD_moveCursor(row,column);
    2bea:	89 81       	ldd	r24, Y+1	; 0x01
    2bec:	6a 81       	ldd	r22, Y+2	; 0x02
    2bee:	0e 94 0e 15 	call	0x2a1c	; 0x2a1c <LCD_moveCursor>
	LCD_displayCharacter(LCD_CGRAM_LOCATION_2);
    2bf2:	81 e0       	ldi	r24, 0x01	; 1
    2bf4:	0e 94 fe 12 	call	0x25fc	; 0x25fc <LCD_displayCharacter>
	
	
}
    2bf8:	0f 90       	pop	r0
    2bfa:	0f 90       	pop	r0
    2bfc:	cf 91       	pop	r28
    2bfe:	df 91       	pop	r29
    2c00:	08 95       	ret

00002c02 <DcMotor_Init>:
 * Return: none
 * */


void DcMotor_Init(void)
{
    2c02:	df 93       	push	r29
    2c04:	cf 93       	push	r28
    2c06:	cd b7       	in	r28, 0x3d	; 61
    2c08:	de b7       	in	r29, 0x3e	; 62
	/* configure pin PC0 and PC1 as output pins */
	DIO_setupPinDirection(PORTB_ID, PIN1_ID, OUTPUT_PIN);
    2c0a:	81 e0       	ldi	r24, 0x01	; 1
    2c0c:	61 e0       	ldi	r22, 0x01	; 1
    2c0e:	42 e0       	ldi	r20, 0x02	; 2
    2c10:	0e 94 0f 09 	call	0x121e	; 0x121e <DIO_setupPinDirection>
	DIO_setupPinDirection(PORTB_ID, PIN2_ID, OUTPUT_PIN);
    2c14:	81 e0       	ldi	r24, 0x01	; 1
    2c16:	62 e0       	ldi	r22, 0x02	; 2
    2c18:	42 e0       	ldi	r20, 0x02	; 2
    2c1a:	0e 94 0f 09 	call	0x121e	; 0x121e <DIO_setupPinDirection>

	/* Motor is stop at the beginning */
	DIO_writePin(PORTB_ID,PIN1_ID,0);
    2c1e:	81 e0       	ldi	r24, 0x01	; 1
    2c20:	61 e0       	ldi	r22, 0x01	; 1
    2c22:	40 e0       	ldi	r20, 0x00	; 0
    2c24:	0e 94 b1 0a 	call	0x1562	; 0x1562 <DIO_writePin>
	DIO_writePin(PORTB_ID,PIN2_ID,0);
    2c28:	81 e0       	ldi	r24, 0x01	; 1
    2c2a:	62 e0       	ldi	r22, 0x02	; 2
    2c2c:	40 e0       	ldi	r20, 0x00	; 0
    2c2e:	0e 94 b1 0a 	call	0x1562	; 0x1562 <DIO_writePin>
}
    2c32:	cf 91       	pop	r28
    2c34:	df 91       	pop	r29
    2c36:	08 95       	ret

00002c38 <DcMotor_Rotate>:
 *
 * Return: none
 * */

void DcMotor_Rotate(DcMotor_State state,uint8_t speed)
{
    2c38:	df 93       	push	r29
    2c3a:	cf 93       	push	r28
    2c3c:	00 d0       	rcall	.+0      	; 0x2c3e <DcMotor_Rotate+0x6>
    2c3e:	cd b7       	in	r28, 0x3d	; 61
    2c40:	de b7       	in	r29, 0x3e	; 62
    2c42:	89 83       	std	Y+1, r24	; 0x01
    2c44:	6a 83       	std	Y+2, r22	; 0x02
	/* initialize timer0 PWM with wanted compare value*/
	PWM_Timer0_Start(speed);
    2c46:	8a 81       	ldd	r24, Y+2	; 0x02
    2c48:	0e 94 e9 08 	call	0x11d2	; 0x11d2 <PWM_Timer0_Start>
	/* PB0:PB1 = 00  rotation Stop
	 * PB0:PB1 = 01  rotate anti clockwise
	 * PB0:PB1 = 00  rotate clockwise
	 * */

	if(state == CW){
    2c4c:	89 81       	ldd	r24, Y+1	; 0x01
    2c4e:	82 30       	cpi	r24, 0x02	; 2
    2c50:	59 f4       	brne	.+22     	; 0x2c68 <DcMotor_Rotate+0x30>
		DIO_writePin(PORTB_ID,PIN1_ID,0);
    2c52:	81 e0       	ldi	r24, 0x01	; 1
    2c54:	61 e0       	ldi	r22, 0x01	; 1
    2c56:	40 e0       	ldi	r20, 0x00	; 0
    2c58:	0e 94 b1 0a 	call	0x1562	; 0x1562 <DIO_writePin>
		DIO_writePin(PORTB_ID,PIN2_ID,1);
    2c5c:	81 e0       	ldi	r24, 0x01	; 1
    2c5e:	62 e0       	ldi	r22, 0x02	; 2
    2c60:	41 e0       	ldi	r20, 0x01	; 1
    2c62:	0e 94 b1 0a 	call	0x1562	; 0x1562 <DIO_writePin>
    2c66:	18 c0       	rjmp	.+48     	; 0x2c98 <DcMotor_Rotate+0x60>
	}
	else if(state == A_CW){
    2c68:	89 81       	ldd	r24, Y+1	; 0x01
    2c6a:	81 30       	cpi	r24, 0x01	; 1
    2c6c:	59 f4       	brne	.+22     	; 0x2c84 <DcMotor_Rotate+0x4c>
		DIO_writePin(PORTB_ID,PIN1_ID,1);
    2c6e:	81 e0       	ldi	r24, 0x01	; 1
    2c70:	61 e0       	ldi	r22, 0x01	; 1
    2c72:	41 e0       	ldi	r20, 0x01	; 1
    2c74:	0e 94 b1 0a 	call	0x1562	; 0x1562 <DIO_writePin>
		DIO_writePin(PORTB_ID,PIN2_ID,0);
    2c78:	81 e0       	ldi	r24, 0x01	; 1
    2c7a:	62 e0       	ldi	r22, 0x02	; 2
    2c7c:	40 e0       	ldi	r20, 0x00	; 0
    2c7e:	0e 94 b1 0a 	call	0x1562	; 0x1562 <DIO_writePin>
    2c82:	0a c0       	rjmp	.+20     	; 0x2c98 <DcMotor_Rotate+0x60>
	}
	else{
		DIO_writePin(PORTB_ID,PIN1_ID,0);
    2c84:	81 e0       	ldi	r24, 0x01	; 1
    2c86:	61 e0       	ldi	r22, 0x01	; 1
    2c88:	40 e0       	ldi	r20, 0x00	; 0
    2c8a:	0e 94 b1 0a 	call	0x1562	; 0x1562 <DIO_writePin>
		DIO_writePin(PORTB_ID,PIN2_ID,0);
    2c8e:	81 e0       	ldi	r24, 0x01	; 1
    2c90:	62 e0       	ldi	r22, 0x02	; 2
    2c92:	40 e0       	ldi	r20, 0x00	; 0
    2c94:	0e 94 b1 0a 	call	0x1562	; 0x1562 <DIO_writePin>
	}


}
    2c98:	0f 90       	pop	r0
    2c9a:	0f 90       	pop	r0
    2c9c:	cf 91       	pop	r28
    2c9e:	df 91       	pop	r29
    2ca0:	08 95       	ret

00002ca2 <APP_init>:
#include "app.h"

#include "../MCUAL/DIO/DIO.h"

void APP_init(void)
{
    2ca2:	df 93       	push	r29
    2ca4:	cf 93       	push	r28
    2ca6:	cd b7       	in	r28, 0x3d	; 61
    2ca8:	de b7       	in	r29, 0x3e	; 62
    2caa:	66 97       	sbiw	r28, 0x16	; 22
    2cac:	0f b6       	in	r0, 0x3f	; 63
    2cae:	f8 94       	cli
    2cb0:	de bf       	out	0x3e, r29	; 62
    2cb2:	0f be       	out	0x3f, r0	; 63
    2cb4:	cd bf       	out	0x3d, r28	; 61
//	/*init timer */
//
//	TIMER0_init(&timer0_config_var);

	/*init LCD*/
	LCD_init();
    2cb6:	0e 94 e4 10 	call	0x21c8	; 0x21c8 <LCD_init>
	LCD_clearScreen();
    2cba:	0e 94 8f 15 	call	0x2b1e	; 0x2b1e <LCD_clearScreen>

	DcMotor_Init();
    2cbe:	0e 94 01 16 	call	0x2c02	; 0x2c02 <DcMotor_Init>

	/*use user custom data type to set it with configuration for SPI*/
	SPI_configType  spi_config_var = {MASTER,IDLE_LOW,SHIFT_SAMPLE_DATA};
    2cc2:	ce 01       	movw	r24, r28
    2cc4:	0f 96       	adiw	r24, 0x0f	; 15
    2cc6:	9b 8b       	std	Y+19, r25	; 0x13
    2cc8:	8a 8b       	std	Y+18, r24	; 0x12
    2cca:	eb e7       	ldi	r30, 0x7B	; 123
    2ccc:	f1 e0       	ldi	r31, 0x01	; 1
    2cce:	fd 8b       	std	Y+21, r31	; 0x15
    2cd0:	ec 8b       	std	Y+20, r30	; 0x14
    2cd2:	f3 e0       	ldi	r31, 0x03	; 3
    2cd4:	fe 8b       	std	Y+22, r31	; 0x16
    2cd6:	ec 89       	ldd	r30, Y+20	; 0x14
    2cd8:	fd 89       	ldd	r31, Y+21	; 0x15
    2cda:	00 80       	ld	r0, Z
    2cdc:	8c 89       	ldd	r24, Y+20	; 0x14
    2cde:	9d 89       	ldd	r25, Y+21	; 0x15
    2ce0:	01 96       	adiw	r24, 0x01	; 1
    2ce2:	9d 8b       	std	Y+21, r25	; 0x15
    2ce4:	8c 8b       	std	Y+20, r24	; 0x14
    2ce6:	ea 89       	ldd	r30, Y+18	; 0x12
    2ce8:	fb 89       	ldd	r31, Y+19	; 0x13
    2cea:	00 82       	st	Z, r0
    2cec:	8a 89       	ldd	r24, Y+18	; 0x12
    2cee:	9b 89       	ldd	r25, Y+19	; 0x13
    2cf0:	01 96       	adiw	r24, 0x01	; 1
    2cf2:	9b 8b       	std	Y+19, r25	; 0x13
    2cf4:	8a 8b       	std	Y+18, r24	; 0x12
    2cf6:	9e 89       	ldd	r25, Y+22	; 0x16
    2cf8:	91 50       	subi	r25, 0x01	; 1
    2cfa:	9e 8b       	std	Y+22, r25	; 0x16
    2cfc:	ee 89       	ldd	r30, Y+22	; 0x16
    2cfe:	ee 23       	and	r30, r30
    2d00:	51 f7       	brne	.-44     	; 0x2cd6 <APP_init+0x34>

	/*init SPI*/
	SPI_init(&spi_config_var);
    2d02:	ce 01       	movw	r24, r28
    2d04:	0f 96       	adiw	r24, 0x0f	; 15
    2d06:	0e 94 ea 07 	call	0xfd4	; 0xfd4 <SPI_init>



	/*init TC72 temperature sensro*/

	TC72_init(CONTINOUS_TEMP_CONVERSION);
    2d0a:	80 e0       	ldi	r24, 0x00	; 0
    2d0c:	0e 94 57 0e 	call	0x1cae	; 0x1cae <TC72_init>
    2d10:	80 e0       	ldi	r24, 0x00	; 0
    2d12:	90 e0       	ldi	r25, 0x00	; 0
    2d14:	a6 e1       	ldi	r26, 0x16	; 22
    2d16:	b3 e4       	ldi	r27, 0x43	; 67
    2d18:	8b 87       	std	Y+11, r24	; 0x0b
    2d1a:	9c 87       	std	Y+12, r25	; 0x0c
    2d1c:	ad 87       	std	Y+13, r26	; 0x0d
    2d1e:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    2d20:	6b 85       	ldd	r22, Y+11	; 0x0b
    2d22:	7c 85       	ldd	r23, Y+12	; 0x0c
    2d24:	8d 85       	ldd	r24, Y+13	; 0x0d
    2d26:	9e 85       	ldd	r25, Y+14	; 0x0e
    2d28:	20 e0       	ldi	r18, 0x00	; 0
    2d2a:	30 e0       	ldi	r19, 0x00	; 0
    2d2c:	4a e7       	ldi	r20, 0x7A	; 122
    2d2e:	53 e4       	ldi	r21, 0x43	; 67
    2d30:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    2d34:	dc 01       	movw	r26, r24
    2d36:	cb 01       	movw	r24, r22
    2d38:	8f 83       	std	Y+7, r24	; 0x07
    2d3a:	98 87       	std	Y+8, r25	; 0x08
    2d3c:	a9 87       	std	Y+9, r26	; 0x09
    2d3e:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    2d40:	6f 81       	ldd	r22, Y+7	; 0x07
    2d42:	78 85       	ldd	r23, Y+8	; 0x08
    2d44:	89 85       	ldd	r24, Y+9	; 0x09
    2d46:	9a 85       	ldd	r25, Y+10	; 0x0a
    2d48:	20 e0       	ldi	r18, 0x00	; 0
    2d4a:	30 e0       	ldi	r19, 0x00	; 0
    2d4c:	40 e8       	ldi	r20, 0x80	; 128
    2d4e:	5f e3       	ldi	r21, 0x3F	; 63
    2d50:	0e 94 a9 03 	call	0x752	; 0x752 <__ltsf2>
    2d54:	88 23       	and	r24, r24
    2d56:	2c f4       	brge	.+10     	; 0x2d62 <APP_init+0xc0>
		__ticks = 1;
    2d58:	81 e0       	ldi	r24, 0x01	; 1
    2d5a:	90 e0       	ldi	r25, 0x00	; 0
    2d5c:	9e 83       	std	Y+6, r25	; 0x06
    2d5e:	8d 83       	std	Y+5, r24	; 0x05
    2d60:	3f c0       	rjmp	.+126    	; 0x2de0 <APP_init+0x13e>
	else if (__tmp > 65535)
    2d62:	6f 81       	ldd	r22, Y+7	; 0x07
    2d64:	78 85       	ldd	r23, Y+8	; 0x08
    2d66:	89 85       	ldd	r24, Y+9	; 0x09
    2d68:	9a 85       	ldd	r25, Y+10	; 0x0a
    2d6a:	20 e0       	ldi	r18, 0x00	; 0
    2d6c:	3f ef       	ldi	r19, 0xFF	; 255
    2d6e:	4f e7       	ldi	r20, 0x7F	; 127
    2d70:	57 e4       	ldi	r21, 0x47	; 71
    2d72:	0e 94 49 03 	call	0x692	; 0x692 <__gtsf2>
    2d76:	18 16       	cp	r1, r24
    2d78:	4c f5       	brge	.+82     	; 0x2dcc <APP_init+0x12a>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    2d7a:	6b 85       	ldd	r22, Y+11	; 0x0b
    2d7c:	7c 85       	ldd	r23, Y+12	; 0x0c
    2d7e:	8d 85       	ldd	r24, Y+13	; 0x0d
    2d80:	9e 85       	ldd	r25, Y+14	; 0x0e
    2d82:	20 e0       	ldi	r18, 0x00	; 0
    2d84:	30 e0       	ldi	r19, 0x00	; 0
    2d86:	40 e2       	ldi	r20, 0x20	; 32
    2d88:	51 e4       	ldi	r21, 0x41	; 65
    2d8a:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    2d8e:	dc 01       	movw	r26, r24
    2d90:	cb 01       	movw	r24, r22
    2d92:	bc 01       	movw	r22, r24
    2d94:	cd 01       	movw	r24, r26
    2d96:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2d9a:	dc 01       	movw	r26, r24
    2d9c:	cb 01       	movw	r24, r22
    2d9e:	9e 83       	std	Y+6, r25	; 0x06
    2da0:	8d 83       	std	Y+5, r24	; 0x05
    2da2:	0f c0       	rjmp	.+30     	; 0x2dc2 <APP_init+0x120>
    2da4:	89 e1       	ldi	r24, 0x19	; 25
    2da6:	90 e0       	ldi	r25, 0x00	; 0
    2da8:	9c 83       	std	Y+4, r25	; 0x04
    2daa:	8b 83       	std	Y+3, r24	; 0x03
    2dac:	8b 81       	ldd	r24, Y+3	; 0x03
    2dae:	9c 81       	ldd	r25, Y+4	; 0x04
    2db0:	01 97       	sbiw	r24, 0x01	; 1
    2db2:	f1 f7       	brne	.-4      	; 0x2db0 <APP_init+0x10e>
    2db4:	9c 83       	std	Y+4, r25	; 0x04
    2db6:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    2db8:	8d 81       	ldd	r24, Y+5	; 0x05
    2dba:	9e 81       	ldd	r25, Y+6	; 0x06
    2dbc:	01 97       	sbiw	r24, 0x01	; 1
    2dbe:	9e 83       	std	Y+6, r25	; 0x06
    2dc0:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    2dc2:	8d 81       	ldd	r24, Y+5	; 0x05
    2dc4:	9e 81       	ldd	r25, Y+6	; 0x06
    2dc6:	00 97       	sbiw	r24, 0x00	; 0
    2dc8:	69 f7       	brne	.-38     	; 0x2da4 <APP_init+0x102>
    2dca:	14 c0       	rjmp	.+40     	; 0x2df4 <APP_init+0x152>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    2dcc:	6f 81       	ldd	r22, Y+7	; 0x07
    2dce:	78 85       	ldd	r23, Y+8	; 0x08
    2dd0:	89 85       	ldd	r24, Y+9	; 0x09
    2dd2:	9a 85       	ldd	r25, Y+10	; 0x0a
    2dd4:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2dd8:	dc 01       	movw	r26, r24
    2dda:	cb 01       	movw	r24, r22
    2ddc:	9e 83       	std	Y+6, r25	; 0x06
    2dde:	8d 83       	std	Y+5, r24	; 0x05
    2de0:	8d 81       	ldd	r24, Y+5	; 0x05
    2de2:	9e 81       	ldd	r25, Y+6	; 0x06
    2de4:	9a 83       	std	Y+2, r25	; 0x02
    2de6:	89 83       	std	Y+1, r24	; 0x01
    2de8:	89 81       	ldd	r24, Y+1	; 0x01
    2dea:	9a 81       	ldd	r25, Y+2	; 0x02
    2dec:	01 97       	sbiw	r24, 0x01	; 1
    2dee:	f1 f7       	brne	.-4      	; 0x2dec <APP_init+0x14a>
    2df0:	9a 83       	std	Y+2, r25	; 0x02
    2df2:	89 83       	std	Y+1, r24	; 0x01
	_delay_ms(150);

	PollTimer_start();
    2df4:	0e 94 65 07 	call	0xeca	; 0xeca <PollTimer_start>

	PollTimer_enableInterrupt();
    2df8:	0e 94 77 07 	call	0xeee	; 0xeee <PollTimer_enableInterrupt>

	POLL_setTime(500);
    2dfc:	64 ef       	ldi	r22, 0xF4	; 244
    2dfe:	71 e0       	ldi	r23, 0x01	; 1
    2e00:	80 e0       	ldi	r24, 0x00	; 0
    2e02:	90 e0       	ldi	r25, 0x00	; 0
    2e04:	0e 94 14 07 	call	0xe28	; 0xe28 <POLL_setTime>

	POLL_start();
    2e08:	0e 94 01 07 	call	0xe02	; 0xe02 <POLL_start>

	DIO_setupPinDirection(PORTA_ID,PIN0_ID,OUTPUT_PIN);
    2e0c:	80 e0       	ldi	r24, 0x00	; 0
    2e0e:	60 e0       	ldi	r22, 0x00	; 0
    2e10:	42 e0       	ldi	r20, 0x02	; 2
    2e12:	0e 94 0f 09 	call	0x121e	; 0x121e <DIO_setupPinDirection>
	TIMSK |= (1<<OCIE1A);
    2e16:	a9 e5       	ldi	r26, 0x59	; 89
    2e18:	b0 e0       	ldi	r27, 0x00	; 0
    2e1a:	e9 e5       	ldi	r30, 0x59	; 89
    2e1c:	f0 e0       	ldi	r31, 0x00	; 0
    2e1e:	80 81       	ld	r24, Z
    2e20:	80 61       	ori	r24, 0x10	; 16
    2e22:	8c 93       	st	X, r24
		SREG  |= (1<<7);
    2e24:	af e5       	ldi	r26, 0x5F	; 95
    2e26:	b0 e0       	ldi	r27, 0x00	; 0
    2e28:	ef e5       	ldi	r30, 0x5F	; 95
    2e2a:	f0 e0       	ldi	r31, 0x00	; 0
    2e2c:	80 81       	ld	r24, Z
    2e2e:	80 68       	ori	r24, 0x80	; 128
    2e30:	8c 93       	st	X, r24

}
    2e32:	66 96       	adiw	r28, 0x16	; 22
    2e34:	0f b6       	in	r0, 0x3f	; 63
    2e36:	f8 94       	cli
    2e38:	de bf       	out	0x3e, r29	; 62
    2e3a:	0f be       	out	0x3f, r0	; 63
    2e3c:	cd bf       	out	0x3d, r28	; 61
    2e3e:	cf 91       	pop	r28
    2e40:	df 91       	pop	r29
    2e42:	08 95       	ret

00002e44 <APP_implement>:


void APP_implement(void)
{
    2e44:	df 93       	push	r29
    2e46:	cf 93       	push	r28
    2e48:	cd b7       	in	r28, 0x3d	; 61
    2e4a:	de b7       	in	r29, 0x3e	; 62
    2e4c:	ff cf       	rjmp	.-2      	; 0x2e4c <APP_implement+0x8>

00002e4e <main>:
 */
#include "APP/app.h"
#include <avr/io.h>

void main(void)
{
    2e4e:	df 93       	push	r29
    2e50:	cf 93       	push	r28
    2e52:	cd b7       	in	r28, 0x3d	; 61
    2e54:	de b7       	in	r29, 0x3e	; 62
	APP_init();
    2e56:	0e 94 51 16 	call	0x2ca2	; 0x2ca2 <APP_init>

	APP_implement();
    2e5a:	0e 94 22 17 	call	0x2e44	; 0x2e44 <APP_implement>
}
    2e5e:	cf 91       	pop	r28
    2e60:	df 91       	pop	r29
    2e62:	08 95       	ret

00002e64 <__udivmodhi4>:
    2e64:	aa 1b       	sub	r26, r26
    2e66:	bb 1b       	sub	r27, r27
    2e68:	51 e1       	ldi	r21, 0x11	; 17
    2e6a:	07 c0       	rjmp	.+14     	; 0x2e7a <__udivmodhi4_ep>

00002e6c <__udivmodhi4_loop>:
    2e6c:	aa 1f       	adc	r26, r26
    2e6e:	bb 1f       	adc	r27, r27
    2e70:	a6 17       	cp	r26, r22
    2e72:	b7 07       	cpc	r27, r23
    2e74:	10 f0       	brcs	.+4      	; 0x2e7a <__udivmodhi4_ep>
    2e76:	a6 1b       	sub	r26, r22
    2e78:	b7 0b       	sbc	r27, r23

00002e7a <__udivmodhi4_ep>:
    2e7a:	88 1f       	adc	r24, r24
    2e7c:	99 1f       	adc	r25, r25
    2e7e:	5a 95       	dec	r21
    2e80:	a9 f7       	brne	.-22     	; 0x2e6c <__udivmodhi4_loop>
    2e82:	80 95       	com	r24
    2e84:	90 95       	com	r25
    2e86:	bc 01       	movw	r22, r24
    2e88:	cd 01       	movw	r24, r26
    2e8a:	08 95       	ret

00002e8c <__udivmodsi4>:
    2e8c:	a1 e2       	ldi	r26, 0x21	; 33
    2e8e:	1a 2e       	mov	r1, r26
    2e90:	aa 1b       	sub	r26, r26
    2e92:	bb 1b       	sub	r27, r27
    2e94:	fd 01       	movw	r30, r26
    2e96:	0d c0       	rjmp	.+26     	; 0x2eb2 <__udivmodsi4_ep>

00002e98 <__udivmodsi4_loop>:
    2e98:	aa 1f       	adc	r26, r26
    2e9a:	bb 1f       	adc	r27, r27
    2e9c:	ee 1f       	adc	r30, r30
    2e9e:	ff 1f       	adc	r31, r31
    2ea0:	a2 17       	cp	r26, r18
    2ea2:	b3 07       	cpc	r27, r19
    2ea4:	e4 07       	cpc	r30, r20
    2ea6:	f5 07       	cpc	r31, r21
    2ea8:	20 f0       	brcs	.+8      	; 0x2eb2 <__udivmodsi4_ep>
    2eaa:	a2 1b       	sub	r26, r18
    2eac:	b3 0b       	sbc	r27, r19
    2eae:	e4 0b       	sbc	r30, r20
    2eb0:	f5 0b       	sbc	r31, r21

00002eb2 <__udivmodsi4_ep>:
    2eb2:	66 1f       	adc	r22, r22
    2eb4:	77 1f       	adc	r23, r23
    2eb6:	88 1f       	adc	r24, r24
    2eb8:	99 1f       	adc	r25, r25
    2eba:	1a 94       	dec	r1
    2ebc:	69 f7       	brne	.-38     	; 0x2e98 <__udivmodsi4_loop>
    2ebe:	60 95       	com	r22
    2ec0:	70 95       	com	r23
    2ec2:	80 95       	com	r24
    2ec4:	90 95       	com	r25
    2ec6:	9b 01       	movw	r18, r22
    2ec8:	ac 01       	movw	r20, r24
    2eca:	bd 01       	movw	r22, r26
    2ecc:	cf 01       	movw	r24, r30
    2ece:	08 95       	ret

00002ed0 <__prologue_saves__>:
    2ed0:	2f 92       	push	r2
    2ed2:	3f 92       	push	r3
    2ed4:	4f 92       	push	r4
    2ed6:	5f 92       	push	r5
    2ed8:	6f 92       	push	r6
    2eda:	7f 92       	push	r7
    2edc:	8f 92       	push	r8
    2ede:	9f 92       	push	r9
    2ee0:	af 92       	push	r10
    2ee2:	bf 92       	push	r11
    2ee4:	cf 92       	push	r12
    2ee6:	df 92       	push	r13
    2ee8:	ef 92       	push	r14
    2eea:	ff 92       	push	r15
    2eec:	0f 93       	push	r16
    2eee:	1f 93       	push	r17
    2ef0:	cf 93       	push	r28
    2ef2:	df 93       	push	r29
    2ef4:	cd b7       	in	r28, 0x3d	; 61
    2ef6:	de b7       	in	r29, 0x3e	; 62
    2ef8:	ca 1b       	sub	r28, r26
    2efa:	db 0b       	sbc	r29, r27
    2efc:	0f b6       	in	r0, 0x3f	; 63
    2efe:	f8 94       	cli
    2f00:	de bf       	out	0x3e, r29	; 62
    2f02:	0f be       	out	0x3f, r0	; 63
    2f04:	cd bf       	out	0x3d, r28	; 61
    2f06:	09 94       	ijmp

00002f08 <__epilogue_restores__>:
    2f08:	2a 88       	ldd	r2, Y+18	; 0x12
    2f0a:	39 88       	ldd	r3, Y+17	; 0x11
    2f0c:	48 88       	ldd	r4, Y+16	; 0x10
    2f0e:	5f 84       	ldd	r5, Y+15	; 0x0f
    2f10:	6e 84       	ldd	r6, Y+14	; 0x0e
    2f12:	7d 84       	ldd	r7, Y+13	; 0x0d
    2f14:	8c 84       	ldd	r8, Y+12	; 0x0c
    2f16:	9b 84       	ldd	r9, Y+11	; 0x0b
    2f18:	aa 84       	ldd	r10, Y+10	; 0x0a
    2f1a:	b9 84       	ldd	r11, Y+9	; 0x09
    2f1c:	c8 84       	ldd	r12, Y+8	; 0x08
    2f1e:	df 80       	ldd	r13, Y+7	; 0x07
    2f20:	ee 80       	ldd	r14, Y+6	; 0x06
    2f22:	fd 80       	ldd	r15, Y+5	; 0x05
    2f24:	0c 81       	ldd	r16, Y+4	; 0x04
    2f26:	1b 81       	ldd	r17, Y+3	; 0x03
    2f28:	aa 81       	ldd	r26, Y+2	; 0x02
    2f2a:	b9 81       	ldd	r27, Y+1	; 0x01
    2f2c:	ce 0f       	add	r28, r30
    2f2e:	d1 1d       	adc	r29, r1
    2f30:	0f b6       	in	r0, 0x3f	; 63
    2f32:	f8 94       	cli
    2f34:	de bf       	out	0x3e, r29	; 62
    2f36:	0f be       	out	0x3f, r0	; 63
    2f38:	cd bf       	out	0x3d, r28	; 61
    2f3a:	ed 01       	movw	r28, r26
    2f3c:	08 95       	ret

00002f3e <itoa>:
    2f3e:	fb 01       	movw	r30, r22
    2f40:	9f 01       	movw	r18, r30
    2f42:	e8 94       	clt
    2f44:	42 30       	cpi	r20, 0x02	; 2
    2f46:	c4 f0       	brlt	.+48     	; 0x2f78 <itoa+0x3a>
    2f48:	45 32       	cpi	r20, 0x25	; 37
    2f4a:	b4 f4       	brge	.+44     	; 0x2f78 <itoa+0x3a>
    2f4c:	4a 30       	cpi	r20, 0x0A	; 10
    2f4e:	29 f4       	brne	.+10     	; 0x2f5a <itoa+0x1c>
    2f50:	97 fb       	bst	r25, 7
    2f52:	1e f4       	brtc	.+6      	; 0x2f5a <itoa+0x1c>
    2f54:	90 95       	com	r25
    2f56:	81 95       	neg	r24
    2f58:	9f 4f       	sbci	r25, 0xFF	; 255
    2f5a:	64 2f       	mov	r22, r20
    2f5c:	77 27       	eor	r23, r23
    2f5e:	0e 94 32 17 	call	0x2e64	; 0x2e64 <__udivmodhi4>
    2f62:	80 5d       	subi	r24, 0xD0	; 208
    2f64:	8a 33       	cpi	r24, 0x3A	; 58
    2f66:	0c f0       	brlt	.+2      	; 0x2f6a <itoa+0x2c>
    2f68:	89 5d       	subi	r24, 0xD9	; 217
    2f6a:	81 93       	st	Z+, r24
    2f6c:	cb 01       	movw	r24, r22
    2f6e:	00 97       	sbiw	r24, 0x00	; 0
    2f70:	a1 f7       	brne	.-24     	; 0x2f5a <itoa+0x1c>
    2f72:	16 f4       	brtc	.+4      	; 0x2f78 <itoa+0x3a>
    2f74:	5d e2       	ldi	r21, 0x2D	; 45
    2f76:	51 93       	st	Z+, r21
    2f78:	10 82       	st	Z, r1
    2f7a:	c9 01       	movw	r24, r18
    2f7c:	0c 94 c0 17 	jmp	0x2f80	; 0x2f80 <strrev>

00002f80 <strrev>:
    2f80:	dc 01       	movw	r26, r24
    2f82:	fc 01       	movw	r30, r24
    2f84:	67 2f       	mov	r22, r23
    2f86:	71 91       	ld	r23, Z+
    2f88:	77 23       	and	r23, r23
    2f8a:	e1 f7       	brne	.-8      	; 0x2f84 <strrev+0x4>
    2f8c:	32 97       	sbiw	r30, 0x02	; 2
    2f8e:	04 c0       	rjmp	.+8      	; 0x2f98 <strrev+0x18>
    2f90:	7c 91       	ld	r23, X
    2f92:	6d 93       	st	X+, r22
    2f94:	70 83       	st	Z, r23
    2f96:	62 91       	ld	r22, -Z
    2f98:	ae 17       	cp	r26, r30
    2f9a:	bf 07       	cpc	r27, r31
    2f9c:	c8 f3       	brcs	.-14     	; 0x2f90 <strrev+0x10>
    2f9e:	08 95       	ret

00002fa0 <_exit>:
    2fa0:	f8 94       	cli

00002fa2 <__stop_program>:
    2fa2:	ff cf       	rjmp	.-2      	; 0x2fa2 <__stop_program>
